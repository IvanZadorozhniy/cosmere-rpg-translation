const Filter = PIXI.Filter;
const utils = PIXI.utils;

/**
 * String identifier for the system used throughout other scripts.
 */
const SYSTEM_ID = 'cosmere-rpg';
/**
 * Author name of the system.
 */
const AUTHOR_NAME = 'The Metalworks';
/**
 * URL for the discord server.
 */
const METALWORKS_DISCORD_INVITE = 'https://discord.gg/GwGTMknXhp';
/**
 * URL for the GitHub repository's issue page.
 */
const GITHUB_ISSUES_URL = 'https://github.com/the-metalworks/cosmere-rpg/issues';
/**
 * URL for the GitHub repository's contributing page.
 */
const GITHUB_CONTRIBUTING_URL = 'https://github.com/the-metalworks/cosmere-rpg/blob/main/CONTRIBUTING.md';
const IMPORTED_RESOURCES = {
    PLOT_DICE_BLANK_BUMP: `systems/${SYSTEM_ID}/assets/art/plot_blank_bump.png`,
    PLOT_DICE_BLANK: `systems/${SYSTEM_ID}/assets/art/plot_blank.png`,
    PLOT_DICE_C2_BUMP: `systems/${SYSTEM_ID}/assets/art/plot_c2_bump.png`,
    PLOT_DICE_C2: `systems/${SYSTEM_ID}/assets/art/plot_c2.png`,
    PLOT_DICE_C4_BUMP: `systems/${SYSTEM_ID}/assets/art/plot_c4_bump.png`,
    PLOT_DICE_C4: `systems/${SYSTEM_ID}/assets/art/plot_c4.png`,
    PLOT_DICE_OP_BUMP: `systems/${SYSTEM_ID}/assets/art/plot_op_bump.png`,
    PLOT_DICE_OP: `systems/${SYSTEM_ID}/assets/art/plot_op.png`,
    PLOT_DICE_C2_IN_CHAT: `systems/${SYSTEM_ID}/assets/icons/svg/dice/dp_c2.svg`,
    PLOT_DICE_C4_IN_CHAT: `systems/${SYSTEM_ID}/assets/icons/svg/dice/dp_c4.svg`,
    PLOT_DICE_OP_IN_CHAT: `systems/${SYSTEM_ID}/assets/icons/svg/dice/dp_op.svg`,
};
const COMPENDIUMS = {
    ACTIONS: `${SYSTEM_ID}.actions`,
    COMPANIONS_AND_ADVERSARIES: `${SYSTEM_ID}.companions-and-adversaries`,
    HEROIC_PATHS: `${SYSTEM_ID}.heroic-paths`,
    ITEMS: `${SYSTEM_ID}.items`,
    STARTER_RULES: `${SYSTEM_ID}.starter-rules`,
    ROLL_TABLES: `${SYSTEM_ID}.tables`,
};

/**
 * Index of identifiers for system templates.
 */
const TEMPLATES = {
    GENERAL_TABS: 'general/tabs.hbs',
    GENERAL_SHEET_CORNERS: 'general/sheet-corners.hbs',
    GENERAL_SHEET_BACKGROUND: 'general/sheet-background.hbs',
    GENERAL_CONTEXT_MENU: 'general/context-menu.hbs',
    COMBAT_TRACKER: 'combat/combat-tracker.hbs',
    COMBAT_COMBATANT: 'combat/combatant.hbs',
    COMPONENT_DOCUMENT_DROP_LIST: 'general/components/document-drop-list.hbs',
    COMPONENT_ITEM_DROP_LIST: 'general/components/item-drop-list.hbs',
    COMPONENT_DOCUMENT_REFERENCE: 'general/components/document-reference.hbs',
    COMPONENT_MULTI_VALUE_SELECT: 'general/components/multi-value-select.hbs',
    COMPONENT_ID_INPUT: 'general/components/id-input.hbs',
    COMPONENT_MULTI_STATE_TOGGLE: 'general/components/multi-state-toggle.hbs',
    COMPONENT_EXPERTISES_LIST: 'general/components/expertises-list.hbs',
    COMPONENT_DOCUMENT_CHANGES_LIST: 'general/components/document-changes-list.hbs',
    // ACTOR BASE
    ACTOR_BASE_NAVIGATION: 'actors/parts/navigation.hbs',
    ACTOR_BASE_BOX_CORNERS: 'actors/parts/box-corners.hbs',
    ACTOR_BASE_SEARCH_BAR: 'actors/components/search-bar.hbs',
    ACTOR_BASE_ACTIONS_LIST: 'actors/components/actions-list.hbs',
    ACTOR_BASE_EFFECTS_LIST: 'actors/components/effects-list.hbs',
    ACTOR_BASE_EQUIPMENT_LIST: 'actors/components/equipment-list.hbs',
    ACTOR_BASE_INJURIES_LIST: 'actors/components/injuries-list.hbs',
    ACTOR_BASE_CURRENCY_LIST: 'actors/components/currency-list.hbs',
    ACTOR_BASE_ATTRIBUTES: 'actors/components/attributes.hbs',
    ACTOR_BASE_IMMUNITIES: 'actors/components/immunities.hbs',
    ACTOR_BASE_CONDITIONS: 'actors/components/conditions.hbs',
    ACTOR_BASE_DETAILS: 'actors/components/details.hbs',
    ACTOR_BASE_RESOURCE: 'actors/components/resource.hbs',
    ACTOR_BASE_SKILL: 'actors/components/skill.hbs',
    ACTOR_BASE_SKILLS_GROUP: 'actors/components/skills-group.hbs',
    ACTOR_BASE_NOTES_FIELDS: 'actors/components/notes-fields.hbs',
    // ACTOR CHARACTER
    ACTOR_CHARACTER_HEADER: 'actors/character/parts/header.hbs',
    ACTOR_CHARACTER_CONTENT: 'actors/character/parts/content.hbs',
    ACTOR_CHARACTER_DETAILS_TAB: 'actors/character/partials/char-details-tab.hbs',
    ACTOR_CHARACTER_ACTIONS_TAB: 'actors/character/partials/char-actions-tab.hbs',
    ACTOR_CHARACTER_EQUIPMENT_TAB: 'actors/character/partials/char-equipment-tab.hbs',
    ACTOR_CHARACTER_GOALS_TAB: 'actors/character/partials/char-goals-tab.hbs',
    ACTOR_CHARACTER_NOTES_TAB: 'actors/character/partials/char-notes-tab.hbs',
    ACTOR_CHARACTER_EFFECTS_TAB: 'actors/character/partials/char-effects-tab.hbs',
    ACTOR_CHARACTER_ANCESTRY: 'actors/character/components/ancestry.hbs',
    ACTOR_CHARACTER_CULTURE: 'actors/character/components/culture.hbs',
    ACTOR_CHARACTER_FAVORITES: 'actors/character/components/favorites.hbs',
    ACTOR_CHARACTER_PATHS: 'actors/character/components/paths.hbs',
    ACTOR_CHARACTER_CONNECTIONS_LIST: 'actors/character/components/connections-list.hbs',
    ACTOR_CHARACTER_GOALS_LIST: 'actors/character/components/goals-list.hbs',
    ACTOR_CHARACTER_SKILL_LINKED_ITEM: 'actors/character/components/skill-linked-item.hbs',
    // ACTOR ADVERSARY
    ACTOR_ADVERSARY_HEADER: 'actors/adversary/parts/header.hbs',
    ACTOR_ADVERSARY_CONTENT: 'actors/adversary/parts/content.hbs',
    ACTOR_ADVERSARY_ACTIONS_TAB: 'actors/adversary/partials/adv-actions-tab.hbs',
    ACTOR_ADVERSARY_EQUIPMENT_TAB: 'actors/adversary/partials/adv-equipment-tab.hbs',
    ACTOR_ADVERSARY_NOTES_TAB: 'actors/adversary/partials/adv-notes-tab.hbs',
    ACTOR_ADVERSARY_EFFECTS_TAB: 'actors/adversary/partials/adv-effects-tab.hbs',
    ACTOR_ADVERSARY_SKILLS: 'actors/adversary/components/skills.hbs',
    //ITEM
    ITEM_BASE_HEADER: 'item/parts/header.hbs',
    ITEM_BASE_CONTENT: 'item/parts/content.hbs',
    ITEM_BASE_PROPERTIES: 'item/components/properties.hbs',
    ITEM_ACTION_CONTENT: 'item/action/parts/content.hbs',
    ITEM_ANCESTRY_CONTENT: 'item/ancestry/parts/content.hbs',
    ITEM_ARMOR_CONTENT: 'item/armor/parts/content.hbs',
    ITEM_GOAL_CONTENT: 'item/goal/parts/content.hbs',
    ITEM_INJURY_CONTENT: 'item/injury/parts/content.hbs',
    ITEM_LOOT_CONTENT: 'item/loot/parts/content.hbs',
    ITEM_PATH_CONTENT: 'item/path/parts/content.hbs',
    ITEM_POWER_CONTENT: 'item/power/parts/content.hbs',
    ITEM_SPECIALTY_CONTENT: 'item/specialty/parts/content.hbs',
    ITEM_TALENT_CONTENT: 'item/talent/parts/content.hbs',
    ITEM_DESCRIPTION_TAB: 'item/partials/item-description-tab.hbs',
    ITEM_EFFECTS_TAB: 'item/partials/item-effects-tab.hbs',
    ITEM_DETAILS_TAB: 'item/partials/item-details-tab.hbs',
    ITEM_EVENTS_TAB: 'item/partials/item-events-tab.hbs',
    ITEM_INJURY_DETAILS_TAB: 'item/injury/partials/injury-details-tab.hbs',
    ITEM_TALENTS_TAB: 'item/partials/item-talents-tab.hbs',
    ITEM_SPECIALTY_DETAILS_TAB: 'item/specialty/partials/specialty-details-tab.hbs',
    ITEM_LOOT_DETAILS_TAB: 'item/loot/partials/loot-details-tab.hbs',
    ITEM_ARMOR_DETAILS_TAB: 'item/armor/partials/armor-details-tab.hbs',
    ITEM_ANCESTRY_DETAILS_TAB: 'item/ancestry/partials/ancestry-details-tab.hbs',
    ITEM_TALENT_DETAILS_TAB: 'item/talent/partials/talent-details-tab.hbs',
    ITEM_ACTION_DETAILS_TAB: 'item/action/partials/action-details-tab.hbs',
    ITEM_GOAL_DETAILS_TAB: 'item/goal/partials/goal-details-tab.hbs',
    ITEM_POWER_DETAILS_TAB: 'item/power/partials/power-details-tab.hbs',
    ITEM_PATH_DETAILS_TAB: 'item/path/partials/path-details-tab.hbs',
    ITEM_TALENT_TREE_NODE_TOOLTIP: 'item/talent-tree/partials/talent-tree-node-tooltip.hbs',
    ITEM_DETAILS_ID: 'item/components/details-id.hbs',
    ITEM_DETAILS_ACTIVATION: 'item/components/details-activation.hbs',
    ITEM_DETAILS_ATTACK: 'item/components/details-attack.hbs',
    ITEM_DETAILS_DAMAGE: 'item/components/details-damage.hbs',
    ITEM_DETAILS_EQUIP: 'item/components/details-equip.hbs',
    ITEM_DETAILS_DEFLECT: 'item/components/details-deflect.hbs',
    ITEM_DETAILS_MODALITY: 'item/components/details-modality.hbs',
    ITEM_DETAILS_TYPE: 'item/components/details-type.hbs',
    ITEM_DETAILS_TALENTS_PROVIDER: 'item/components/details-talents-provider.hbs',
    ITEM_DETAILS_LINKED_SKILLS: 'item/components/details-linked-skills.hbs',
    ITEM_EFFECTS_LIST: 'item/components/effects-list.hbs',
    ITEM_EVENT_RULES_LIST: 'item/components/event-rules-list.hbs',
    ITEM_ANCESTRY_TALENT_LIST: 'item/ancestry/components/advancement-talent-list.hbs',
    ITEM_ANCESTRY_BONUS_TALENTS: 'item/ancestry/components/bonus-talents.hbs',
    // ITEM EMBEDDINGS
    ITEM_TALENT_EMBED: 'item/talent/embed.hbs',
    ITEM_TALENT_TREE_EMBED: 'item/talent-tree/embed.hbs',
    ITEM_ACTION_EMBED: 'item/action/embed.hbs',
    ITEM_PATH_EMBED: 'item/path/embed.hbs',
    ITEM_ANCESTRY_EMBED: 'item/ancestry/embed.hbs',
    ITEM_GENERIC_EMBED: 'item/generic/embed.hbs',
    //CHAT
    CHAT_CARD_HEADER: 'chat/card-header.hbs',
    CHAT_CARD_CONTENT: 'chat/card-content.hbs',
    CHAT_CARD_SECTION: 'chat/card-section.hbs',
    CHAT_CARD_DESCRIPTION: 'chat/card-description.hbs',
    CHAT_CARD_INJURY: 'chat/card-injury.hbs',
    CHAT_CARD_DAMAGE_TAKEN: 'chat/card-damage-taken.hbs',
    CHAT_CARD_DAMAGE_BUTTONS: 'chat/card-damage-buttons.hbs',
    CHAT_CARD_TRAY_TARGETS: 'chat/card-tray-targets.hbs',
    CHAT_ROLL_D20: 'chat/roll-d20.hbs',
    CHAT_ROLL_DAMAGE: 'chat/roll-damage.hbs',
    CHAT_ROLL_TOOLTIP: 'chat/roll-tooltip.hbs',
    CHAT_OVERLAY_D20: 'chat/overlay-d20.hbs',
    CHAT_OVERLAY_CRIT: 'chat/overlay-crit.hbs',
    //DIALOGS
    DIALOG_ACTOR_EDIT_EXPERTISES: 'actors/dialogs/edit-expertises.hbs',
    DIALOG_ACTOR_EDIT_IMMUNITIES: 'actors/dialogs/edit-immunities.hbs',
    DIALOG_ACTOR_CONFIGURE_RESOURCE: 'actors/dialogs/configure-resource.hbs',
    DIALOG_ACTOR_CONFIGURE_DEFLECT: 'actors/dialogs/configure-deflect.hbs',
    DIALOG_ACTOR_CONFIGURE_DEFENSE: 'actors/dialogs/configure-defense.hbs',
    DIALOG_ACTOR_CONFIGURE_RECOVERY: 'actors/dialogs/configure-recovery-die.hbs',
    DIALOG_ACTOR_CONFIGURE_MOVEMENT: 'actors/dialogs/configure-movement-rate.hbs',
    DIALOG_ACTOR_CONFIGURE_SENSES: 'actors/dialogs/configure-senses-range.hbs',
    DIALOG_CHARACTER_SHORT_REST: 'actors/character/dialogs/short-rest.hbs',
    DIALOG_ADVERSARY_CONFIGURE_SKILLS: 'actors/adversary/dialogs/configure-skills.hbs',
    DIALOG_ADVERSARY_EDIT_CREATURE_TYPE: 'actors/adversary/dialogs/edit-creature-type.hbs',
    DIALOG_ITEM_CONSUME: 'item/dialog/item-consume.hbs',
    DIALOG_ITEM_EDIT_EVENT_RULE: 'item/dialog/edit-event-rule.hbs',
    DIALOG_CHAT_MODIFY_DAMAGE: 'chat/dialogs/damage-modifier.hbs',
    DIALOG_ROLL_PICK_DICE_RESULT: 'roll/dialogs/pick-dice-result.hbs',
    DIALOG_ROLL_CONFIGURATION: 'roll/dialogs/roll-configuration.hbs',
    DIALOG_EDIT_EXPERTISES: 'general/dialogs/edit-expertises.hbs',
    DIALOG_PICK: 'general/dialogs/pick.hbs',
    // ITEM EVENT SYSTEM HANDLERS
    IES_HANDLER_EXECUTE_MACRO: 'item/event-system/handlers/execute-macro.hbs',
    IES_HANDLER_GRANT_ITEMS: 'item/event-system/handlers/grant-items.hbs',
    IES_HANDLER_REMOVE_ITEMS: 'item/event-system/handlers/remove-items.hbs',
    IES_HANDLER_MODIFY_ATTRIBUTE: 'item/event-system/handlers/modify-attribute.hbs',
    IES_HANDLER_SET_ATTRIBUTE: 'item/event-system/handlers/set-attribute.hbs',
    IES_HANDLER_MODIFY_SKILL_RANK: 'item/event-system/handlers/modify-skill-rank.hbs',
    IES_HANDLER_SET_SKILL_RANK: 'item/event-system/handlers/set-skill-rank.hbs',
    IES_HANDLER_GRANT_EXPERTISES: 'item/event-system/handlers/grant-expertises.hbs',
    IES_HANDLER_REMOVE_EXPERTISES: 'item/event-system/handlers/remove-expertises.hbs',
    IES_HANDLER_USE_ITEM: 'item/event-system/handlers/use-item.hbs',
    IES_HANDLER_UPDATE_ITEM: 'item/event-system/handlers/update-item.hbs',
    IES_HANDLER_UPDATE_ACTOR: 'item/event-system/handlers/update-actor.hbs',
};
/**
 * Shortcut function to render a custom template from the system templates folder.
 * @param {string} template Name (or sub path) of the template in the templates folder.
 * @param {object} data The template data to render the template with.
 * @returns {Promise<string>} A rendered html template.
 * @private
 */
function renderSystemTemplate(template, data) {
    return renderTemplate(`systems/${SYSTEM_ID}/templates/${template}`, data);
}
const THEME_TAG = 'cosmere-theme';
/**
 * Set the theme on an element, removing the previous theme class in the process.
 * @param {HTMLElement} element Body or sheet element on which to set the theme data.
 * @param {Theme} [theme=Theme.Default] Theme key to set.
 * @param {string[]} [flags=[]] Additional theming flags to set.
 */
function setTheme(element, theme, flags = new Set()) {
    const previous = Array.from(element.classList).filter((c) => c.startsWith(THEME_TAG));
    element.classList.remove(...previous);
    element.classList.add(`${THEME_TAG}-${theme}`);
    element.dataset.theme = theme;
    element.dataset.themeFlags = Array.from(flags).join(' ');
}

var Skill;
(function (Skill) {
    Skill["Agility"] = "agi";
    Skill["Athletics"] = "ath";
    Skill["HeavyWeapons"] = "hwp";
    Skill["LightWeapons"] = "lwp";
    Skill["Stealth"] = "stl";
    Skill["Thievery"] = "thv";
    Skill["Crafting"] = "cra";
    Skill["Deduction"] = "ded";
    Skill["Discipline"] = "dis";
    Skill["Intimidation"] = "inm";
    Skill["Lore"] = "lor";
    Skill["Medicine"] = "med";
    Skill["Deception"] = "dec";
    Skill["Insight"] = "ins";
    Skill["Leadership"] = "lea";
    Skill["Perception"] = "prc";
    Skill["Persuasion"] = "prs";
    Skill["Survival"] = "sur";
})(Skill || (Skill = {}));
var DamageType;
(function (DamageType) {
    DamageType["Energy"] = "energy";
    DamageType["Impact"] = "impact";
    DamageType["Keen"] = "keen";
    DamageType["Spirit"] = "spirit";
    DamageType["Vital"] = "vital";
    DamageType["Healing"] = "heal";
})(DamageType || (DamageType = {}));

var AdvantageMode;
(function (AdvantageMode) {
    AdvantageMode["None"] = "none";
    AdvantageMode["Advantage"] = "advantage";
    AdvantageMode["Disadvantage"] = "disadvantage";
})(AdvantageMode || (AdvantageMode = {}));

const COSMERE = {
    sizes: {
        ["small" /* Size.Small */]: {
            label: 'COSMERE.Actor.Size.Small',
            size: 2.5,
            unit: 'feet',
        },
        ["medium" /* Size.Medium */]: {
            label: 'COSMERE.Actor.Size.Medium',
            size: 5,
            unit: 'feet',
        },
        ["large" /* Size.Large */]: {
            label: 'COSMERE.Actor.Size.Large',
            size: 10,
            unit: 'feet',
        },
        ["huge" /* Size.Huge */]: {
            label: 'COSMERE.Actor.Size.Huge',
            size: 15,
            unit: 'feet',
        },
        ["gargantuan" /* Size.Garguantuan */]: {
            label: 'COSMERE.Actor.Size.Gargantuan',
            size: 20,
            unit: 'feet',
        },
    },
    creatureTypes: {
        ["custom" /* CreatureType.Custom */]: {
            label: 'COSMERE.Actor.Type.Custom',
        },
        ["humanoid" /* CreatureType.Humanoid */]: {
            label: 'COSMERE.Actor.Type.Humanoid',
        },
        ["animal" /* CreatureType.Animal */]: {
            label: 'COSMERE.Actor.Type.Animal',
        },
    },
    movement: {
        types: {
            ["walk" /* MovementType.Walk */]: {
                label: 'COSMERE.Actor.Movement.Type.Walk',
            },
            ["swim" /* MovementType.Swim */]: {
                label: 'COSMERE.Actor.Movement.Type.Swim',
            },
            ["fly" /* MovementType.Fly */]: {
                label: 'COSMERE.Actor.Movement.Type.Fly',
            },
        },
    },
    themes: {
        ["default" /* Theme.Default */]: 'COSMERE.Theme.Default',
    },
    statuses: {
        ["afflicted" /* Status.Afflicted */]: {
            label: 'COSMERE.Status.Afflicted',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/afflicted.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#porazhyonnyj',
            condition: true,
        },
        ["blind" /* Status.Blind */]: {
            label: 'COSMERE.Status.Blind',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/blind.svg',
            condition: false,
        },
        ["burrowing" /* Status.Burrowing */]: {
            label: 'COSMERE.Status.Burrowing',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/burrowing.svg',
            condition: false,
        },
        ["determined" /* Status.Determined */]: {
            label: 'COSMERE.Status.Determined',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/determined.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#reshitelьnyj',
            condition: true,
        },
        ["disoriented" /* Status.Disoriented */]: {
            label: 'COSMERE.Status.Disoriented',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/disoriented.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#dezorientirovan',
            condition: true,
        },
        ["empowered" /* Status.Empowered */]: {
            label: 'COSMERE.Status.Empowered',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/empowered.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#ozaryonnyj',
            condition: true,
        },
        ["enhanced" /* Status.Enhanced */]: {
            label: 'COSMERE.Status.Enhanced',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/enhanced.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#usilenie',
            condition: true,
        },
        ["exhausted" /* Status.Exhausted */]: {
            label: 'COSMERE.Status.Exhausted',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/exhausted.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#istoshenie',
            condition: true,
            stackable: true,
            stacksDisplayTransform: (stacks) => (-stacks).toFixed(),
        },
        ["flying" /* Status.Flying */]: {
            label: 'COSMERE.Status.Flying',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/flying.svg',
            condition: false,
        },
        ["focused" /* Status.Focused */]: {
            label: 'COSMERE.Status.Focused',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/focused.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#sfokusirovan',
            condition: true,
        },
        ["hidden" /* Status.Hidden */]: {
            label: 'COSMERE.Status.Hidden',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/hidden.svg',
            condition: false,
        },
        ["immobilized" /* Status.Immobilized */]: {
            label: 'COSMERE.Status.Immobilized',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/immobilized.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#obezdvizhen',
            condition: true,
        },
        ["invisible" /* Status.Invisible */]: {
            label: 'COSMERE.Status.Invisible',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/invisible.svg',
            condition: false,
        },
        ["prone" /* Status.Prone */]: {
            label: 'COSMERE.Status.Prone',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/prone.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#sbityj-s-nog',
            condition: true,
        },
        ["restrained" /* Status.Restrained */]: {
            label: 'COSMERE.Status.Restrained',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/restrained.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#skovan',
            condition: true,
        },
        ["slowed" /* Status.Slowed */]: {
            label: 'COSMERE.Status.Slowed',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/slowed.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#zamedlen',
            condition: true,
        },
        ["stunned" /* Status.Stunned */]: {
            label: 'COSMERE.Status.Stunned',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/stunned.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#oshelomlen',
            condition: true,
        },
        ["surprised" /* Status.Surprised */]: {
            label: 'COSMERE.Status.Surprised',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/surprised.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#vzyat-vrasploh',
            condition: true,
        },
        ["unconscious" /* Status.Unconscious */]: {
            label: 'COSMERE.Status.Unconscious',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/unconscious.svg',
            reference: 'Compendium.cosmere-rpg.starter-rules.JournalEntry.4BfYSQ4DinrH4dPa.JournalEntryPage.jQvh7ULoKmh49sYA#bez-soznaniya',
            condition: true,
        },
        ["dead" /* Status.Dead */]: {
            label: 'COSMERE.Status.Dead',
            icon: 'systems/cosmere-rpg/assets/icons/svg/conditions/dead.svg',
            condition: true,
        },
    },
    injury: {
        types: {
            ["flesh_wound" /* InjuryType.FleshWound */]: {
                label: 'COSMERE.Item.Injuries.Duration.FleshWound',
                durationFormula: '1',
            },
            ["shallow_injury" /* InjuryType.ShallowInjury */]: {
                label: 'COSMERE.Item.Injuries.Duration.ShallowInjury',
                durationFormula: '1d6',
            },
            ["vicious_injury" /* InjuryType.ViciousInjury */]: {
                label: 'COSMERE.Item.Injuries.Duration.ViciousInjury',
                durationFormula: '6d6',
            },
            ["permanent_injury" /* InjuryType.PermanentInjury */]: {
                label: 'COSMERE.Item.Injuries.Duration.PermanentInjury',
            },
            ["death" /* InjuryType.Death */]: {
                label: 'COSMERE.Item.Injuries.Duration.Death',
            },
        },
        durationTable: 'Compendium.cosmere-rpg.tables.RollTable.qOXZSTYaP6jhnvBV',
    },
    attributeGroups: {
        ["phy" /* AttributeGroup.Physical */]: {
            key: "phy" /* AttributeGroup.Physical */,
            label: 'COSMERE.AttributeGroup.Physical.long',
            attributes: ["str" /* Attribute.Strength */, "spd" /* Attribute.Speed */],
            resource: "hea" /* Resource.Health */,
        },
        ["cog" /* AttributeGroup.Cognitive */]: {
            key: "cog" /* AttributeGroup.Cognitive */,
            label: 'COSMERE.AttributeGroup.Cognitive.long',
            attributes: ["int" /* Attribute.Intellect */, "wil" /* Attribute.Willpower */],
            resource: "foc" /* Resource.Focus */,
        },
        ["spi" /* AttributeGroup.Spiritual */]: {
            key: "spi" /* AttributeGroup.Spiritual */,
            label: 'COSMERE.AttributeGroup.Spiritual.long',
            attributes: ["awa" /* Attribute.Awareness */, "pre" /* Attribute.Presence */],
            resource: "inv" /* Resource.Investiture */,
        },
    },
    attributes: {
        ["str" /* Attribute.Strength */]: {
            key: "str" /* Attribute.Strength */,
            label: 'COSMERE.Actor.Attribute.Strength.long',
            labelShort: 'COSMERE.Actor.Attribute.Strength.short',
            skills: [Skill.Athletics, Skill.HeavyWeapons],
        },
        ["spd" /* Attribute.Speed */]: {
            key: "spd" /* Attribute.Speed */,
            label: 'COSMERE.Actor.Attribute.Speed.long',
            labelShort: 'COSMERE.Actor.Attribute.Speed.short',
            skills: [
                Skill.Agility,
                Skill.LightWeapons,
                Skill.Stealth,
                Skill.Thievery,
            ],
        },
        ["int" /* Attribute.Intellect */]: {
            key: "int" /* Attribute.Intellect */,
            label: 'COSMERE.Actor.Attribute.Intellect.long',
            labelShort: 'COSMERE.Actor.Attribute.Intellect.short',
            skills: [
                Skill.Crafting,
                Skill.Deduction,
                Skill.Lore,
                Skill.Medicine,
            ],
        },
        ["wil" /* Attribute.Willpower */]: {
            key: "wil" /* Attribute.Willpower */,
            label: 'COSMERE.Actor.Attribute.Willpower.long',
            labelShort: 'COSMERE.Actor.Attribute.Willpower.short',
            skills: [Skill.Discipline, Skill.Intimidation],
        },
        ["awa" /* Attribute.Awareness */]: {
            key: "awa" /* Attribute.Awareness */,
            label: 'COSMERE.Actor.Attribute.Awareness.long',
            labelShort: 'COSMERE.Actor.Attribute.Awareness.short',
            skills: [Skill.Insight, Skill.Perception, Skill.Survival],
        },
        ["pre" /* Attribute.Presence */]: {
            key: "pre" /* Attribute.Presence */,
            label: 'COSMERE.Actor.Attribute.Presence.long',
            labelShort: 'COSMERE.Actor.Attribute.Presence.short',
            skills: [Skill.Deception, Skill.Leadership, Skill.Persuasion],
        },
    },
    resources: {
        ["hea" /* Resource.Health */]: {
            key: "hea" /* Resource.Health */,
            label: 'COSMERE.Actor.Resource.Health',
            deflect: true,
            formula: '10 + @attr.str + @bonus',
        },
        ["foc" /* Resource.Focus */]: {
            key: "hea" /* Resource.Health */,
            label: 'COSMERE.Actor.Resource.Focus',
            formula: '2 + @attr.wil + @bonus',
        },
        ["inv" /* Resource.Investiture */]: {
            key: "hea" /* Resource.Health */,
            label: 'COSMERE.Actor.Resource.Investiture',
        },
    },
    skills: {
        [Skill.Agility]: {
            key: Skill.Agility,
            label: 'COSMERE.Actor.Skill.Agility',
            attribute: "spd" /* Attribute.Speed */,
            core: true,
        },
        [Skill.Athletics]: {
            key: Skill.Athletics,
            label: 'COSMERE.Actor.Skill.Athletics',
            attribute: "str" /* Attribute.Strength */,
            core: true,
        },
        [Skill.HeavyWeapons]: {
            key: Skill.HeavyWeapons,
            label: 'COSMERE.Actor.Skill.HeavyWeapons',
            attribute: "str" /* Attribute.Strength */,
            core: true,
        },
        [Skill.LightWeapons]: {
            key: Skill.LightWeapons,
            label: 'COSMERE.Actor.Skill.LightWeapons',
            attribute: "spd" /* Attribute.Speed */,
            core: true,
        },
        [Skill.Stealth]: {
            key: Skill.Stealth,
            label: 'COSMERE.Actor.Skill.Stealth',
            attribute: "spd" /* Attribute.Speed */,
            core: true,
        },
        [Skill.Thievery]: {
            key: Skill.Thievery,
            label: 'COSMERE.Actor.Skill.Thievery',
            attribute: "spd" /* Attribute.Speed */,
            core: true,
        },
        [Skill.Crafting]: {
            key: Skill.Crafting,
            label: 'COSMERE.Actor.Skill.Crafting',
            attribute: "int" /* Attribute.Intellect */,
            core: true,
        },
        [Skill.Deduction]: {
            key: Skill.Deduction,
            label: 'COSMERE.Actor.Skill.Deduction',
            attribute: "int" /* Attribute.Intellect */,
            core: true,
        },
        [Skill.Discipline]: {
            key: Skill.Discipline,
            label: 'COSMERE.Actor.Skill.Discipline',
            attribute: "wil" /* Attribute.Willpower */,
            core: true,
        },
        [Skill.Intimidation]: {
            key: Skill.Intimidation,
            label: 'COSMERE.Actor.Skill.Intimidation',
            attribute: "wil" /* Attribute.Willpower */,
            core: true,
        },
        [Skill.Lore]: {
            key: Skill.Lore,
            label: 'COSMERE.Actor.Skill.Lore',
            attribute: "int" /* Attribute.Intellect */,
            core: true,
        },
        [Skill.Medicine]: {
            key: Skill.Medicine,
            label: 'COSMERE.Actor.Skill.Medicine',
            attribute: "int" /* Attribute.Intellect */,
            core: true,
        },
        [Skill.Deception]: {
            key: Skill.Deception,
            label: 'COSMERE.Actor.Skill.Deception',
            attribute: "pre" /* Attribute.Presence */,
            core: true,
        },
        [Skill.Insight]: {
            key: Skill.Insight,
            label: 'COSMERE.Actor.Skill.Insight',
            attribute: "awa" /* Attribute.Awareness */,
            core: true,
        },
        [Skill.Leadership]: {
            key: Skill.Leadership,
            label: 'COSMERE.Actor.Skill.Leadership',
            attribute: "pre" /* Attribute.Presence */,
            core: true,
        },
        [Skill.Perception]: {
            key: Skill.Perception,
            label: 'COSMERE.Actor.Skill.Perception',
            attribute: "awa" /* Attribute.Awareness */,
            core: true,
        },
        [Skill.Persuasion]: {
            key: Skill.Persuasion,
            label: 'COSMERE.Actor.Skill.Persuasion',
            attribute: "pre" /* Attribute.Presence */,
            core: true,
        },
        [Skill.Survival]: {
            key: Skill.Survival,
            label: 'COSMERE.Actor.Skill.Survival',
            attribute: "awa" /* Attribute.Awareness */,
            core: true,
        },
    },
    advancement: {
        rules: [
            {
                level: 1,
                tier: 1,
                maxSkillRanks: 2,
                attributePoints: 12,
                health: 10,
                healthIncludeStrength: true,
                skillRanks: 4,
                talents: 1,
            }, // Level 1
            {
                level: 2,
                tier: 1,
                maxSkillRanks: 2,
                health: 5,
                skillRanks: 2,
                talents: 1,
            }, // Level 2
            {
                level: 3,
                tier: 1,
                maxSkillRanks: 2,
                attributePoints: 1,
                health: 5,
                skillRanks: 2,
                talents: 1,
            }, // Level 3
            {
                level: 4,
                tier: 1,
                maxSkillRanks: 2,
                health: 5,
                skillRanks: 2,
                talents: 1,
            }, // Level 4
            {
                level: 5,
                tier: 1,
                maxSkillRanks: 2,
                health: 5,
                skillRanks: 2,
                talents: 1,
            }, // Level 5
            {
                level: 6,
                tier: 2,
                maxSkillRanks: 3,
                attributePoints: 1,
                health: 4,
                healthIncludeStrength: true,
                skillRanks: 2,
                talents: 1,
            }, // Level 6
            {
                level: 7,
                tier: 2,
                maxSkillRanks: 3,
                health: 4,
                skillRanks: 2,
                talents: 1,
            }, // Level 7
            {
                level: 8,
                tier: 2,
                maxSkillRanks: 3,
                health: 4,
                skillRanks: 2,
                talents: 1,
            }, // Level 8
            {
                level: 9,
                tier: 2,
                maxSkillRanks: 3,
                attributePoints: 1,
                health: 4,
                skillRanks: 2,
                talents: 1,
            }, // Level 9
            {
                level: 10,
                tier: 2,
                maxSkillRanks: 3,
                health: 4,
                skillRanks: 2,
                talents: 1,
            }, // Level 10
            {
                level: 11,
                tier: 3,
                maxSkillRanks: 4,
                health: 3,
                healthIncludeStrength: true,
                skillRanks: 2,
                talents: 1,
            }, // Level 11
            {
                level: 12,
                tier: 3,
                maxSkillRanks: 4,
                attributePoints: 1,
                health: 3,
                skillRanks: 2,
                talents: 1,
            }, // Level 12
            {
                level: 13,
                tier: 3,
                maxSkillRanks: 4,
                health: 3,
                skillRanks: 2,
                talents: 1,
            }, // Level 13
            {
                level: 14,
                tier: 3,
                maxSkillRanks: 4,
                health: 3,
                skillRanks: 2,
                talents: 1,
            }, // Level 14
            {
                level: 15,
                tier: 3,
                maxSkillRanks: 4,
                attributePoints: 1,
                health: 3,
                skillRanks: 2,
                talents: 1,
            }, // Level 15
            {
                level: 16,
                tier: 4,
                maxSkillRanks: 5,
                health: 2,
                healthIncludeStrength: true,
                skillRanks: 2,
                talents: 1,
            }, // Level 16
            {
                level: 17,
                tier: 4,
                maxSkillRanks: 5,
                health: 2,
                skillRanks: 2,
                talents: 1,
            }, // Level 17
            {
                level: 18,
                tier: 4,
                maxSkillRanks: 5,
                attributePoints: 1,
                health: 2,
                skillRanks: 2,
                talents: 1,
            }, // Level 18
            {
                level: 19,
                tier: 4,
                maxSkillRanks: 5,
                health: 2,
                skillRanks: 2,
                talents: 1,
            }, // Level 19
            {
                level: 20,
                tier: 4,
                maxSkillRanks: 5,
                health: 2,
                skillRanks: 2,
                talents: 1,
            }, // Level 20
            {
                level: 21,
                tier: 5,
                maxSkillRanks: 5,
                health: 1,
                skillRanksOrTalents: 1,
            }, // Level 21
        ],
    },
    paths: {
        types: {
            ["heroic" /* PathType.Heroic */]: {
                label: 'COSMERE.Paths.Types.Heroic.Label',
            },
        },
    },
    items: {
        types: {
            ["weapon" /* ItemType.Weapon */]: {
                label: 'COSMERE.Item.Type.Weapon.label',
                labelPlural: 'COSMERE.Item.Type.Weapon.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Weapon.desc_placeholder',
            },
            ["armor" /* ItemType.Armor */]: {
                label: 'COSMERE.Item.Type.Armor.label',
                labelPlural: 'COSMERE.Item.Type.Armor.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Armor.desc_placeholder',
            },
            ["equipment" /* ItemType.Equipment */]: {
                label: 'COSMERE.Item.Type.Equipment.label',
                labelPlural: 'COSMERE.Item.Type.Equipment.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Equipment.desc_placeholder',
            },
            ["loot" /* ItemType.Loot */]: {
                label: 'COSMERE.Item.Type.Loot.label',
                labelPlural: 'COSMERE.Item.Type.Loot.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Loot.desc_placeholder',
            },
            ["ancestry" /* ItemType.Ancestry */]: {
                label: 'COSMERE.Item.Type.Ancestry.label',
                labelPlural: 'COSMERE.Item.Type.Ancestry.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Ancestry.desc_placeholder',
            },
            ["culture" /* ItemType.Culture */]: {
                label: 'COSMERE.Item.Type.Culture.label',
                labelPlural: 'COSMERE.Item.Type.Culture.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Culture.desc_placeholder',
            },
            ["path" /* ItemType.Path */]: {
                label: 'COSMERE.Item.Type.Path.label',
                labelPlural: 'COSMERE.Item.Type.Path.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Path.desc_placeholder',
            },
            ["specialty" /* ItemType.Specialty */]: {
                label: 'COSMERE.Item.Type.Specialty.label',
                labelPlural: 'COSMERE.Item.Type.Specialty.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Specialty.desc_placeholder',
            },
            ["talent" /* ItemType.Talent */]: {
                label: 'COSMERE.Item.Type.Talent.label',
                labelPlural: 'COSMERE.Item.Type.Talent.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Talent.desc_placeholder',
            },
            ["action" /* ItemType.Action */]: {
                label: 'COSMERE.Item.Type.Action.label',
                labelPlural: 'COSMERE.Item.Type.Action.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Action.desc_placeholder',
            },
            ["trait" /* ItemType.Trait */]: {
                label: 'COSMERE.Item.Type.Trait.label',
                labelPlural: 'COSMERE.Item.Type.Trait.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Trait.desc_placeholder',
            },
            ["injury" /* ItemType.Injury */]: {
                label: 'COSMERE.Item.Type.Injury.label',
                labelPlural: 'COSMERE.Item.Type.Injury.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Injury.desc_placeholder',
            },
            ["connection" /* ItemType.Connection */]: {
                label: 'COSMERE.Item.Type.Connection.label',
                labelPlural: 'COSMERE.Item.Type.Connection.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Connection.desc_placeholder',
            },
            ["goal" /* ItemType.Goal */]: {
                label: 'COSMERE.Item.Type.Goal.label',
                labelPlural: 'COSMERE.Item.Type.Goal.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Goal.desc_placeholder',
            },
            ["power" /* ItemType.Power */]: {
                label: 'COSMERE.Item.Type.Power.label',
                labelPlural: 'COSMERE.Item.Type.Power.label_plural',
                desc_placeholder: 'COSMERE.Item.Type.Power.desc_placeholder',
            },
            ["talent_tree" /* ItemType.TalentTree */]: {
                label: 'COSMERE.Item.Type.TalentTree.label',
                labelPlural: 'COSMERE.Item.Type.TalentTree.label_plural',
            },
        },
        activation: {
            types: {
                ["none" /* ActivationType.None */]: {
                    label: 'GENERIC.None',
                },
                ["skill_test" /* ActivationType.SkillTest */]: {
                    label: 'COSMERE.Item.Activation.Type.SkillTest',
                },
                ["utility" /* ActivationType.Utility */]: {
                    label: 'COSMERE.Item.Activation.Type.Utility',
                },
            },
            consumeTypes: {
                ["resource" /* ItemConsumeType.Resource */]: {
                    label: 'COSMERE.Item.Activation.ConsumeType.Resource.Label',
                },
                ["item" /* ItemConsumeType.Item */]: {
                    label: 'COSMERE.Item.Activation.ConsumeType.Item.Label',
                },
            },
            uses: {
                types: {
                    ["use" /* ItemUseType.Use */]: {
                        label: 'COSMERE.Item.Activation.Uses.Types.Use.Singular',
                        labelPlural: 'COSMERE.Item.Activation.Uses.Types.Use.Plural',
                    },
                    ["charge" /* ItemUseType.Charge */]: {
                        label: 'COSMERE.Item.Activation.Uses.Types.Charge.Singular',
                        labelPlural: 'COSMERE.Item.Activation.Uses.Types.Charge.Plural',
                    },
                },
                recharge: {
                    ["per_scene" /* ItemRechargeType.PerScene */]: {
                        label: 'COSMERE.Item.Activation.Uses.Recharge.PerScene',
                    },
                },
            },
        },
        equip: {
            types: {
                ["wear" /* EquipType.Wear */]: {
                    label: 'COSMERE.Item.Equip.Types.Wear.Label',
                },
                ["hold" /* EquipType.Hold */]: {
                    label: 'COSMERE.Item.Equip.Types.Hold.Label',
                },
            },
            hold: {
                ["one_handed" /* HoldType.OneHanded */]: {
                    label: 'COSMERE.Item.Equip.Hold.OneHanded.Label',
                },
                ["two_handed" /* HoldType.TwoHanded */]: {
                    label: 'COSMERE.Item.Equip.Hold.TwoHanded.Label',
                },
            },
            hand: {
                ["main_hand" /* EquipHand.Main */]: {
                    label: 'COSMERE.Item.Equip.Hand.Main.Label',
                },
                ["off_hand" /* EquipHand.Off */]: {
                    label: 'COSMERE.Item.Equip.Hand.Off.Label',
                },
            },
        },
        weapon: {
            types: {
                ["light_wpn" /* WeaponType.Light */]: {
                    label: 'COSMERE.Item.Weapon.Type.Light',
                    skill: Skill.LightWeapons,
                },
                ["heavy_wpn" /* WeaponType.Heavy */]: {
                    label: 'COSMERE.Item.Weapon.Type.Heavy',
                    skill: Skill.HeavyWeapons,
                },
                ["special_wpn" /* WeaponType.Special */]: {
                    label: 'COSMERE.Item.Weapon.Type.Special',
                },
            },
        },
        equipment: {
            types: {
                ["basic" /* EquipmentType.Basic */]: {
                    label: 'COSMERE.Item.Equipment.Type.Basic',
                },
            },
        },
        talent: {
            types: {
                ["ancestry" /* Talent.Type.Ancestry */]: {
                    label: 'COSMERE.Item.Talent.Type.Ancestry',
                },
                ["path" /* Talent.Type.Path */]: {
                    label: 'COSMERE.Item.Talent.Type.Path',
                },
                ["power" /* Talent.Type.Power */]: {
                    label: 'COSMERE.Item.Talent.Type.Power',
                },
            },
        },
        talentTree: {
            node: {
                prerequisite: {
                    types: {
                        ["talent" /* TalentTree.Node.Prerequisite.Type.Talent */]: 'COSMERE.Item.Talent.Prerequisite.Type.talent',
                        ["attribute" /* TalentTree.Node.Prerequisite.Type.Attribute */]: 'COSMERE.Item.Talent.Prerequisite.Type.attribute',
                        ["skill" /* TalentTree.Node.Prerequisite.Type.Skill */]: 'COSMERE.Item.Talent.Prerequisite.Type.skill',
                        ["connection" /* TalentTree.Node.Prerequisite.Type.Connection */]: 'COSMERE.Item.Talent.Prerequisite.Type.connection',
                        ["level" /* TalentTree.Node.Prerequisite.Type.Level */]: 'COSMERE.Item.Talent.Prerequisite.Type.level',
                        ["ancestry" /* TalentTree.Node.Prerequisite.Type.Ancestry */]: 'COSMERE.Item.Talent.Prerequisite.Type.ancestry',
                        ["culture" /* TalentTree.Node.Prerequisite.Type.Culture */]: 'COSMERE.Item.Talent.Prerequisite.Type.culture',
                        ["goal" /* TalentTree.Node.Prerequisite.Type.Goal */]: 'COSMERE.Item.Talent.Prerequisite.Type.goal',
                    },
                },
            },
        },
        events: {
            types: {}, // Default events registered using the api
            handlers: {}, // Default handlers registered using the api
        },
    },
    currencies: {},
    // TODO: These should reference their respective item ids in the compendium
    weapons: {
        ["improvised" /* WeaponId.Improvised */]: {
            label: 'COSMERE.Item.Weapon.Improvised',
            reference: '',
        },
        ["unarmed" /* WeaponId.Unarmed */]: {
            label: 'COSMERE.Item.Weapon.Unarmed',
            reference: '',
        },
    },
    armors: {},
    expertiseTypes: {
        ["armor" /* ExpertiseType.Armor */]: {
            label: 'COSMERE.Actor.Character.Expertise.Armor',
            configRegistryKey: 'armors',
            icon: 'fas fa-helmet-battle',
        },
        ["cultural" /* ExpertiseType.Cultural */]: {
            label: 'COSMERE.Actor.Character.Expertise.Cultural',
            configRegistryKey: 'cultures',
            icon: 'far fa-earth-asia',
        },
        ["specialist" /* ExpertiseType.Specialist */]: {
            label: 'COSMERE.Actor.Character.Expertise.Specialist',
            icon: 'fas fa-award',
        },
        ["utility" /* ExpertiseType.Utility */]: {
            label: 'COSMERE.Actor.Character.Expertise.Utility',
            icon: 'fas fa-wrench',
        },
        ["weapon" /* ExpertiseType.Weapon */]: {
            label: 'COSMERE.Actor.Character.Expertise.Weapon',
            configRegistryKey: 'weapons',
            icon: 'fas fa-sword',
        },
    },
    immunityTypes: {
        ["damage" /* ImmunityType.Damage */]: {
            label: 'GENERIC.Damage',
            icon: 'fas fa-heart-crack',
        },
        ["condition" /* ImmunityType.Condition */]: {
            label: 'GENERIC.Condition',
            icon: 'fas fa-bolt',
        },
    },
    traits: {
        weaponTraits: {
            ["cumbersome" /* WeaponTraitId.Cumbersome */]: {
                label: 'COSMERE.Item.Weapon.Trait.Cumbersome',
                hasValue: true,
            },
            ["dangerous" /* WeaponTraitId.Dangerous */]: {
                label: 'COSMERE.Item.Weapon.Trait.Dangerous',
            },
            ["deadly" /* WeaponTraitId.Deadly */]: {
                label: 'COSMERE.Item.Weapon.Trait.Deadly',
            },
            ["defensive" /* WeaponTraitId.Defensive */]: {
                label: 'COSMERE.Item.Weapon.Trait.Defensive',
            },
            ["discreet" /* WeaponTraitId.Discreet */]: {
                label: 'COSMERE.Item.Weapon.Trait.Discreet',
            },
            ["indirect" /* WeaponTraitId.Indirect */]: {
                label: 'COSMERE.Item.Weapon.Trait.Indirect',
            },
            ["loaded" /* WeaponTraitId.Loaded */]: {
                label: 'COSMERE.Item.Weapon.Trait.Loaded',
                hasValue: true,
            },
            ["momentum" /* WeaponTraitId.Momentum */]: {
                label: 'COSMERE.Item.Weapon.Trait.Momentum',
            },
            ["offhand" /* WeaponTraitId.Offhand */]: {
                label: 'COSMERE.Item.Weapon.Trait.Offhand',
            },
            ["pierce" /* WeaponTraitId.Pierce */]: {
                label: 'COSMERE.Item.Weapon.Trait.Pierce',
            },
            ["quickdraw" /* WeaponTraitId.Quickdraw */]: {
                label: 'COSMERE.Item.Weapon.Trait.Quickdraw',
            },
            ["thrown" /* WeaponTraitId.Thrown */]: {
                label: 'COSMERE.Item.Weapon.Trait.Thrown',
            },
            ["two_handed" /* WeaponTraitId.TwoHanded */]: {
                label: 'COSMERE.Item.Weapon.Trait.TwoHanded',
            },
            ["unique" /* WeaponTraitId.Unique */]: {
                label: 'COSMERE.Item.Weapon.Trait.Unique',
            },
            ["fragile" /* WeaponTraitId.Fragile */]: {
                label: 'COSMERE.Item.Weapon.Trait.Fragile',
            },
            ["reach" /* WeaponTraitId.Reach */]: {
                label: 'COSMERE.Item.Weapon.Trait.Reach',
            },
        },
        armorTraits: {
            ["cumbersome" /* ArmorTraitId.Cumbersome */]: {
                label: 'COSMERE.Item.Armor.Trait.Cumbersome',
                hasValue: true,
            },
            ["dangerous" /* ArmorTraitId.Dangerous */]: {
                label: 'COSMERE.Item.Armor.Trait.Dangerous',
            },
            ["presentable" /* ArmorTraitId.Presentable */]: {
                label: 'COSMERE.Item.Armor.Trait.Presentable',
            },
            ["unique" /* ArmorTraitId.Unique */]: {
                label: 'COSMERE.Item.Armor.Trait.Unique',
            },
        },
    },
    adversary: {
        roles: {
            ["minion" /* AdversaryRole.Minion */]: {
                label: 'COSMERE.Actor.Adversary.Role.Minion',
            },
            ["rival" /* AdversaryRole.Rival */]: {
                label: 'COSMERE.Actor.Adversary.Role.Rival',
            },
            ["boss" /* AdversaryRole.Boss */]: {
                label: 'COSMERE.Actor.Adversary.Role.Boss',
            },
        },
    },
    deflect: {
        sources: {
            ["none" /* DeflectSource.None */]: {
                label: 'GENERIC.None',
            },
            ["armor" /* DeflectSource.Armor */]: {
                label: 'COSMERE.Item.Type.Armor',
            },
        },
    },
    action: {
        types: {
            ["basic" /* ActionType.Basic */]: {
                label: 'COSMERE.Item.Action.Type.Basic.label',
                labelPlural: 'COSMERE.Item.Action.Type.Basic.label_plural',
            },
            ["ancestry" /* ActionType.Ancestry */]: {
                label: 'COSMERE.Item.Action.Type.Ancestry.label',
                labelPlural: 'COSMERE.Item.Action.Type.Ancestry.label_plural',
            },
            ["adversary" /* ActionType.Adversary */]: {
                label: 'COSMERE.Item.Action.Type.Adversary.label',
                labelPlural: 'COSMERE.Item.Action.Type.Adversary.label_plural',
            },
        },
        costs: {
            ["act" /* ActionCostType.Action */]: {
                label: 'COSMERE.Actor.ActionCosts.Action',
            },
            ["rea" /* ActionCostType.Reaction */]: {
                label: 'COSMERE.Actor.ActionCosts.Reaction',
            },
            ["fre" /* ActionCostType.FreeAction */]: {
                label: 'COSMERE.Actor.ActionCosts.FreeAction',
            },
            ["spe" /* ActionCostType.Special */]: {
                label: 'COSMERE.Actor.ActionCosts.Special',
            },
        },
    },
    attack: {
        types: {
            ["melee" /* AttackType.Melee */]: {
                label: 'COSMERE.Attack.Type.Melee',
            },
            ["ranged" /* AttackType.Ranged */]: {
                label: 'COSMERE.Attack.Type.Ranged',
            },
        },
    },
    power: {
        types: {
            ["none" /* PowerType.None */]: {
                label: 'COSMERE.Item.Type.Power.label',
                plural: 'COSMERE.Item.Type.Power.label_plural',
            },
        },
    },
    damageTypes: {
        [DamageType.Energy]: {
            label: 'COSMERE.DamageTypes.Energy',
            icon: 'systems/cosmere-rpg/assets/icons/svg/damage/energy.svg',
        },
        [DamageType.Impact]: {
            label: 'COSMERE.DamageTypes.Impact',
            icon: 'systems/cosmere-rpg/assets/icons/svg/damage/impact.svg',
        },
        [DamageType.Keen]: {
            label: 'COSMERE.DamageTypes.Keen',
            icon: 'systems/cosmere-rpg/assets/icons/svg/damage/keen.svg',
        },
        [DamageType.Spirit]: {
            label: 'COSMERE.DamageTypes.Spirit',
            icon: 'systems/cosmere-rpg/assets/icons/svg/damage/spirit.svg',
            ignoreDeflect: true,
        },
        [DamageType.Vital]: {
            label: 'COSMERE.DamageTypes.Vital',
            icon: 'systems/cosmere-rpg/assets/icons/svg/damage/vital.svg',
            ignoreDeflect: true,
        },
        [DamageType.Healing]: {
            label: 'COSMERE.DamageTypes.Healing',
            icon: 'systems/cosmere-rpg/assets/icons/svg/damage/healing.svg',
            ignoreDeflect: true,
        },
    },
    cultures: {},
    ancestries: {},
    units: {
        weight: ['lb'],
        distance: {
            ft: 'UNITS.Distance.Feet',
        },
    },
    scaling: {
        damage: {
            unarmed: {
                strength: [
                    { min: 0, max: 2, formula: '1' },
                    { min: 3, max: 4, formula: '1d4' },
                    { min: 5, max: 6, formula: '1d8' },
                    { min: 7, max: 8, formula: '2d6' },
                    { min: 9, max: Infinity, formula: '2d10' },
                ],
            },
        },
        power: {
            die: {
                ranks: [
                    { value: 1, formula: 'd4' },
                    { value: 2, formula: 'd6' },
                    { value: 3, formula: 'd8' },
                    { value: 4, formula: 'd10' },
                    { value: 5, formula: 'd12' },
                ],
            },
            effectSize: {
                ranks: [
                    { value: 1, formula: "small" /* Size.Small */ },
                    { value: 2, formula: "medium" /* Size.Medium */ },
                    { value: 3, formula: "large" /* Size.Large */ },
                    { value: 4, formula: "huge" /* Size.Huge */ },
                    { value: 5, formula: "gargantuan" /* Size.Garguantuan */ },
                ],
            },
        },
    },
    dice: {
        advantageModes: {
            [AdvantageMode.Disadvantage]: 'DICE.AdvantageMode.Disadvantage',
            [AdvantageMode.None]: 'DICE.AdvantageMode.None',
            [AdvantageMode.Advantage]: 'DICE.AdvantageMode.Advantage',
        },
    },
    sheet: {
        actor: {
            components: {
                actions: {
                    sections: {
                        static: {},
                        dynamic: {},
                    },
                },
            },
        },
    },
};

/// <reference path="./vector.d.ts" />
/**
 * Adds other to this point
 */
function add(b) {
    return new PIXI.Point(this.x + b.x, this.y + b.y);
}
/**
 * Subtracts other from this point
 */
function subtract(b) {
    return new PIXI.Point(this.x - b.x, this.y - b.y);
}
/**
 * Multiplies this point by another point
 */
function multiply(b) {
    return new PIXI.Point(this.x * b.x, this.y * b.y);
}
/**
 * Multiplies this point by a scalar value
 */
function multiplyScalar(scalar) {
    return new PIXI.Point(this.x * scalar, this.y * scalar);
}
/**
 * Computes the dot product of other with this point.
 * The dot product is the sum of the products of the corresponding components of two vectors
 */
function dot(b) {
    return this.x * b.x + this.y * b.y;
}
/**
 * Computes the cross product of other with this point.
 * Given two linearly independent R3 vectors a and b, the cross product, a × b (read "a cross b"),
 * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.
 * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and
 * the result becomes a vector that will only have magnitude on the z axis.
 *
 * This function returns the z component of the cross product of the two points.
 */
function cross(b) {
    return this.x * b.y - this.y * b.x;
}
/**
 * Computes a normalized version of this point.
 * A normalized vector is a vector of magnitude (length) 1.
 */
function normalize() {
    const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
    return new PIXI.Point(this.x / magnitude, this.y / magnitude);
}
/**
 * Computes the magnitude of this point (Euclidean distance from 0, 0).
 * Defined as the square root of the sum of the squares of each component.
 */
function magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
}
/**
 * Computes the projection of this point onto another point.
 * The projection of a vector a onto a vector b is the orthogonal projection of a onto b.
 * It is the vector in the direction of b that is closest to a.
 */
function project(b) {
    const normalizedScalarProjection = (this.x * b.x + this.y * b.y) / (b.x * b.x + b.y * b.y);
    return new PIXI.Point(normalizedScalarProjection * b.x, normalizedScalarProjection * b.y);
}
/**
 * Finds the distance between two points
 */
function distance(b) {
    // Find the length
    return this.subtract(b).magnitude();
}
function angle(b) {
    b = new PIXI.Point(b.x, b.y);
    // Calculate dot product
    const d = this.dot(b);
    // Calculate lengths
    const lenA = this.magnitude();
    const lenB = b.magnitude();
    // Calculate angle
    const rad = Math.acos(d / (lenA * lenB));
    const deg = Math.toDegrees(rad);
    return deg > 180 ? 360 - deg : deg;
}
function tanget() {
    const a = { x: this.x, y: this.y, z: 0 };
    const b = { x: 0, y: 0, z: 1 };
    return new PIXI.Point(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z).normalize();
}
function rotate(angle) {
    const rad = Math.toRadians(angle);
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    return new PIXI.Point(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
}
/* --- Define mixins --- */
const mixins = {
    add,
    subtract,
    multiply,
    multiplyScalar,
    dot,
    cross,
    normalize,
    magnitude,
    project,
    distance,
    angle,
    tanget,
    rotate,
};
Object.assign(PIXI.Point.prototype, mixins);

Hooks.once('diceSoNiceReady', (dice3d) => {
    dice3d.addSystem({ id: SYSTEM_ID, name: 'Cosmere RPG' }, true);
    dice3d.addDicePreset({
        type: 'dp',
        labels: [
            IMPORTED_RESOURCES.PLOT_DICE_C2,
            IMPORTED_RESOURCES.PLOT_DICE_C4,
            IMPORTED_RESOURCES.PLOT_DICE_BLANK,
            IMPORTED_RESOURCES.PLOT_DICE_BLANK,
            IMPORTED_RESOURCES.PLOT_DICE_OP,
            IMPORTED_RESOURCES.PLOT_DICE_OP,
        ],
        bumpMaps: [
            IMPORTED_RESOURCES.PLOT_DICE_C2_BUMP,
            IMPORTED_RESOURCES.PLOT_DICE_C4_BUMP,
            IMPORTED_RESOURCES.PLOT_DICE_BLANK_BUMP,
            IMPORTED_RESOURCES.PLOT_DICE_BLANK_BUMP,
            IMPORTED_RESOURCES.PLOT_DICE_OP_BUMP,
            IMPORTED_RESOURCES.PLOT_DICE_OP_BUMP,
        ],
        system: SYSTEM_ID,
    });
});

const { ApplicationV2: ApplicationV2$h, HandlebarsApplicationMixin: HandlebarsApplicationMixin$b } = foundry.applications.api;
class ReleaseNotesDialog extends HandlebarsApplicationMixin$b((ApplicationV2$h)) {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            resizable: true,
        },
        position: {
            width: 800,
        },
        classes: ['cosmere', 'dialog', 'release-notes'],
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        release: {
            template: 'systems/cosmere-rpg/release-notes.html',
        },
        patch: {
            template: 'systems/cosmere-rpg/patch-notes.html',
        },
    });
    patch;
    constructor(options = {}) {
        super({
            window: {
                title: game.i18n.localize('DIALOG.ReleaseNotes.Title'),
            },
        });
        this.patch = options.patch ?? false;
    }
    /* --- Statics --- */
    static async show(options = {}) {
        await new this(options).render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).attr('open', 'true');
        if (this.patch) {
            $(this.element).find('[data-application-part="release"]').hide();
            $(this.element).find('[data-application-part="patch"]').show();
        }
        else {
            $(this.element).find('[data-application-part="release"]').show();
            $(this.element).find('[data-application-part="patch"]').hide();
        }
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            version: game.system.version,
        });
    }
}

/**
 * Index of identifiers for system settings.
 */
const SETTINGS = {
    INTERNAL_FIRST_CREATION: 'firstTimeWorldCreation',
    INTERNAL_LATEST_VERSION: 'latestVersion',
    DIALOG_ROLL_SKIP_DEFAULT: 'skipRollDialogByDefault',
    DIALOG_DAMAGE_MODIFIER_SKIP_DEFAULT: 'skipDamageModDialogByDefault',
    CHAT_ENABLE_OVERLAY_BUTTONS: 'enableOverlayButtons',
    CHAT_ENABLE_APPLY_BUTTONS: 'enableApplyButtons',
    CHAT_ALWAYS_SHOW_BUTTONS: 'alwaysShowApplyButtons',
    APPLY_BUTTONS_TO: 'applyButtonsTo',
    SHEET_EXPAND_DESCRIPTION_DEFAULT: 'expandDescriptionByDefault',
    SHEET_SKILL_INCDEC_TOGGLE: 'skillIncrementDecrementToggle',
    SYSTEM_THEME: 'systemTheme',
};
/**
 * Register all of the system's settings.
 */
function registerSystemSettings() {
    game.settings.register(SYSTEM_ID, SETTINGS.INTERNAL_FIRST_CREATION, {
        name: 'First Time World Creation',
        scope: 'world',
        config: false,
        default: true,
        type: Boolean,
    });
    game.settings.register(SYSTEM_ID, SETTINGS.INTERNAL_LATEST_VERSION, {
        name: 'Latest Version',
        scope: 'world',
        config: false,
        default: '0.0.0',
        type: String,
    });
    // SHEET SETTINGS
    const sheetOptions = [
        {
            name: SETTINGS.SHEET_EXPAND_DESCRIPTION_DEFAULT,
            default: false,
            scope: 'client',
        },
        {
            name: SETTINGS.SHEET_SKILL_INCDEC_TOGGLE,
            default: false,
            scope: 'client',
        },
    ];
    sheetOptions.forEach((option) => {
        game.settings.register(SYSTEM_ID, option.name, {
            name: game.i18n.localize(`SETTINGS.${option.name}.name`),
            hint: game.i18n.localize(`SETTINGS.${option.name}.hint`),
            scope: option.scope,
            config: true,
            type: Boolean,
            default: option.default,
        });
    });
    // DIALOG SKIP SETTINGS
    const dialogOptions = [
        { name: SETTINGS.DIALOG_ROLL_SKIP_DEFAULT, default: false },
        { name: SETTINGS.DIALOG_DAMAGE_MODIFIER_SKIP_DEFAULT, default: true },
    ];
    dialogOptions.forEach((option) => {
        game.settings.register(SYSTEM_ID, option.name, {
            name: game.i18n.localize(`SETTINGS.${option.name}.name`),
            hint: game.i18n.localize(`SETTINGS.${option.name}.hint`),
            scope: 'client',
            config: true,
            type: Boolean,
            default: option.default,
        });
    });
    // CHAT SETTINGS
    const chatOptions = [
        { name: SETTINGS.CHAT_ENABLE_OVERLAY_BUTTONS, default: true },
        { name: SETTINGS.CHAT_ENABLE_APPLY_BUTTONS, default: true },
        { name: SETTINGS.CHAT_ALWAYS_SHOW_BUTTONS, default: true },
    ];
    chatOptions.forEach((option) => {
        game.settings.register(SYSTEM_ID, option.name, {
            name: game.i18n.localize(`SETTINGS.${option.name}.name`),
            hint: game.i18n.localize(`SETTINGS.${option.name}.hint`),
            scope: 'client',
            config: true,
            type: Boolean,
            default: option.default,
            requiresReload: true,
        });
    });
    game.settings.register(SYSTEM_ID, SETTINGS.APPLY_BUTTONS_TO, {
        name: game.i18n.localize(`SETTINGS.${SETTINGS.APPLY_BUTTONS_TO}.name`),
        hint: game.i18n.localize(`SETTINGS.${SETTINGS.APPLY_BUTTONS_TO}.hint`),
        scope: 'client',
        config: true,
        type: Number,
        default: 0 /* TargetingOptions.SelectedOnly */,
        requiresReload: true,
        choices: {
            [0 /* TargetingOptions.SelectedOnly */]: game.i18n.localize(`SETTINGS.${SETTINGS.APPLY_BUTTONS_TO}.choices.SelectedOnly`),
            [1 /* TargetingOptions.TargetedOnly */]: game.i18n.localize(`SETTINGS.${SETTINGS.APPLY_BUTTONS_TO}.choices.TargetedOnly`),
            [2 /* TargetingOptions.SelectedAndTargeted */]: game.i18n.localize(`SETTINGS.${SETTINGS.APPLY_BUTTONS_TO}.choices.SelectedAndTargeted`),
            [3 /* TargetingOptions.PrioritiseSelected */]: game.i18n.localize(`SETTINGS.${SETTINGS.APPLY_BUTTONS_TO}.choices.PrioritiseSelected`),
            [4 /* TargetingOptions.PrioritiseTargeted */]: game.i18n.localize(`SETTINGS.${SETTINGS.APPLY_BUTTONS_TO}.choices.PrioritiseTargeted`),
        },
    });
}
/**
 * Register additional settings after modules have had a chance to initialize to give them a chance to modify choices.
 */
function registerDeferredSettings() {
    game.settings.register(SYSTEM_ID, SETTINGS.SYSTEM_THEME, {
        name: game.i18n.localize(`SETTINGS.${SETTINGS.SYSTEM_THEME}.name`),
        hint: game.i18n.localize(`SETTINGS.${SETTINGS.SYSTEM_THEME}.hint`),
        scope: 'client',
        config: true,
        type: String,
        default: "default" /* Theme.Default */,
        choices: {
            ...CONFIG.COSMERE.themes,
        },
        onChange: (s) => setTheme(document.body, s),
    });
    setTheme(document.body, getSystemSetting(SETTINGS.SYSTEM_THEME));
}
/**
 * Index of identifiers for system keybindings.
 */
const KEYBINDINGS = {
    SKIP_DIALOG_DEFAULT: 'skipDialogDefault',
    SKIP_DIALOG_ADVANTAGE: 'skipDialogAdvantage',
    SKIP_DIALOG_DISADVANTAGE: 'skipDialogDisadvantage',
    SKIP_DIALOG_RAISE_STAKES: 'skipDialogRaiseStakes',
    CHANGE_QUANTITY_BY_5: 'changeQuantity5',
    CHANGE_QUANTITY_BY_10: 'changeQuantity10',
    CHANGE_QUANTITY_BY_50: 'changeQuantity50',
};
/**
 * Register all of the system's keybindings.
 */
function registerSystemKeybindings() {
    const keybindings = [
        {
            name: KEYBINDINGS.SKIP_DIALOG_DEFAULT,
            editable: [{ key: 'AltLeft' }, { key: 'AltRight' }],
        },
        {
            name: KEYBINDINGS.SKIP_DIALOG_ADVANTAGE,
            editable: [{ key: 'ShiftLeft' }, { key: 'ShiftRight' }],
        },
        {
            name: KEYBINDINGS.SKIP_DIALOG_DISADVANTAGE,
            editable: [
                { key: 'ControlLeft' },
                { key: 'ControlRight' },
                { key: 'OsLeft' },
                { key: 'OsRight' },
            ],
        },
        {
            name: KEYBINDINGS.SKIP_DIALOG_RAISE_STAKES,
            editable: [{ key: 'KeyQ' }],
        },
        {
            name: KEYBINDINGS.CHANGE_QUANTITY_BY_5,
            editable: [{ key: 'ShiftLeft' }, { key: 'ShiftRight' }],
        },
        {
            name: KEYBINDINGS.CHANGE_QUANTITY_BY_10,
            editable: [
                { key: 'ControlLeft' },
                { key: 'ControlRight' },
                { key: 'OsLeft' },
                { key: 'OsRight' },
            ],
        },
        {
            name: KEYBINDINGS.CHANGE_QUANTITY_BY_50,
            editable: [{ key: 'AltLeft' }, { key: 'AltRight' }],
        },
    ];
    keybindings.forEach((keybind) => {
        game.keybindings.register(SYSTEM_ID, keybind.name, {
            name: `KEYBINDINGS.${keybind.name}`,
            editable: keybind.editable,
        });
    });
}
/**
 * Retrieve a specific setting value for the provided key.
 * @param settingKey The identifier of the setting to retrieve.
 * @returns The value of the setting as set for the world/client.
 */
function getSystemSetting(settingKey) {
    return game.settings.get(SYSTEM_ID, settingKey);
}
/**
 * Set a specific setting value for the provided key.
 * @param settingKey  The identifier of the setting to set.
 * @param value The value to set the setting to.
 */
function setSystemSetting(settingKey, value) {
    return game.settings.set(SYSTEM_ID, settingKey, value);
}
/**
 * Retrieves an array of keybinding values for the provided key.
 * @param {string} keybindingKey The identifier of the keybinding to retrieve.
 * @returns {Array<object>} The value of the keybindings associated with the given key.
 */
function getSystemKeybinding(keybindingKey) {
    return game.keybindings.get(SYSTEM_ID, keybindingKey);
}

const HTML_TAG_REGEX = /<[^>]+>/g;
/**
 * Checks if a given HTML string has any content or is just whitespace.
 * @param htmlString The HTML string to check.
 * @returns True if the HTML string has content, false otherwise.
 */
function htmlStringHasContent(htmlString) {
    // If the string is undefined or null, return false
    if (!htmlString)
        return false;
    // Remove HTML tags and trim whitespace
    const content = htmlString.replace(HTML_TAG_REGEX, '').trim();
    // Check if the content is not empty
    return content.length > 0;
}
/**
 * Determine if the keys of a requested keybinding are pressed.
 * @param {string} action Keybinding action within the system namespace. Can have multiple keybindings associated.
 * @returns {boolean} True if one of the keybindings for the requested action are triggered, false otherwise.
 */
function areKeysPressed(action) {
    const keybinds = getSystemKeybinding(action);
    if (!keybinds || keybinds.length === 0) {
        return false;
    }
    const activeModifiers = {};
    const addModifiers = (key) => {
        if (hasKey(KeyboardManager.MODIFIER_CODES, key)) {
            KeyboardManager.MODIFIER_CODES[key].forEach((n) => (activeModifiers[n] = game.keyboard.downKeys.has(n)));
        }
    };
    addModifiers(KeyboardManager.MODIFIER_KEYS.CONTROL);
    addModifiers(KeyboardManager.MODIFIER_KEYS.SHIFT);
    addModifiers(KeyboardManager.MODIFIER_KEYS.ALT);
    return getSystemKeybinding(action).some((b) => {
        if (game.keyboard.downKeys.has(b.key) &&
            b.modifiers?.every((m) => activeModifiers[m]))
            return true;
        if (b.modifiers?.length)
            return false;
        return activeModifiers[b.key];
    });
}
/**
 * Checks if a given object has the given property key as a key for indexing.
 * Adding this check beforehand allows an object to be indexed by that key directly without typescript errors.
 * @param {T} obj The object to check for indexing.
 * @param {PropertyKey} key The key to check within the object.
 * @returns {boolean} True if the given object has requested property key, false otherwise.
 */
function hasKey(obj, key) {
    return key in obj;
}
/**
 * Converts entries from input forms that will include human-readable "none" into nulls for easier identification in code.
 */
function getNullableFromFormInput(formField) {
    return formField && formField !== NONE ? formField : null;
}
function determineConfigurationMode(...args) {
    const useOptions = args.length === 1
        ? args[0]
        : undefined;
    const [configure, advantage, disadvantage, raiseStakes] = args.length === 1
        ? [
            useOptions?.configurable,
            useOptions?.advantageMode !== undefined
                ? useOptions.advantageMode === AdvantageMode.Advantage
                : undefined,
            useOptions?.advantageMode !== undefined
                ? useOptions.advantageMode === AdvantageMode.Disadvantage
                : undefined,
            useOptions?.plotDie,
        ]
        : args;
    const modifiers = {
        advantage: areKeysPressed(KEYBINDINGS.SKIP_DIALOG_ADVANTAGE),
        disadvantage: areKeysPressed(KEYBINDINGS.SKIP_DIALOG_DISADVANTAGE),
        raiseStakes: areKeysPressed(KEYBINDINGS.SKIP_DIALOG_RAISE_STAKES),
    };
    const fastForward = configure !== undefined
        ? !configure
        : isFastForward() || Object.values(modifiers).some((k) => k);
    const hasAdvantage = advantage ?? modifiers.advantage;
    const hasDisadvantage = disadvantage ?? modifiers.disadvantage;
    const advantageMode = hasAdvantage
        ? AdvantageMode.Advantage
        : hasDisadvantage
            ? AdvantageMode.Disadvantage
            : AdvantageMode.None;
    const plotDie = raiseStakes ?? modifiers.raiseStakes;
    return { fastForward, advantageMode, plotDie };
}
/**
 * Processes pressed keys and selected system settings to determine if a roll should fast forward.
 * This function allows the swappable behaviour of the Skip/Show Dialog modifier key, making it behave correctly depending on the system setting selected by the user.
 * @returns {boolean} Whether a roll should fast forward or not.
 */
function isFastForward() {
    const skipKeyPressed = areKeysPressed(KEYBINDINGS.SKIP_DIALOG_DEFAULT);
    const skipByDefault = getSystemSetting(SETTINGS.DIALOG_ROLL_SKIP_DEFAULT);
    return ((skipByDefault && !skipKeyPressed) || (!skipByDefault && skipKeyPressed));
}
/**
 * Computes the constant value of a roll (i.e. total of numeric terms).
 * @param {Roll} roll The roll to calculate the constant total from.
 * @returns {number} The total constant value.
 */
function getConstantFromRoll(roll) {
    let previous;
    let constant = 0;
    for (const term of roll.terms) {
        if (term instanceof foundry.dice.terms.NumericTerm) {
            if (previous instanceof foundry.dice.terms.OperatorTerm &&
                previous.operator === '-') {
                constant -= term.number;
            }
            else {
                constant += term.number;
            }
        }
        else if (term instanceof foundry.dice.terms.FunctionTerm) {
            if (typeof term.total === 'number') {
                constant += term.total;
            }
        }
        previous = term;
    }
    return constant;
}
/**
 * Toggles a given Advantage Mode to the correct advantage mode given the corresponding click used.
 * @param {AdvantageMode} current The current Advantage Mode to cycle from.
 * @param {boolean} leftClick Was the click a left click or a right click.
 * @returns {AdvantageMode} The resulting cycled Advantage Mode.
 */
function toggleAdvantageMode(current, leftClick) {
    switch (current) {
        case AdvantageMode.None:
            return leftClick
                ? AdvantageMode.Advantage
                : AdvantageMode.Disadvantage;
        case AdvantageMode.Advantage:
            return leftClick ? AdvantageMode.None : AdvantageMode.Disadvantage;
        case AdvantageMode.Disadvantage:
            return leftClick ? AdvantageMode.Advantage : AdvantageMode.None;
    }
}
/**
 * Converts a list of the various parts of a formula into a displayable string.
 *
 * @param {string[]} diceParts A parts array as provided from the foundry Roll API.
 * @returns {string} The human readable display string for the formula (without terms aggregated).
 */
function getFormulaDisplayString(diceParts) {
    const joined = diceParts
        .join(' + ')
        .replace(/\+ -/g, '-')
        .replace(/\+ \+/g, '+');
    return joined.endsWith(' + ') || joined.endsWith(' - ')
        ? joined.substring(0, joined.length - 3)
        : joined;
}
/**
 * Gets the current set of tokens that are selected or targeted (or both) depending on the chosen setting.
 * @returns {Set} A set of tokens that the system considers as current targets.
 */
function getApplyTargets() {
    const setting = getSystemSetting(SETTINGS.APPLY_BUTTONS_TO);
    const applyToTargeted = setting === 1 /* TargetingOptions.TargetedOnly */ ||
        setting >= 2 /* TargetingOptions.SelectedAndTargeted */;
    const applyToSelected = setting === 0 /* TargetingOptions.SelectedOnly */ ||
        setting >= 2 /* TargetingOptions.SelectedAndTargeted */;
    const prioritiseTargeted = setting === 4 /* TargetingOptions.PrioritiseTargeted */;
    const prioritiseSelected = setting === 3 /* TargetingOptions.PrioritiseSelected */;
    const selectTokens = applyToSelected
        ? canvas.tokens.controlled
        : [];
    const targetTokens = applyToTargeted ? game.user.targets : new Set();
    if (prioritiseSelected && selectTokens.length > 0) {
        targetTokens.clear();
    }
    if (prioritiseTargeted && targetTokens.size > 0) {
        selectTokens.length = 0;
    }
    return new Set([...selectTokens, ...targetTokens]);
}
/**
 * Grab the targeted tokens and return relevant information on them.
 * @returns {TargetDescriptor[]}
 */
function getTargetDescriptors() {
    const targets = new Map();
    for (const token of game.user.targets) {
        const { name, img, system, uuid } = token.actor ?? {};
        const phy = system?.defenses.phy.value ?? 10;
        const cog = system?.defenses.cog.value ?? 10;
        const spi = system?.defenses.spi.value ?? 10;
        if (uuid) {
            targets.set(uuid, { name, img, uuid, def: { phy, cog, spi } });
        }
    }
    return Array.from(targets.values());
}
/**
 * Wrap callbacks in debounce mechanism.
 * Prevents multiple invocations of the same callback within a given delay.
 * If the `immediate` flag is set, the callback will be invoked immediately on the first call and then debounced for subsequent calls.
 * Otherwise, it will wait for the delay before invoking the callback.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function debounce(callback, delay, immediate = false) {
    let timeoutId = null;
    return function (...args) {
        const later = () => {
            timeoutId = null;
            if (!immediate)
                callback.apply(this, args);
        };
        const callNow = immediate && !timeoutId;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(later, delay);
        if (callNow)
            callback.apply(this, args);
    };
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var sparkMd5 = {exports: {}};

(function (module, exports) {
	(function (factory) {
	    {
	        // Node/CommonJS
	        module.exports = factory();
	    }
	}(function (undefined$1) {

	    /*
	     * Fastest md5 implementation around (JKM md5).
	     * Credits: Joseph Myers
	     *
	     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
	     * @see http://jsperf.com/md5-shootout/7
	     */

	    /* this function is much faster,
	      so if possible we use it. Some IEs
	      are the only ones I know of that
	      need the idiotic second function,
	      generated by an if clause.  */
	    var hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];

	    function md5cycle(x, k) {
	        var a = x[0],
	            b = x[1],
	            c = x[2],
	            d = x[3];

	        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
	        a  = (a << 7 | a >>> 25) + b | 0;
	        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
	        d  = (d << 12 | d >>> 20) + a | 0;
	        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
	        c  = (c << 17 | c >>> 15) + d | 0;
	        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
	        b  = (b << 22 | b >>> 10) + c | 0;
	        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
	        a  = (a << 7 | a >>> 25) + b | 0;
	        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
	        d  = (d << 12 | d >>> 20) + a | 0;
	        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
	        c  = (c << 17 | c >>> 15) + d | 0;
	        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
	        b  = (b << 22 | b >>> 10) + c | 0;
	        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
	        a  = (a << 7 | a >>> 25) + b | 0;
	        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
	        d  = (d << 12 | d >>> 20) + a | 0;
	        c += (d & a | ~d & b) + k[10] - 42063 | 0;
	        c  = (c << 17 | c >>> 15) + d | 0;
	        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
	        b  = (b << 22 | b >>> 10) + c | 0;
	        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
	        a  = (a << 7 | a >>> 25) + b | 0;
	        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
	        d  = (d << 12 | d >>> 20) + a | 0;
	        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
	        c  = (c << 17 | c >>> 15) + d | 0;
	        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
	        b  = (b << 22 | b >>> 10) + c | 0;

	        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
	        a  = (a << 5 | a >>> 27) + b | 0;
	        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
	        d  = (d << 9 | d >>> 23) + a | 0;
	        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
	        c  = (c << 14 | c >>> 18) + d | 0;
	        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
	        b  = (b << 20 | b >>> 12) + c | 0;
	        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
	        a  = (a << 5 | a >>> 27) + b | 0;
	        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
	        d  = (d << 9 | d >>> 23) + a | 0;
	        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
	        c  = (c << 14 | c >>> 18) + d | 0;
	        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
	        b  = (b << 20 | b >>> 12) + c | 0;
	        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
	        a  = (a << 5 | a >>> 27) + b | 0;
	        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
	        d  = (d << 9 | d >>> 23) + a | 0;
	        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
	        c  = (c << 14 | c >>> 18) + d | 0;
	        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
	        b  = (b << 20 | b >>> 12) + c | 0;
	        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
	        a  = (a << 5 | a >>> 27) + b | 0;
	        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
	        d  = (d << 9 | d >>> 23) + a | 0;
	        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
	        c  = (c << 14 | c >>> 18) + d | 0;
	        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
	        b  = (b << 20 | b >>> 12) + c | 0;

	        a += (b ^ c ^ d) + k[5] - 378558 | 0;
	        a  = (a << 4 | a >>> 28) + b | 0;
	        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
	        d  = (d << 11 | d >>> 21) + a | 0;
	        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
	        c  = (c << 16 | c >>> 16) + d | 0;
	        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
	        b  = (b << 23 | b >>> 9) + c | 0;
	        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
	        a  = (a << 4 | a >>> 28) + b | 0;
	        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
	        d  = (d << 11 | d >>> 21) + a | 0;
	        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
	        c  = (c << 16 | c >>> 16) + d | 0;
	        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
	        b  = (b << 23 | b >>> 9) + c | 0;
	        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
	        a  = (a << 4 | a >>> 28) + b | 0;
	        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
	        d  = (d << 11 | d >>> 21) + a | 0;
	        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
	        c  = (c << 16 | c >>> 16) + d | 0;
	        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
	        b  = (b << 23 | b >>> 9) + c | 0;
	        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
	        a  = (a << 4 | a >>> 28) + b | 0;
	        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
	        d  = (d << 11 | d >>> 21) + a | 0;
	        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
	        c  = (c << 16 | c >>> 16) + d | 0;
	        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
	        b  = (b << 23 | b >>> 9) + c | 0;

	        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
	        a  = (a << 6 | a >>> 26) + b | 0;
	        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
	        d  = (d << 10 | d >>> 22) + a | 0;
	        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
	        c  = (c << 15 | c >>> 17) + d | 0;
	        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
	        b  = (b << 21 |b >>> 11) + c | 0;
	        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
	        a  = (a << 6 | a >>> 26) + b | 0;
	        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
	        d  = (d << 10 | d >>> 22) + a | 0;
	        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
	        c  = (c << 15 | c >>> 17) + d | 0;
	        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
	        b  = (b << 21 |b >>> 11) + c | 0;
	        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
	        a  = (a << 6 | a >>> 26) + b | 0;
	        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
	        d  = (d << 10 | d >>> 22) + a | 0;
	        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
	        c  = (c << 15 | c >>> 17) + d | 0;
	        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
	        b  = (b << 21 |b >>> 11) + c | 0;
	        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
	        a  = (a << 6 | a >>> 26) + b | 0;
	        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
	        d  = (d << 10 | d >>> 22) + a | 0;
	        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
	        c  = (c << 15 | c >>> 17) + d | 0;
	        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
	        b  = (b << 21 | b >>> 11) + c | 0;

	        x[0] = a + x[0] | 0;
	        x[1] = b + x[1] | 0;
	        x[2] = c + x[2] | 0;
	        x[3] = d + x[3] | 0;
	    }

	    function md5blk(s) {
	        var md5blks = [],
	            i; /* Andy King said do it this way. */

	        for (i = 0; i < 64; i += 4) {
	            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
	        }
	        return md5blks;
	    }

	    function md5blk_array(a) {
	        var md5blks = [],
	            i; /* Andy King said do it this way. */

	        for (i = 0; i < 64; i += 4) {
	            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
	        }
	        return md5blks;
	    }

	    function md51(s) {
	        var n = s.length,
	            state = [1732584193, -271733879, -1732584194, 271733878],
	            i,
	            length,
	            tail,
	            tmp,
	            lo,
	            hi;

	        for (i = 64; i <= n; i += 64) {
	            md5cycle(state, md5blk(s.substring(i - 64, i)));
	        }
	        s = s.substring(i - 64);
	        length = s.length;
	        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	        for (i = 0; i < length; i += 1) {
	            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
	        }
	        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
	        if (i > 55) {
	            md5cycle(state, tail);
	            for (i = 0; i < 16; i += 1) {
	                tail[i] = 0;
	            }
	        }

	        // Beware that the final length might not fit in 32 bits so we take care of that
	        tmp = n * 8;
	        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
	        lo = parseInt(tmp[2], 16);
	        hi = parseInt(tmp[1], 16) || 0;

	        tail[14] = lo;
	        tail[15] = hi;

	        md5cycle(state, tail);
	        return state;
	    }

	    function md51_array(a) {
	        var n = a.length,
	            state = [1732584193, -271733879, -1732584194, 271733878],
	            i,
	            length,
	            tail,
	            tmp,
	            lo,
	            hi;

	        for (i = 64; i <= n; i += 64) {
	            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
	        }

	        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
	        // containing the last element of the parent array if the sub array specified starts
	        // beyond the length of the parent array - weird.
	        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
	        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

	        length = a.length;
	        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	        for (i = 0; i < length; i += 1) {
	            tail[i >> 2] |= a[i] << ((i % 4) << 3);
	        }

	        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
	        if (i > 55) {
	            md5cycle(state, tail);
	            for (i = 0; i < 16; i += 1) {
	                tail[i] = 0;
	            }
	        }

	        // Beware that the final length might not fit in 32 bits so we take care of that
	        tmp = n * 8;
	        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
	        lo = parseInt(tmp[2], 16);
	        hi = parseInt(tmp[1], 16) || 0;

	        tail[14] = lo;
	        tail[15] = hi;

	        md5cycle(state, tail);

	        return state;
	    }

	    function rhex(n) {
	        var s = '',
	            j;
	        for (j = 0; j < 4; j += 1) {
	            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
	        }
	        return s;
	    }

	    function hex(x) {
	        var i;
	        for (i = 0; i < x.length; i += 1) {
	            x[i] = rhex(x[i]);
	        }
	        return x.join('');
	    }

	    // In some cases the fast add32 function cannot be used..
	    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') ;

	    // ---------------------------------------------------

	    /**
	     * ArrayBuffer slice polyfill.
	     *
	     * @see https://github.com/ttaubert/node-arraybuffer-slice
	     */

	    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
	        (function () {
	            function clamp(val, length) {
	                val = (val | 0) || 0;

	                if (val < 0) {
	                    return Math.max(val + length, 0);
	                }

	                return Math.min(val, length);
	            }

	            ArrayBuffer.prototype.slice = function (from, to) {
	                var length = this.byteLength,
	                    begin = clamp(from, length),
	                    end = length,
	                    num,
	                    target,
	                    targetArray,
	                    sourceArray;

	                if (to !== undefined$1) {
	                    end = clamp(to, length);
	                }

	                if (begin > end) {
	                    return new ArrayBuffer(0);
	                }

	                num = end - begin;
	                target = new ArrayBuffer(num);
	                targetArray = new Uint8Array(target);

	                sourceArray = new Uint8Array(this, begin, num);
	                targetArray.set(sourceArray);

	                return target;
	            };
	        })();
	    }

	    // ---------------------------------------------------

	    /**
	     * Helpers.
	     */

	    function toUtf8(str) {
	        if (/[\u0080-\uFFFF]/.test(str)) {
	            str = unescape(encodeURIComponent(str));
	        }

	        return str;
	    }

	    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
	        var length = str.length,
	           buff = new ArrayBuffer(length),
	           arr = new Uint8Array(buff),
	           i;

	        for (i = 0; i < length; i += 1) {
	            arr[i] = str.charCodeAt(i);
	        }

	        return returnUInt8Array ? arr : buff;
	    }

	    function arrayBuffer2Utf8Str(buff) {
	        return String.fromCharCode.apply(null, new Uint8Array(buff));
	    }

	    function concatenateArrayBuffers(first, second, returnUInt8Array) {
	        var result = new Uint8Array(first.byteLength + second.byteLength);

	        result.set(new Uint8Array(first));
	        result.set(new Uint8Array(second), first.byteLength);

	        return result ;
	    }

	    function hexToBinaryString(hex) {
	        var bytes = [],
	            length = hex.length,
	            x;

	        for (x = 0; x < length - 1; x += 2) {
	            bytes.push(parseInt(hex.substr(x, 2), 16));
	        }

	        return String.fromCharCode.apply(String, bytes);
	    }

	    // ---------------------------------------------------

	    /**
	     * SparkMD5 OOP implementation.
	     *
	     * Use this class to perform an incremental md5, otherwise use the
	     * static methods instead.
	     */

	    function SparkMD5() {
	        // call reset to init the instance
	        this.reset();
	    }

	    /**
	     * Appends a string.
	     * A conversion will be applied if an utf8 string is detected.
	     *
	     * @param {String} str The string to be appended
	     *
	     * @return {SparkMD5} The instance itself
	     */
	    SparkMD5.prototype.append = function (str) {
	        // Converts the string to utf8 bytes if necessary
	        // Then append as binary
	        this.appendBinary(toUtf8(str));

	        return this;
	    };

	    /**
	     * Appends a binary string.
	     *
	     * @param {String} contents The binary string to be appended
	     *
	     * @return {SparkMD5} The instance itself
	     */
	    SparkMD5.prototype.appendBinary = function (contents) {
	        this._buff += contents;
	        this._length += contents.length;

	        var length = this._buff.length,
	            i;

	        for (i = 64; i <= length; i += 64) {
	            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
	        }

	        this._buff = this._buff.substring(i - 64);

	        return this;
	    };

	    /**
	     * Finishes the incremental computation, reseting the internal state and
	     * returning the result.
	     *
	     * @param {Boolean} raw True to get the raw string, false to get the hex string
	     *
	     * @return {String} The result
	     */
	    SparkMD5.prototype.end = function (raw) {
	        var buff = this._buff,
	            length = buff.length,
	            i,
	            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	            ret;

	        for (i = 0; i < length; i += 1) {
	            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
	        }

	        this._finish(tail, length);
	        ret = hex(this._hash);

	        if (raw) {
	            ret = hexToBinaryString(ret);
	        }

	        this.reset();

	        return ret;
	    };

	    /**
	     * Resets the internal state of the computation.
	     *
	     * @return {SparkMD5} The instance itself
	     */
	    SparkMD5.prototype.reset = function () {
	        this._buff = '';
	        this._length = 0;
	        this._hash = [1732584193, -271733879, -1732584194, 271733878];

	        return this;
	    };

	    /**
	     * Gets the internal state of the computation.
	     *
	     * @return {Object} The state
	     */
	    SparkMD5.prototype.getState = function () {
	        return {
	            buff: this._buff,
	            length: this._length,
	            hash: this._hash.slice()
	        };
	    };

	    /**
	     * Gets the internal state of the computation.
	     *
	     * @param {Object} state The state
	     *
	     * @return {SparkMD5} The instance itself
	     */
	    SparkMD5.prototype.setState = function (state) {
	        this._buff = state.buff;
	        this._length = state.length;
	        this._hash = state.hash;

	        return this;
	    };

	    /**
	     * Releases memory used by the incremental buffer and other additional
	     * resources. If you plan to use the instance again, use reset instead.
	     */
	    SparkMD5.prototype.destroy = function () {
	        delete this._hash;
	        delete this._buff;
	        delete this._length;
	    };

	    /**
	     * Finish the final calculation based on the tail.
	     *
	     * @param {Array}  tail   The tail (will be modified)
	     * @param {Number} length The length of the remaining buffer
	     */
	    SparkMD5.prototype._finish = function (tail, length) {
	        var i = length,
	            tmp,
	            lo,
	            hi;

	        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
	        if (i > 55) {
	            md5cycle(this._hash, tail);
	            for (i = 0; i < 16; i += 1) {
	                tail[i] = 0;
	            }
	        }

	        // Do the final computation based on the tail and length
	        // Beware that the final length may not fit in 32 bits so we take care of that
	        tmp = this._length * 8;
	        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
	        lo = parseInt(tmp[2], 16);
	        hi = parseInt(tmp[1], 16) || 0;

	        tail[14] = lo;
	        tail[15] = hi;
	        md5cycle(this._hash, tail);
	    };

	    /**
	     * Performs the md5 hash on a string.
	     * A conversion will be applied if utf8 string is detected.
	     *
	     * @param {String}  str The string
	     * @param {Boolean} [raw] True to get the raw string, false to get the hex string
	     *
	     * @return {String} The result
	     */
	    SparkMD5.hash = function (str, raw) {
	        // Converts the string to utf8 bytes if necessary
	        // Then compute it using the binary function
	        return SparkMD5.hashBinary(toUtf8(str), raw);
	    };

	    /**
	     * Performs the md5 hash on a binary string.
	     *
	     * @param {String}  content The binary string
	     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
	     *
	     * @return {String} The result
	     */
	    SparkMD5.hashBinary = function (content, raw) {
	        var hash = md51(content),
	            ret = hex(hash);

	        return raw ? hexToBinaryString(ret) : ret;
	    };

	    // ---------------------------------------------------

	    /**
	     * SparkMD5 OOP implementation for array buffers.
	     *
	     * Use this class to perform an incremental md5 ONLY for array buffers.
	     */
	    SparkMD5.ArrayBuffer = function () {
	        // call reset to init the instance
	        this.reset();
	    };

	    /**
	     * Appends an array buffer.
	     *
	     * @param {ArrayBuffer} arr The array to be appended
	     *
	     * @return {SparkMD5.ArrayBuffer} The instance itself
	     */
	    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
	        var buff = concatenateArrayBuffers(this._buff.buffer, arr),
	            length = buff.length,
	            i;

	        this._length += arr.byteLength;

	        for (i = 64; i <= length; i += 64) {
	            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
	        }

	        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

	        return this;
	    };

	    /**
	     * Finishes the incremental computation, reseting the internal state and
	     * returning the result.
	     *
	     * @param {Boolean} raw True to get the raw string, false to get the hex string
	     *
	     * @return {String} The result
	     */
	    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
	        var buff = this._buff,
	            length = buff.length,
	            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	            i,
	            ret;

	        for (i = 0; i < length; i += 1) {
	            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
	        }

	        this._finish(tail, length);
	        ret = hex(this._hash);

	        if (raw) {
	            ret = hexToBinaryString(ret);
	        }

	        this.reset();

	        return ret;
	    };

	    /**
	     * Resets the internal state of the computation.
	     *
	     * @return {SparkMD5.ArrayBuffer} The instance itself
	     */
	    SparkMD5.ArrayBuffer.prototype.reset = function () {
	        this._buff = new Uint8Array(0);
	        this._length = 0;
	        this._hash = [1732584193, -271733879, -1732584194, 271733878];

	        return this;
	    };

	    /**
	     * Gets the internal state of the computation.
	     *
	     * @return {Object} The state
	     */
	    SparkMD5.ArrayBuffer.prototype.getState = function () {
	        var state = SparkMD5.prototype.getState.call(this);

	        // Convert buffer to a string
	        state.buff = arrayBuffer2Utf8Str(state.buff);

	        return state;
	    };

	    /**
	     * Gets the internal state of the computation.
	     *
	     * @param {Object} state The state
	     *
	     * @return {SparkMD5.ArrayBuffer} The instance itself
	     */
	    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
	        // Convert string to buffer
	        state.buff = utf8Str2ArrayBuffer(state.buff, true);

	        return SparkMD5.prototype.setState.call(this, state);
	    };

	    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

	    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

	    /**
	     * Performs the md5 hash on an array buffer.
	     *
	     * @param {ArrayBuffer} arr The array buffer
	     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
	     *
	     * @return {String} The result
	     */
	    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
	        var hash = md51_array(new Uint8Array(arr)),
	            ret = hex(hash);

	        return raw ? hexToBinaryString(ret) : ret;
	    };

	    return SparkMD5;
	})); 
} (sparkMd5));

var sparkMd5Exports = sparkMd5.exports;
var SparkMD5 = /*@__PURE__*/getDefaultExportFromCjs(sparkMd5Exports);

// Import spark-md5 for hashing (used for component ids)
const componentClsRegistry = {};
const componentRegistry = {};
const applicationInstances = {};
function registerComponent(selector, componentCls) {
    if (selector in componentClsRegistry)
        throw new Error(`Failed to register component "${selector}". A component with that selector is already registered`);
    // Ensure template is set
    if (!componentCls.TEMPLATE)
        throw new Error(`Failed to register component "${selector}". Invalid template. Template cannot be blank`);
    // Add to registry
    componentClsRegistry[selector] = componentCls;
    // Set up helper
    Handlebars.registerHelper(selector, (...args) => {
        /**
         * NOTE: Data field in Handlebars.HelperOptions is any.
         * We have to disable this rule to access the necessary fields
         */
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        const options = args[args.length - 1];
        // Get from root data
        const application = options.data.root.__application;
        const partId = options.data.root.partId.replace(`${application.id}-`, '');
        const parentRef = (options.data.root.__componentRef ??
            `${application.id}:${partId}`).split(':');
        const index = getFullIndexRecursive(options.data);
        // Generate id
        const componentId = SparkMD5.hash(`${selector}-${options.loc.start.line}.${index}.${options.loc.start.column}_${options.loc.end.line}.${options.loc.end.column}`);
        // Append to ref
        const componentRef = [...parentRef, componentId].join(':');
        // Init the component if required
        const wasInitialized = initComponent(selector, componentRef);
        // Get id
        const htmlId = options.hash.id;
        // Get classs
        const cssClass = options.hash.class;
        // Get style
        const cssStyle = options.hash.style;
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        // Construct class list
        const cssClassList = [cssClass, ...componentCls.CLASSES]
            .filter((v) => !!v)
            .join(' ');
        // Assign params
        assignParams(componentRef, options.hash);
        // Invoke lifecycle event if required
        if (wasInitialized) {
            const instance = getComponentInstance(componentRef);
            instance.dispatchEvent(new CustomEvent('initialize', {
                detail: { params: getComponentParams(componentRef) },
            }));
        }
        // Return result
        return new Handlebars.SafeString(`
            <${selector} data-component-id="${componentId}" 
                ${htmlId ? `id="${htmlId}"` : ''} 
                ${cssClassList.length > 0 ? `class="${cssClassList}"` : ''}
                ${cssStyle ? `style="${cssStyle}"` : ''}
            >
            </${selector}>
        `);
    });
    if (componentCls.FORM_ASSOCIATED) {
        customElements.define(selector, class extends HTMLElement {
            static formAssociated = true;
            name;
            _value;
            internals;
            constructor() {
                super();
                this.internals = this.attachInternals();
            }
            set value(value) {
                this._value = value;
                this.internals.setFormValue(value);
            }
            get value() {
                return this._value;
            }
        });
    }
}
/* --- Helpers --- */
// See note above
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
function getFullIndexRecursive(data) {
    if (!data)
        return;
    return [
        data.index ?? '0',
        '_parent' in data && 'index' in data._parent
            ? getFullIndexRecursive(data._parent)
            : null,
    ]
        .filter((v) => v !== null)
        .join('.');
}
/* eslint-enable @typescript-eslint/no-unsafe-member-access */
function assignParams(componentRef, hash) {
    // Get params
    const params = Object.entries(hash)
        .filter(([key]) => key !== 'id' && key !== 'class' && key !== 'style')
        .reduce((params, [key, value]) => ({
        ...params,
        [key]: value,
    }), {});
    // Set params
    componentRegistry[componentRef].params = params;
}
function initComponent(selector, componentRef) {
    if (!(selector in componentClsRegistry))
        throw new Error(`Failed to initialize component "${selector}". No such component registered`);
    // If the component is already initialized, do nothing
    if (componentRef in componentRegistry)
        return false;
    // Get relevant ids
    const [applicationId, partId, ...componentIds] = componentRef.split(':');
    const componentId = componentIds[componentIds.length - 1];
    const parentRef = componentIds.length > 1
        ? [applicationId, partId, ...componentIds.slice(0, -1)].join(':')
        : undefined;
    // Get the application
    const app = applicationInstances[applicationId];
    // Get the class
    const ComponentClass = componentClsRegistry[selector];
    // Init component
    const instance = new ComponentClass(componentId, selector, partId, componentRef, app);
    // Assign
    componentRegistry[componentRef] = {
        selector,
        instance,
        parentRef,
        dirty: false,
    };
    return true;
}
/* --- Rendering --- */
function onComponentAction(handler, event) {
    if (!(event instanceof PointerEvent))
        return;
    if (!(event.target instanceof HTMLElement))
        return;
    let buttons = [0];
    if (typeof handler === 'object') {
        buttons = handler.buttons;
        handler = handler.handler;
    }
    if (buttons.includes(event.button))
        void handler.call(this, event, event.target);
}
function registerApplicationInstance(application) {
    applicationInstances[application.id] = application;
}
function deregisterApplicationInstance(application) {
    console.log('Deregistering application instance:', application.id);
    Object.keys(componentRegistry)
        .filter((componentRef) => 
            componentRef.startsWith(application.id) && 
            !componentRegistry[componentRef]?.parentRef // no parent, only top level components
        )
        .forEach((componentRef) => destroyComponent(componentRef));
    delete applicationInstances[application.id];
}
function destroyComponent(componentRef, recursive = true) {
    console.log('Destroying component:', componentRef, recursive);
    // Get component instance
    const instance = getComponentInstance(componentRef);
    if (!instance)
        throw new Error(`Failed to destroy component. Invalid component ref "${componentRef}"`);
    // Get all child components
    const childRefs = Object.entries(componentRegistry)
        .filter(([_, { parentRef }]) => parentRef === componentRef)
        .map(([ref]) => ref);
    // Destroy children
    if (recursive) {
        childRefs.forEach((childRef) => destroyComponent(childRef, true));
    }
    // Invoke lifecycle event
    instance.dispatchEvent(new CustomEvent('destroy', {
        detail: { params: getComponentParams(componentRef) },
    }));
    // Remove from registry
    delete componentRegistry[componentRef];
}
function getComponentInstance(componentRef) {
    // Check if component already exists in the registry
    if (!(componentRef in componentRegistry)) {
        return undefined;
    }
    else {
        return componentRegistry[componentRef].instance;
    }
}
async function renderComponent(componentRef, applicationContext, options) {
    // Get component instance
    const instance = getComponentInstance(componentRef);
    if (!instance)
        throw new Error(`Failed to render component. Invalid component ref "${componentRef}"`);
    // Get params
    const params = componentRegistry[componentRef].params ?? {};
    // Prepare context
    const context = await instance._prepareContext(params, applicationContext, options);
    // Get component class
    const ComponentClass = componentClsRegistry[instance.selector];
    // Render
    const content = await renderTemplate(ComponentClass.TEMPLATE, {
        ...instance,
        ...context,
        __application: instance.application,
        __componentRef: componentRef,
        partId: instance.partId,
    });
    // To HTML
    const t = document.createElement('template');
    t.innerHTML = content;
    const html = t.content.children;
    // Get all child components
    const childRefs = Object.entries(componentRegistry)
        .filter(([_, { parentRef }]) => parentRef === componentRef)
        .filter(([_, { selector, instance }]) => $(html).find(`${selector}[data-component-id="${instance.id}"]`)
        .length > 0)
        .map(([ref]) => ref);
    // Render children
    for (const childRef of childRefs) {
        const childHtml = await renderComponent(childRef, applicationContext, options);
        replaceComponent(childRef, childHtml, $(html));
    }
    // Mark as clean
    componentRegistry[componentRef].dirty = false;
    // Return result
    return html;
}
function getComponentState(componentRef) {
    // Get component instance
    const instance = getComponentInstance(componentRef);
    if (!instance?.element)
        throw new Error(`Failed to get component state. Invalid component ref "${componentRef}"`);
    // Get the component class
    const ComponentClass = instance.constructor;
    // Prepare return state
    const state = {};
    // Focused element or field
    const focus = instance.element.querySelector(':focus');
    if (focus?.id)
        state.focus = `#${focus.id}`;
    else if (focus && focus instanceof HTMLInputElement)
        state.focus = `${focus.tagName}[name="${focus.name}"]`;
    // Scroll positions
    state.scrollPositions = [];
    ComponentClass.SCROLLABLE.forEach((scrollSelector) => {
        const scrollElement = scrollSelector === ''
            ? instance.element
            : instance.element?.querySelector(scrollSelector);
        if (scrollElement) {
            state.scrollPositions.push([
                scrollSelector,
                scrollElement.scrollTop,
                scrollElement.scrollLeft,
            ]);
        }
    });
    return state;
}
function getComponentStatesRecursive(rootRef, states = {}) {
    // Get component instance
    const instance = getComponentInstance(rootRef);
    if (!instance)
        throw new Error(`Failed to get component state. Invalid component ref "${rootRef}"`);
    // Ensure instance has element
    if (!instance.element)
        return states;
    // Get state
    states[rootRef] = getComponentState(rootRef);
    getComponentChildrenRefs(rootRef).forEach((childRef) => getComponentStatesRecursive(childRef, states));
    // Return result
    return states;
}
function replaceComponent(componentRef, componentContent, root) {
    // Get component instance
    const instance = getComponentInstance(componentRef);
    if (!instance)
        throw new Error(`Failed to replace component. Invalid component ref "${componentRef}"`);
    // Get application
    const app = instance.application;
    // Find element
    const element = (root ?? $(app.element)).find(`${instance.selector}[data-component-id="${instance.id}"]`);
    // Retain value if the element is form associated
    if (!!componentRegistry[componentRef].element &&
        element.get(0) !== componentRegistry[componentRef].element &&
        componentClsRegistry[instance.selector].FORM_ASSOCIATED) {
        // Assign value to the new element
        element.get(0).value = componentRegistry[componentRef].element.value;
    }
    // Assign element
    componentRegistry[componentRef].element = element.get(0);
    // Replace content
    element.empty();
    element.append($(componentContent));
}
function applyComponentState(componentRef, state) {
    // Get component instance
    const instance = getComponentInstance(componentRef);
    if (!instance?.element)
        throw new Error(`Failed to apply component state. Invalid component ref "${componentRef}"`);
    if (state.focus) {
        const el = instance.element.querySelector(state.focus);
        el?.focus();
    }
    state.scrollPositions.forEach(([selector, scrollTop, scrollLeft]) => {
        const target = selector === ''
            ? instance.element
            : instance.element?.querySelector(selector);
        if (!target)
            return;
        Object.assign(target, { scrollTop, scrollLeft });
    });
}
function attachComponentListeners(componentRef) {
    // Get component instance
    const instance = getComponentInstance(componentRef);
    if (!instance)
        throw new Error(`Failed to attach component listeners. Invalid component ref "${componentRef}"`);
    // Get the element
    const htmlElement = getComponentElement(componentRef);
    if (!htmlElement)
        throw new Error(`Failed to attach component listeners. Component element not set. Selector: "${instance.selector}" Ref: "${componentRef}"`);
    // Get the component actions
    const actions = instance.constructor.ACTIONS;
    // Attach listeners
    Object.entries(actions).forEach(([actionId, handler]) => {
        // Construct selector
        const actionSelector = `[data-action="${actionId}"]`;
        // Find the action elements
        const actionElements = htmlElement.matches(actionSelector)
            ? $(htmlElement)
            : $(htmlElement).find(actionSelector);
        // Add listeners
        actionElements.get().forEach((el) => {
            el.addEventListener('click', onComponentAction.bind(instance, handler));
            el.addEventListener('contextmenu', onComponentAction.bind(instance, handler));
        });
    });
    // Invoke lifecylce event
    instance.dispatchEvent(new CustomEvent('attachListeners', {
        detail: { params: getComponentParams(componentRef) },
    }));
    // Get all child components
    const childRefs = Object.entries(componentRegistry)
        .filter(([_, { parentRef }]) => parentRef === componentRef)
        .map(([ref]) => ref);
    // Attach child component listeners
    childRefs.forEach((childRef) => attachComponentListeners(childRef));
}
function preRenderApplication(applicationId, parts, componentRefs) {
    // Mark all components as dirty
    Object.entries(componentRegistry)
        .filter(([ref]) => ref.startsWith(applicationId))
        .filter(([ref]) => (!parts && !componentRefs) ||
        (parts?.includes(ref.split(':')[1]) ?? false) ||
        componentRefs?.some((otherRef) => ref.startsWith(otherRef)))
        .forEach(([ref, { selector, instance }]) => {
        componentRegistry[ref].dirty = true;
    });
}
function removeOrphanedComponents(applicationId) {
    // Get all components
    const components = Object.entries(componentRegistry).filter(([ref]) => ref.startsWith(applicationId));
    // Remove orphaned components
    components.forEach(([ref, { dirty, selector, instance }]) => {
        if (dirty) {
            // Destroy component
            destroyComponent(ref, false);
        }
    });
}
function getComponentElement(componentRef) {
    return componentRegistry[componentRef]?.element;
}
function getComponentParams(componentRef) {
    return componentRegistry[componentRef]?.params;
}
function getComponentChildrenRefs(componentRef) {
    return Object.entries(componentRegistry)
        .filter(([_, { parentRef }]) => parentRef === componentRef)
        .map(([ref]) => ref);
}
function getComponentChildren(componentRef) {
    return getComponentChildrenRefs(componentRef).map((ref) => componentRegistry[ref].instance);
}
function getComponentParentRef(componentRef) {
    return componentRegistry[componentRef]?.parentRef;
}
function getComponentParent(componentRef) {
    const parentRef = getComponentParentRef(componentRef);
    return parentRef ? componentRegistry[parentRef].instance : undefined;
}
function getApplicationComponents(applicationId, partId) {
    const prefix = [applicationId, partId].filter((v) => !!v).join(':');
    return Object.entries(componentRegistry)
        .filter(([ref]) => ref.startsWith(prefix))
        .map(([_, { instance }]) => instance);
}
/* --- Hooks --- */
Hooks.on('ready', async () => {
    // Get templates
    const templates = Object.values(componentClsRegistry).map((cls) => cls.TEMPLATE);
    // Pre-load
    await loadTemplates(templates);
});
/* --- Default exports --- */
var ComponentSystem = {
    registerComponent,
    getComponentInstance,
    renderComponent,
    getComponentState,
    getComponentStatesRecursive,
    replaceComponent,
    preRenderApplication,
    removeOrphanedComponents,
    applyComponentState,
    attachComponentListeners,
    getComponentElement,
    getComponentParams,
    getComponentChildrenRefs,
    getComponentChildren,
    getComponentParentRef,
    getComponentParent,
    getApplicationComponents,
    registerApplicationInstance,
    deregisterApplicationInstance,
    destroyComponent,
};

// Component system
class HandlebarsApplicationComponent extends foundry.utils.EventEmitterMixin(Object) {
    id;
    selector;
    partId;
    ref;
    application;
    static emittedEvents = [
        'initialize',
        'attachListeners',
        'render',
        'destroy',
    ];
    /**
     * The template entry-point for the Component
     */
    static TEMPLATE = '';
    /**
     * An array of CSS classes to apply to the top-level element of the
     * rendered component.
     */
    static CLASSES = [];
    /**
     * An array of selectors within this component whose scroll positions should
     * be persisted during a re-render operation. A blank string is used
     * to denote that the root level of the component is scrollable.
     */
    static SCROLLABLE = [];
    /**
     * A registry of forms selectors and submission handlers.
     */
    static FORMS = {};
    /**
     * Click actions supported by this Component and their event handler functions.
     * A handler function can be defined directly which only
     * responds to left-click events. Otherwise, an object can be declared
     * containing both a handler function and an array of buttons which are
     * matched against the PointerEvent#button property.
     */
    static ACTIONS = {};
    /**
     * Whether this Component is form associated.
     */
    static FORM_ASSOCIATED = false;
    constructor(id, selector, partId, ref, application) {
        super();
        this.id = id;
        this.selector = selector;
        this.partId = partId;
        this.ref = ref;
        this.application = application;
        this.addEventListener('initialize', (event) => this._onInitialize(event.detail.params));
        this.addEventListener('render', (event) => this._onRender(event.detail.params));
        this.addEventListener('attachListeners', (event) => this._onAttachListeners(event.detail.params));
        this.addEventListener('destroy', this._onDestroy.bind(this));
    }
    get element() {
        return ComponentSystem.getComponentElement(this.ref);
    }
    get params() {
        return ComponentSystem.getComponentParams(this.ref);
    }
    get childRefs() {
        return ComponentSystem.getComponentChildrenRefs(this.ref);
    }
    get children() {
        return ComponentSystem.getComponentChildren(this.ref);
    }
    get parentRef() {
        return ComponentSystem.getComponentParentRef(this.ref);
    }
    get parent() {
        return ComponentSystem.getComponentParent(this.ref);
    }
    /* --- Rendering --- */
    /**
     * Render this component
     */
    async render() {
        await this.application.render({
            parts: [],
            componentRefs: [this.ref],
        });
        return this;
    }
    /* --- Context --- */
    /**
     * Prepare Component rendering context data for a given render request.
     * @param params    - The params passed to the Component from the part
     * @param context   - The application render context
     * @param options   - Options which configure rendering behavior
     * @returns         Context data for the rendering operation
     * @virtual
     */
    _prepareContext(params, context, options) {
        return Promise.resolve({});
    }
    /* --- Lifecycle --- */
    /**
     * Actions performed after Component initialization.
     */
    _onInitialize(params) { }
    /**
     * Actions performed after Component rendering.
     */
    _onRender(params) { }
    /**
     * Actions performed after Component listeners are attached.
     * Use this to attach your own event listeners.
     * @param params
     */
    _onAttachListeners(params) { }
    /**
     * Actions performed at Component teardown.
     */
    _onDestroy() { }
    /* --- Registration --- */
    static register(selector) {
        ComponentSystem.registerComponent(selector, this);
    }
}

// Component System
const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$a } = foundry.applications.api;
function ComponentHandlebarsApplicationMixin(base) {
    return class mixin extends HandlebarsApplicationMixin$a(base) {
        get components() {
            return ComponentSystem.getApplicationComponents(this.id).reduce((dict, component) => ({
                ...dict,
                [component.ref]: component,
            }), {});
        }
        async _preFirstRender(context, options) {
            await super._preFirstRender(context, options);
            // Register instance
            ComponentSystem.registerApplicationInstance(this);
        }
        _onClose(options) {
            super._onClose(options);
            // Deregister instance
            ComponentSystem.deregisterApplicationInstance(this);
        }
        _configureRenderOptions(options) {
            super._configureRenderOptions(options);
            options.componentRefs ??= [];
        }
        async _renderHTML(context, options) {
            let renderedParts = {};
            const renderedComponents = {};
            if (options.components) {
                options.componentRefs.push(...Object.values(this.components)
                    .filter((instance) => options.components.includes(instance.selector))
                    .map((instance) => instance.ref));
            }
            // Pre-render application
            ComponentSystem.preRenderApplication(this.id, options.parts, options.componentRefs);
            // Part rendering
            if (options.parts?.length > 0) {
                renderedParts = (await super._renderHTML({ ...context, __application: this }, options));
                // Get all component refs that belong to the rendered parts
                const componentRefs = Object.entries(this.components)
                    .filter(([ref, instance]) => Object.entries(renderedParts).some(([partId, partHTML]) => ref.split(':')[1] === partId &&
                    $(partHTML)
                        .find(`${instance.selector}[data-component-id="${instance.id}"]`)
                        .addBack(instance.selector).length > 0))
                    .map(([ref]) => ref);
                // Mark components from rendered parts for rendering
                options.componentRefs.push(...componentRefs);
            }
            // Component rendering
            if (options.componentRefs.length > 0) {
                // Sort component refs and filter out duplicates
                options.componentRefs = options.componentRefs
                    .sort()
                    .filter((v, i, self) => self.indexOf(v) === i);
                // Remove all components of which an ancestor is already included in the refs
                for (let i = 0; i < options.componentRefs.length; i++) {
                    const ref = options.componentRefs[i];
                    const numChildren = options.componentRefs
                        .slice(i + 1)
                        .filter((otherRef) => otherRef.startsWith(ref)).length;
                    if (numChildren > 0) {
                        options.componentRefs.splice(i + 1, numChildren);
                    }
                }
                for (const ref of options.componentRefs) {
                    // Perform render
                    const html = await ComponentSystem.renderComponent(ref, context, options);
                    // Add component to list of rendered components
                    renderedComponents[ref] = html;
                }
            }
            // Remove components that were deleted
            ComponentSystem.removeOrphanedComponents(this.id);
            /**
             * NOTE: Changing the return type of this function is actually
             * within spec for ApplicationV2 (so long as the return type of
             * _renderHTML and the result param of _replaceHTML match).
             * However the types on HandlebarsApplication don't allow it without
             * casting to any.
             */
            return {
                parts: renderedParts,
                components: renderedComponents,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            };
        }
        _replaceHTML(result, content, options) {
            const parts = result.parts;
            const components = result.components;
            const partStates = {};
            let states = {};
            // Extract existing component states
            Object.keys(components).forEach((ref) => {
                states = {
                    ...states,
                    ...ComponentSystem.getComponentStatesRecursive(ref),
                };
            });
            // Replace parts
            if (Object.keys(parts).length > 0) {
                Object.entries(parts).forEach(([partId, htmlElement]) => {
                    // Get part element
                    const priorElement = content.querySelector(`[data-application-part="${partId}"]`);
                    const state = {};
                    if (priorElement) {
                        super._preSyncPartState(partId, htmlElement, priorElement, state);
                        partStates[partId] = [priorElement, state];
                        priorElement.replaceWith(htmlElement);
                    }
                    else {
                        content.appendChild(htmlElement);
                    }
                    super._attachPartListeners(partId, htmlElement, options);
                    super.parts[partId] = htmlElement;
                });
            }
            // Replace components
            Object.entries(components).forEach(([ref, html]) => ComponentSystem.replaceComponent(ref, html));
            // Apply part states
            Object.entries(partStates).forEach(([partId, [priorElement, state]]) => {
                const htmlElement = parts[partId];
                this._syncPartState(partId, htmlElement, priorElement, state);
            });
            // Apply states
            Object.entries(states).forEach(([ref, state]) => ComponentSystem.applyComponentState(ref, state));
            // Attach listeners
            Object.keys(components).forEach((ref) => ComponentSystem.attachComponentListeners(ref));
        }
        async _prepareContext(options) {
            return await super._prepareContext(options);
        }
        _onRender(context, options) {
            // Trigger render events
            options.componentRefs.forEach((ref) => this.dispatchRenderEventRecursive(ref));
        }
        dispatchRenderEventRecursive(componentRef) {
            const component = this.components[componentRef];
            // Dispatch event
            component.dispatchEvent(new CustomEvent('render', {
                detail: {
                    params: ComponentSystem.getComponentParams(componentRef),
                },
            }));
            // Recursive call for children
            component.childRefs.forEach((childRef) => this.dispatchRenderEventRecursive(childRef));
        }
    };
}

const { ApplicationV2: ApplicationV2$g } = foundry.applications.api;
class RollConfigurationDialog extends ComponentHandlebarsApplicationMixin((ApplicationV2$g)) {
    data;
    resolve;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            resizable: false,
            positioned: true,
        },
        classes: ['dialog', 'roll-configuration'],
        tag: 'dialog',
        position: {
            width: 500,
        },
        actions: {
            submit: this.onSubmit,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ROLL_CONFIGURATION}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    submitted = false;
    originalFormulaSize = 0;
    constructor(data, resolve) {
        super({
            window: {
                title: data.title,
            },
        });
        this.data = data;
        this.resolve = resolve;
        this.originalFormulaSize = this.data.skillTest.parts.length;
        this.data.skillTest.advantageMode ??= AdvantageMode.None;
        this.data.plotDie.advantageMode ??= AdvantageMode.None;
        this.data.skillTest.formula = foundry.dice.Roll.replaceFormulaData(getFormulaDisplayString(this.data.skillTest.parts), this.data.skillTest.data, {
            missing: '0',
        });
    }
    /* --- Statics --- */
    static show(data) {
        return new Promise((resolve) => {
            void new this(data, resolve).render(true);
        });
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        const attribute = getNullableFromFormInput(formData.get('attribute'));
        const rollMode = formData.get('rollMode');
        const raiseStakes = formData.get('raiseStakes') === 'true';
        const tempMod = formData.get('temporaryMod')?.valueOf();
        // get rid of existing temp mod formula
        if (this.data.skillTest.parts.length > this.originalFormulaSize)
            this.data.skillTest.parts.pop();
        // add the current ones in for display in the formula bar
        this.data.skillTest.parts.push(tempMod);
        // store it
        this.data.temporaryModifiers = tempMod;
        const skill = this.data.skillTest.data.skill;
        const attributeData = attribute
            ? this.data.skillTest.data.attributes[attribute]
            : { value: 0, bonus: 0 };
        const rank = skill.rank;
        const value = attributeData.value + attributeData.bonus;
        this.data.skillTest.data.mod = rank + value;
        this.data.defaultAttribute = attribute ?? undefined;
        this.data.defaultRollMode = rollMode;
        this.data.raiseStakes = raiseStakes;
        void this.render();
    }
    /* --- Actions --- */
    static onSubmit() {
        const form = this.element.querySelector('form');
        this.resolve({
            attribute: getNullableFromFormInput(form.attribute.value),
            rollMode: form.rollMode?.value ?? 'roll',
            temporaryModifiers: form.temporaryMod.value,
            plotDie: form.raiseStakes.checked,
            advantageMode: this.data.skillTest.advantageMode ?? AdvantageMode.None,
            advantageModePlot: this.data.plotDie.advantageMode ?? AdvantageMode.None,
        });
        this.submitted = true;
        void this.close();
    }
    /* --- Event handlers --- */
    onClickConfigureDie(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.which !== 1 && event.which !== 3)
            return;
        const target = event.currentTarget;
        const action = target.dataset.action;
        target.classList.remove(AdvantageMode.Advantage);
        target.classList.remove(AdvantageMode.Disadvantage);
        target.classList.remove(AdvantageMode.None);
        switch (action) {
            case 'skill-adv-mode':
                this.data.skillTest.advantageMode = toggleAdvantageMode(this.data.skillTest.advantageMode ?? AdvantageMode.None, event.which === 1);
                target.classList.add(this.data.skillTest.advantageMode);
                break;
            case 'plot-adv-mode':
                this.data.plotDie.advantageMode = toggleAdvantageMode(this.data.plotDie.advantageMode ?? AdvantageMode.None, event.which === 1);
                target.classList.add(this.data.plotDie.advantageMode);
                break;
        }
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
        $(this.element)
            .find('.roll-config.test .dice-tooltip .dice-rolls .roll.die')
            .addClass(this.data.skillTest.advantageMode ?? AdvantageMode.None);
        $(this.element)
            .find('.roll-config.plot .dice-tooltip .dice-rolls .roll.die')
            .addClass(this.data.plotDie.advantageMode ?? AdvantageMode.None);
        $(this.element)
            .find('.dice-tooltip .dice-rolls .roll.die')
            .on('mousedown', this.onClickConfigureDie.bind(this));
    }
    _onClose() {
        if (!this.submitted)
            this.resolve(null);
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            rollModes: CONFIG.Dice.rollModes,
            defaultRollMode: this.data.defaultRollMode,
            attributes: {
                [NONE]: 'GENERIC.None',
                ...Object.entries(CONFIG.COSMERE.attributes).reduce((acc, [key, config]) => ({
                    ...acc,
                    [key]: config.label,
                }), {}),
            },
            defaultAttribute: this.data.defaultAttribute,
            temporaryModifiers: this.data.temporaryModifiers,
            skillTest: this.data.skillTest.formula
                ? {
                    formula: this.data.skillTest.formula,
                    dice: new foundry.dice.Roll(this.data.skillTest.formula)
                        .dice,
                }
                : undefined,
            plotDie: this.data.raiseStakes
                ? {
                    formula: '1dp',
                    dice: new foundry.dice.Roll('1dp').dice,
                }
                : undefined,
        });
    }
}

// Constants
const SIDES = {
    1: `<img src="${IMPORTED_RESOURCES.PLOT_DICE_C2_IN_CHAT}" />`,
    2: `<img src="${IMPORTED_RESOURCES.PLOT_DICE_C4_IN_CHAT}" />`,
    3: '&nbsp;',
    4: '&nbsp;',
    5: `<img src="${IMPORTED_RESOURCES.PLOT_DICE_OP_IN_CHAT}" />`,
    6: `<img src="${IMPORTED_RESOURCES.PLOT_DICE_OP_IN_CHAT}" />`,
};
class PlotDie extends foundry.dice.terms.Die {
    isPlotDie = true;
    constructor(data = {}) {
        super({
            ...data,
            faces: 6,
        });
    }
    static DENOMINATION = 'p';
    /* --- Accessors --- */
    get rolledComplication() {
        return this.results.find((r) => !r.discarded)?.failure ?? false;
    }
    get rolledOpportunity() {
        return this.results.find((r) => !r.discarded)?.success ?? false;
    }
    /* --- Functions --- */
    async roll({ minimize = false, maximize = false, ...options } = {}) {
        const roll = {
            result: undefined,
            active: true,
        };
        if (minimize)
            roll.result = 1;
        else if (maximize)
            roll.result = 6;
        else
            roll.result = await this._roll(options);
        if (roll.result === undefined)
            roll.result = this.randomFace();
        if (roll.result <= 2) {
            roll.failure = true;
            roll.count = roll.result * 2;
        }
        else {
            if (roll.result >= 5)
                roll.success = true;
            roll.count = 0;
        }
        const rollResult = roll;
        this.results.push(rollResult);
        return rollResult;
    }
    getResultLabel(result) {
        return SIDES[result.result];
    }
}

const DEFAULT_OPPORUNITY_VALUE = 20;
const DEFAULT_COMPLICATION_VALUE = 1;
class D20Roll extends foundry.dice.Roll {
    parts;
    constructor(parts, data, options = {}) {
        super(parts, data, options);
        this.parts = parts;
        if (!this.options.configured) {
            this.configureModifiers();
        }
    }
    /* --- Accessors --- */
    /**
     * Does this roll start with a d20?
     */
    get validD20Roll() {
        return (this.terms[0] instanceof foundry.dice.terms.Die &&
            this.terms[0].faces === 20);
    }
    /**
     * Whether or not to include a plot die in the roll
     */
    get hasPlotDie() {
        return !!this.options.plotDie;
    }
    /**
     * Whether or not the d20 roll has advantage
     */
    get hasAdvantage() {
        return this.options.advantageMode === AdvantageMode.Advantage;
    }
    /**
     * Whether or not the d20 roll has disadvantage
     */
    get hasDisadvantage() {
        return this.options.advantageMode === AdvantageMode.Disadvantage;
    }
    /**
     * Whether or not the plot die roll has advantage
     */
    get hasPlotAdvantage() {
        return this.options.advantageModePlot === AdvantageMode.Advantage;
    }
    /**
     * Whether or not the plot die roll has disadvantage
     */
    get hasPlotDisadvantage() {
        return this.options.advantageModePlot === AdvantageMode.Disadvantage;
    }
    /**
     * How many complications were rolled?
     */
    get complicationsCount() {
        if (!this._evaluated) {
            throw new Error('Roll not evaluated');
        }
        // Get d20s
        const d20s = this.dice.filter((die) => die.faces === 20);
        // Get plot dice
        const plotDice = this.dice.filter((die) => die instanceof PlotDie);
        // Get all dice that rolled a complication
        const d20Complications = d20s.filter((die) => die.results[0].result <=
            (this.options.complication ?? DEFAULT_COMPLICATION_VALUE));
        const plotDiceComplications = plotDice.filter((die) => die.results[0].failure === true);
        // Return the count
        return d20Complications.length + plotDiceComplications.length;
    }
    /**
     * How many opportunities were rolled?
     */
    get opportunitiesCount() {
        if (!this._evaluated) {
            throw new Error('Roll not evaluated');
        }
        // Get d20s
        const d20s = this.dice.filter((die) => die.faces === 20);
        // Get plot dice
        const plotDice = this.dice.filter((die) => die instanceof PlotDie);
        // Get all dice that rolled an opportunity
        const d20Opportunities = d20s.filter((die) => die.results[0].result >=
            (this.options.opportunity ?? DEFAULT_OPPORUNITY_VALUE));
        const plotDiceOpportunities = plotDice.filter((die) => die.results[0].success === true);
        // Return the count
        return d20Opportunities.length + plotDiceOpportunities.length;
    }
    /**
     * Whether a complication was rolled (either on the plot die, or on the d20)
     */
    get rolledComplication() {
        return this.complicationsCount > 0;
    }
    /**
     * Whether an opporunity was rolled (either on the plot die, or on the d20)
     */
    get rolledOpportunity() {
        return this.opportunitiesCount > 0;
    }
    /**
     * Was an opporunity rolled on the d20?
     * Returns undefined if the roll isn't yet evaluated
     */
    get hasRolledOpportunity() {
        if (!this.validD20Roll || !this._evaluated)
            return undefined;
        // Get the opporunity value
        const opporunity = this.options.opportunity ?? DEFAULT_OPPORUNITY_VALUE;
        if (!Number.isNumeric(opporunity))
            return false;
        return this.dice[0].total >= opporunity;
    }
    /**
     * Was a complication rolled on the d20?
     * Returns undefined if the roll isn't yet evaluated
     */
    get hasRolledComplication() {
        if (!this.validD20Roll || !this._evaluated)
            return undefined;
        // Get the complication value
        const complication = this.options.complication ?? DEFAULT_COMPLICATION_VALUE;
        if (!Number.isNumeric(complication))
            return false;
        return this.dice[0].total <= complication;
    }
    /* --- Public Functions --- */
    async configureDialog(data) {
        // Populate parts list
        data.skillTest.parts = [this.parts];
        // Show the dialog
        const result = await RollConfigurationDialog.show({
            ...data,
        });
        if (!result)
            return null;
        if (result.attribute !== this.options.defaultAttribute) {
            this.data.skill.attribute = result.attribute;
            const skill = this.data.skill;
            const attribute = result.attribute
                ? this.data.attributes[result.attribute]
                : { value: 0, bonus: 0 };
            this.terms[2] = new foundry.dice.terms.NumericTerm({
                number: skill.rank + attribute.value + attribute.bonus,
            });
        }
        this.options.rollMode = result.rollMode;
        this.options.plotDie = result.plotDie;
        this.options.advantageMode = result.advantageMode;
        this.options.advantageModePlot = result.advantageModePlot;
        if (result.temporaryModifiers) {
            const tempTerms = new Roll(`0 + ${result.temporaryModifiers}`)
                .terms;
            this.terms = this.terms.concat(tempTerms.slice(1));
            this.resetFormula();
        }
        this.configureModifiers();
        return this;
    }
    toMessage(messageData, options) {
        options ??= {};
        options.rollMode ??= this.options.rollMode;
        if (options.rollMode === 'roll')
            options.rollMode = undefined;
        options.rollMode ??= game.settings.get('core', 'rollMode');
        return super.toMessage(messageData, options);
    }
    async getHTML() {
        const OPPORTUNITY = 'opportunity';
        const COMPLICATION = 'complication';
        if (!this.validD20Roll)
            return;
        // Process bonuses beyond the base d20s into a single roll.
        const bonusTerms = this.terms.slice(1);
        for (const term of bonusTerms) {
            // Terms throw an error if already evaluated. We can ignore them if so.
            try {
                await term.evaluate();
            }
            catch (err) {
                continue;
            }
        }
        const bonusRoll = bonusTerms && bonusTerms.length > 0
            ? Roll.fromTerms(bonusTerms)
            : null;
        const d20Dice = this.dice.find((d) => d.faces === 20);
        if (!d20Dice)
            return;
        const plot = [];
        if (this.hasPlotDie) {
            const plotDice = this.terms.filter((r) => r instanceof PlotDie);
            for (const plotDie of plotDice) {
                if (plotDie.rolledOpportunity)
                    plot.push(OPPORTUNITY);
                if (plotDie.rolledComplication)
                    plot.push(COMPLICATION);
            }
        }
        const entries = [];
        for (let i = 0; i < d20Dice.results.length; i++) {
            const tmpResults = [];
            tmpResults.push(foundry.utils.duplicate(d20Dice.results[i]));
            while (d20Dice?.results[i]?.rerolled &&
                !d20Dice?.results[i]?.count) {
                if (i + 1 >= d20Dice.results.length) {
                    break;
                }
                i++;
                tmpResults.push(foundry.utils.duplicate(d20Dice.results[i]));
            }
            // Die terms must have active results or the base roll total of the generated roll is 0.
            // This does not apply to dice that have been rerolled (unless they are replaced by a fixer value eg. for reliable talent).
            tmpResults.forEach((r) => {
                r.active = !(r.rerolled && !r.count);
            });
            const modifiers = new Array();
            for (const mod of d20Dice.modifiers) {
                if (hasKey(foundry.dice.terms.Die.MODIFIERS, mod)) {
                    modifiers.push(mod);
                }
            }
            const baseTerm = new foundry.dice.terms.Die({
                number: 1,
                faces: 20,
                results: tmpResults,
                modifiers,
            });
            const baseRoll = D20Roll.fromTerms([baseTerm]);
            baseRoll.options = this.options;
            const total = (baseRoll?.total ?? 0) + (bonusRoll?.total ?? 0);
            const plotD20 = [...plot];
            for (let o = 0; o < baseRoll.opportunitiesCount; o++) {
                plotD20.push(OPPORTUNITY);
            }
            for (let c = 0; c < baseRoll.complicationsCount; c++) {
                plotD20.push(COMPLICATION);
            }
            entries.push({
                roll: baseRoll,
                total: total,
                ignored: tmpResults.some((r) => r.discarded) ? true : undefined,
                plotType: plotD20.some((p) => p === OPPORTUNITY)
                    ? OPPORTUNITY
                    : plotD20.some((p) => p === COMPLICATION)
                        ? COMPLICATION
                        : undefined,
                plotDice: plotD20,
            });
        }
        return renderSystemTemplate(TEMPLATES.CHAT_ROLL_D20, {
            formula: this.formula,
            tooltip: await this.getTooltip(),
            entries,
        });
    }
    /**
     * Recalculates the roll total from the current (potentially modified) terms.
     * @returns {number} The new total of the roll.
     */
    resetTotal() {
        return (this._total = this._evaluateTotal());
    }
    /* --- Internal Functions --- */
    configureModifiers() {
        if (!this.validD20Roll)
            return;
        const d20 = this.terms[0];
        d20.modifiers = [];
        if (this.hasAdvantage) {
            d20.number = 2;
            d20.modifiers.push('kh');
        }
        else if (this.hasDisadvantage) {
            d20.number = 2;
            d20.modifiers.push('kl');
        }
        else {
            d20.number = 1;
        }
        if (this.hasPlotDie) {
            if (!this.terms.some((t) => t instanceof PlotDie)) {
                this.terms.push(new foundry.dice.terms.OperatorTerm({
                    operator: '+',
                }), new PlotDie());
            }
            const plotDieTerm = this.terms.find((t) => t instanceof PlotDie);
            if (this.hasPlotAdvantage) {
                plotDieTerm.number = 2;
                plotDieTerm.modifiers.push('p');
            }
            else if (this.hasPlotDisadvantage) {
                plotDieTerm.number = 2;
                plotDieTerm.modifiers.push('gmp');
            }
        }
        // NOTE: Unused right now
        // if (!!this.options.targetValue) {
        //     (d20.options as any).targetValue = this.options.targetValue;
        // }
        // Re-compile the underlying formula
        this._formula = Roll.getFormula(this.terms);
        // Mark as configured
        this.options.configured = true;
    }
}

class DamageRoll extends foundry.dice.Roll {
    isDamage = true;
    constructor(formula, data, options) {
        super(formula, data, options);
        if (!this.options.configured) {
            this.configureModifiers();
        }
    }
    get damageType() {
        return this.options.damageType;
    }
    get mod() {
        return this.options.mod;
    }
    get damageSourceName() {
        return this.options.damageSourceName;
    }
    get graze() {
        return this.options.graze;
    }
    set graze(roll) {
        this.options.graze = roll;
    }
    get hasMod() {
        return this.options.mod !== undefined;
    }
    /**
     * Whether or not the damage roll has advantage
     */
    get hasAdvantage() {
        return this.options.advantageMode === AdvantageMode.Advantage;
    }
    /**
     * Whether or not the damage roll has disadvantage
     */
    get hasDisadvantage() {
        return this.options.advantageMode === AdvantageMode.Disadvantage;
    }
    /**
     * Whether or not the damage roll is a critical hit
     */
    get isCritical() {
        return this.options.critical === true;
    }
    get hasDice() {
        return this.dice.length > 0;
    }
    /* --- Functions --- */
    async getTooltip() {
        const tooltip = await super.getTooltip();
        if (tooltip) {
            const diceRolls = $(tooltip).find('.roll.die');
            const firstPart = $(tooltip).find('.tooltip-part').first();
            let total = 0;
            $(tooltip)
                .find('.value')
                .each((_index, value) => {
                total += Number($(value).text());
            });
            firstPart.find('.dice-rolls').empty().append(diceRolls);
            firstPart.find('.value').text(total);
            const tooltipFinal = $(tooltip)
                .find('.dice-tooltip')
                .empty()
                .append(firstPart);
            return tooltipFinal[0].outerHTML;
        }
        // Get dice terms
        const parts = [
            {
                formula: this.formula,
                total: this.total,
                rolls: [], // There are no dice, otherwise the default tooltip would have been returned
            },
        ];
        // Render the template
        const rendered = await renderTemplate(foundry.dice.Roll.TOOLTIP_TEMPLATE, {
            parts,
        });
        return rendered;
    }
    /* --- Helper Functions --- */
    removeTermSafely(conditional) {
        this.terms.findSplice(conditional);
        this.cleanUpTerms();
    }
    filterTermsSafely(condition) {
        this.terms = this.terms.filter(condition);
        this.cleanUpTerms();
    }
    replaceDieResults(sourceDicePool) {
        sourceDicePool.forEach((die, index) => {
            this.dice[index].results = die.results;
        });
        this._total = this._evaluateTotal();
    }
    /* --- Internal Functions --- */
    cleanUpTerms() {
        while (this.terms[this.terms.length - 1] instanceof
            foundry.dice.terms.OperatorTerm)
            this.terms.pop();
        this.resetFormula();
    }
    configureModifiers() {
        // Find the first die term
        const dieTerm = this.terms.find((term) => term instanceof foundry.dice.terms.Die);
        const shouldApplyModifier = this.hasAdvantage || this.hasDisadvantage;
        if (dieTerm && shouldApplyModifier) {
            const modifier = this.hasAdvantage ? 'kh' : 'kl';
            if (dieTerm.number && dieTerm.number > 1) {
                // Remove one die from the original
                dieTerm.number -= 1;
                // Create a new term with the modifier
                const newTerm = new foundry.dice.terms.Die({
                    number: 2,
                    faces: dieTerm.faces,
                    modifiers: [modifier],
                });
                this.terms.push(new foundry.dice.terms.OperatorTerm({
                    operator: '+',
                }), newTerm);
            }
            else if (dieTerm.number === 1) {
                dieTerm.number = 2;
                dieTerm.modifiers.push(modifier);
            }
        }
        // Re-compile the underlying formula
        this._formula = Roll.getFormula(this.terms);
        // Mark as configured
        this.options.configured = true;
    }
}

// Constants
const TEMPLATE$3 = `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_CHAT_MODIFY_DAMAGE}`;
class DamageModifierDialog extends foundry.applications.api.DialogV2 {
    isHealing;
    action;
    resolve;
    constructor(isHealing, action, resolve, content) {
        super({
            window: {
                title: `COSMERE.ChatMessage.ModifierDialog.${action === 'reduce-focus' ? 'FocusTitle' : isHealing ? 'HealingTitle' : 'DamageTitle'}`,
            },
            content,
            buttons: [
                {
                    label: 'GENERIC.Button.Confirm',
                    action: 'submit',
                    default: true,
                    // NOTE: Callback must be async
                    // eslint-disable-next-line @typescript-eslint/require-await
                    callback: async () => this.onContinue(),
                },
            ],
        });
        this.isHealing = isHealing;
        this.action = action;
        this.resolve = resolve;
    }
    /* --- Statics --- */
    static async show(options = {
        isHealing: false,
        action: '',
    }) {
        // Render dialog inner HTML
        const content = await renderTemplate(TEMPLATE$3, {
            isHealing: options.isHealing,
            action: options.action,
        });
        // Render dialog and wrap as promise
        return new Promise((resolve) => {
            void new DamageModifierDialog(options.isHealing, options.action, resolve, content).render(true);
        });
    }
    /* --- Actions --- */
    onContinue() {
        const form = this.element.querySelector('form');
        // Resolve
        this.resolve(form.modifier.value ? form.modifier.valueAsNumber : 0);
    }
}

const HOOKS = {
    /* ----- Actor Hooks ----- */
    /* -- Damage application hooks -- */
    PRE_APPLY_DAMAGE: `${SYSTEM_ID}.preApplyDamage`,
    APPLY_DAMAGE: `${SYSTEM_ID}.applyDamage`,
    /* -- Injury Application Hooks -- */
    PRE_APPLY_INJURY: `${SYSTEM_ID}.preApplyInjury`,
    APPLY_INJURY: `${SYSTEM_ID}.applyInjury`,
    /* -- Rest Hooks -- */
    PRE_REST: `${SYSTEM_ID}.preRest`,
    REST: `${SYSTEM_ID}.rest`,
    /* ----- Item Hooks ----- */
    /* -- Item Activation/Usage Hooks -- */
    USE_ITEM: `${SYSTEM_ID}.useItem`,
    PRE_USE_ITEM: `${SYSTEM_ID}.preUseItem`,
    MODE_ACTIVATE_ITEM: `${SYSTEM_ID}.modeActivateItem`,
    PRE_MODE_ACTIVATE_ITEM: `${SYSTEM_ID}.preModeActivateItem`,
    MODE_DEACTIVATE_ITEM: `${SYSTEM_ID}.modeDeactivateItem`,
    PRE_MODE_DEACTIVATE_ITEM: `${SYSTEM_ID}.preModeDeactivateItem`,
    /**
     * Executed when a Goal Item's progresses gets updated towards completion.
     * This only counts forward progress, not executed when the goal's progress is reduced.
     */
    PROGRESS_GOAL: `${SYSTEM_ID}.progressGoal`,
    /**
     * Executed before a Goal Item's progress is updated towards completion.
     */
    PRE_PROGRESS_GOAL: `${SYSTEM_ID}.preProgressGoal`,
    /**
     * Executed when a Goal Item's progress is updated.
     */
    UPDATE_PROGRESS_GOAL: `${SYSTEM_ID}.updateProgressGoal`,
    /**
     * Executed before a Goal Item's progress is updated.
     */
    PRE_UPDATE_PROGRESS_GOAL: `${SYSTEM_ID}.preUpdateProgressGoal`,
    /**
     * Executed when a Goal Item's progress gets filled and the goal is completed.
     */
    COMPLETE_GOAL: `${SYSTEM_ID}.completeGoal`,
    /**
     * Executed before a Goal Item's progress is filled and the goal is completed.
     */
    PRE_COMPLETE_GOAL: `${SYSTEM_ID}.preCompleteGoal`,
    /* ----- Chat Message Hooks ----- */
    /* -- Message Interaction Hooks -- */
    MESSAGE_INTERACTED: `${SYSTEM_ID}.chatMessageInteract`,
    /* ----- Roll Hooks ----- */
    PRE_ROLL: (context) => `${SYSTEM_ID}.pre${context.toLowerCase().capitalize()}Roll`,
    ROLL: (context) => `${SYSTEM_ID}.${context.toLowerCase()}Roll`,
    PRE_SKILL_ROLL: `${SYSTEM_ID}.preSkillRoll`,
    SKILL_ROLL: `${SYSTEM_ID}.skillRoll`,
    PRE_ITEM_ROLL: `${SYSTEM_ID}.preItemRoll`,
    ITEM_ROLL: `${SYSTEM_ID}.itemRoll`,
    PRE_ATTACK_ROLL: `${SYSTEM_ID}.preAttackRoll`,
    ATTACK_ROLL: `${SYSTEM_ID}.attackRoll`,
    PRE_DAMAGE_ROLL: `${SYSTEM_ID}.preDamageRoll`,
    DAMAGE_ROLL: `${SYSTEM_ID}.damageRoll`,
    PRE_INJURY_TYPE_ROLL: `${SYSTEM_ID}.preInjuryTypeRoll`,
    INJURY_TYPE_ROLL: `${SYSTEM_ID}.injuryTypeRoll`,
    PRE_INJURY_DURATION_ROLL: `${SYSTEM_ID}.preInjuryDurationRoll`,
    INJURY_DURATION_ROLL: `${SYSTEM_ID}.injuryDurationRoll`,
    PRE_SHORT_REST_RECOVERY_ROLL: `${SYSTEM_ID}.preShortRestRecoveryRoll`,
    SHORT_REST_RECOVERY_ROLL: `${SYSTEM_ID}.shortRestRecoveryRoll`,
    PRE_ROLL_CONFIGURATION: (context) => `${SYSTEM_ID}.pre${context.toLowerCase().capitalize()}RollConfiguration`,
    ROLL_CONFIGURATION: (context) => `${SYSTEM_ID}.${context.toLowerCase()}RollConfiguration`,
    PRE_SKILL_ROLL_CONFIGURATION: `${SYSTEM_ID}.preSkillRollConfiguration`,
    SKILL_ROLL_CONFIGURATION: `${SYSTEM_ID}.skillRollConfiguration`,
    PRE_ITEM_ROLL_CONFIGURATION: `${SYSTEM_ID}.preItemRollConfiguration`,
    ITEM_ROLL_CONFIGURATION: `${SYSTEM_ID}.itemRollConfiguration`,
    PRE_ATTACK_ROLL_CONFIGURATION: `${SYSTEM_ID}.preAttackRollConfiguration`,
    ATTACK_ROLL_CONFIGURATION: `${SYSTEM_ID}.attackRollConfiguration`,
    /* ---- Migration Hooks ----- */
    PRE_MIGRATION: `${SYSTEM_ID}.preMigration`,
    MIGRATION: `${SYSTEM_ID}.migration`,
    PRE_MIGRATE_VERSION: `${SYSTEM_ID}.preMigrateVersion`,
    MIGRATE_VERSION: `${SYSTEM_ID}.migrateVersion`,
    /* ----- Enricher Hooks ----- */
    TRIGGER_ENRICHER: (type) => `${SYSTEM_ID}.trigger${type.toLowerCase().capitalize()}Enricher`,
    TRIGGER_TEST_ENRICHER: `${SYSTEM_ID}.triggerTestEnricher`,
    TRIGGER_DAMAGE_ENRICHER: `${SYSTEM_ID}.triggerDamageEnricher`,
};

const MESSAGE_TYPES = {
    SKILL: 'skill',
    ACTION: 'action',
    INJURY: 'injury',
    DAMAGE_TAKEN: 'taken',
};
class CosmereChatMessage extends ChatMessage {
    useGraze = false;
    totalDamageNormal = 0;
    totalDamageGraze = 0;
    /* --- Accessors --- */
    get actorSource() {
        // NOTE: game.scenes resolves to any type
        /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access */
        if (this.speaker.scene && this.speaker.token) {
            const scene = game.scenes.get(this.speaker.scene);
            const token = scene?.tokens?.get(this.speaker.token);
            if (token)
                return token.actor;
        }
        return game.actors?.get(this.speaker.actor);
        /* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access */
    }
    get itemSource() {
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        return this.actorSource
            ? (this.actorSource.items.get(this.flags[SYSTEM_ID].message.item) ??
                null)
            : null;
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    }
    get d20Rolls() {
        return this.rolls.filter((r) => r instanceof D20Roll);
    }
    get damageRolls() {
        return this.rolls.filter((r) => r instanceof DamageRoll);
    }
    get hasSkillTest() {
        return this.d20Rolls.length > 0;
    }
    get hasDamage() {
        return this.damageRolls.length > 0;
    }
    get hasInjury() {
        return this.getFlag(SYSTEM_ID, MESSAGE_TYPES.INJURY) !== undefined;
    }
    get hasDamageTaken() {
        return (this.getFlag(SYSTEM_ID, MESSAGE_TYPES.DAMAGE_TAKEN) !== undefined);
    }
    get headerImg() {
        return this.getFlag(SYSTEM_ID, 'headerImg');
    }
    /* --- Rendering --- */
    async getHTML() {
        const html = await super.getHTML();
        // Enrich the chat card
        await this.enrichCardHeader(html);
        await this.enrichCardContent(html);
        html.find('.enricher-link > a').on('click', (event) => event.stopPropagation());
        html.find('.collapsible').on('click', (event) => this.onClickCollapsible(event));
        return html;
    }
    async enrichCardHeader(html) {
        const actor = this.actorSource;
        let img;
        let name;
        if (this.isContentVisible) {
            img = this.headerImg ?? actor?.img ?? this.author.avatar;
            name = this.alias;
        }
        else {
            img = this.author.avatar;
            name = this.author.name;
        }
        const headerHTML = await renderSystemTemplate(TEMPLATES.CHAT_CARD_HEADER, {
            img,
            name,
            subtitle: name !== this.author.name ? this.author.name : undefined,
            timestamp: html.find('.message-timestamp').text(),
            canRepeat: this.hasSkillTest || this.hasDamage,
        });
        // Replace header
        html.find('.message-header').replaceWith(headerHTML);
        const deleteButton = html
            .find('.message-metadata')
            .find('.message-delete');
        if (!game.user.isGM)
            deleteButton?.remove();
        html.find('.message-repeat').on('click', (event) => {
            void this.onClickRepeat(event);
        });
    }
    async enrichCardContent(html) {
        if (!this.isContentVisible)
            return;
        const type = this.getFlag(SYSTEM_ID, 'message.type');
        if (!type || !Object.values(MESSAGE_TYPES).includes(type))
            return;
        const content = $(await renderSystemTemplate(TEMPLATES.CHAT_CARD_CONTENT, {}));
        this.enrichDescription(content);
        await this.enrichSkillTest(content);
        await this.enrichDamage(content);
        await this.enrichInjury(content);
        await this.enrichDamageTaken(content);
        await this.enrichTestTargets(content);
        // Replace content
        html.find('.message-content').replaceWith(content);
        // Setup hover buttons when the message is actually hovered(for optimisation).
        let hoverSetupComplete = false;
        content.on('mouseenter', async () => {
            if (!hoverSetupComplete) {
                hoverSetupComplete = true;
                await this.enrichCardOverlay(content);
            }
            this.onOverlayHoverStart(content);
        });
        content.on('mouseleave', () => {
            this.onOverlayHoverEnd(content);
        });
        // Run hover end once to ensure all hover buttons are in the correct state.
        this.onOverlayHoverEnd(content);
    }
    enrichDescription(html) {
        const description = this.getFlag(SYSTEM_ID, 'message.description');
        if (!description)
            return;
        html.find('.chat-card').append(description);
    }
    async enrichSkillTest(html) {
        if (!this.hasSkillTest)
            return;
        const d20Roll = this.d20Rolls[0];
        const skill = d20Roll?.options?.data?.skill;
        if (!skill)
            return;
        const sectionHTML = await renderSystemTemplate(TEMPLATES.CHAT_CARD_SECTION, {
            type: 'skill',
            icon: 'fa-regular fa-dice-d20',
            title: game.i18n.localize('GENERIC.SkillTest'),
            subtitle: {
                skill: skill.id
                    ? CONFIG.COSMERE.skills[skill.id].label
                    : `${game.i18n.localize('GENERIC.Custom')} ${game.i18n.localize('GENERIC.Skill')}`,
                attribute: skill.attribute
                    ? CONFIG.COSMERE.attributes[d20Roll?.options?.defaultAttribute ??
                        skill.attribute].labelShort
                    : game.i18n?.localize('GENERIC.None'),
            },
            content: await d20Roll.getHTML(),
        });
        const section = $(sectionHTML);
        const tooltip = section.find('.dice-tooltip');
        this.enrichD20Tooltip(d20Roll, tooltip[0]);
        tooltip.prepend(section.find('.dice-formula'));
        html.find('.chat-card').append(section);
    }
    async enrichTestTargets(html) {
        if (!this.hasSkillTest)
            return;
        const targets = this.getFlag(SYSTEM_ID, 'message.targets');
        if (!targets || targets.length === 0)
            return;
        const d20Roll = this.d20Rolls[0];
        const success = '<i class="fas fa-check success"></i>';
        const failure = '<i class="fas fa-times failure"></i>';
        const targetData = [];
        for (const target of targets) {
            targetData.push({
                name: target.name,
                uuid: target.uuid,
                phyDef: target.def.phy,
                phyIcon: (d20Roll.total ?? 0) >= target.def.phy ? success : failure,
                cogDef: target.def.cog,
                cogIcon: (d20Roll.total ?? 0) >= target.def.cog ? success : failure,
                spiDef: target.def.spi,
                spiIcon: (d20Roll.total ?? 0) >= target.def.spi ? success : failure,
            });
        }
        const trayHTML = await renderSystemTemplate(TEMPLATES.CHAT_CARD_TRAY_TARGETS, {
            targets: targetData,
        });
        const tray = $(trayHTML);
        tray.find('li.target').on('click', (event) => {
            void this.onClickTarget(event);
        });
        html.find('.chat-card').append(tray);
    }
    async enrichDamage(html) {
        if (!this.hasDamage)
            return;
        const damageRolls = this.damageRolls;
        this.totalDamageNormal = 0;
        this.totalDamageGraze = 0;
        let tooltipNormalHTML = '';
        let tooltipGrazeHTML = '';
        const partsNormal = [];
        const partsGraze = [];
        const types = new Set();
        for (const rollNormal of damageRolls) {
            const type = rollNormal.damageType
                ? game.i18n.localize(CONFIG.COSMERE.damageTypes[rollNormal.damageType].label)
                : '';
            const typeIcon = rollNormal.damageType
                ? `<img src="${CONFIG.COSMERE.damageTypes[rollNormal.damageType].icon}">`
                : '';
            types.add([type, typeIcon]);
            this.totalDamageNormal += rollNormal.total ?? 0;
            partsNormal.push(rollNormal.formula);
            const tooltipNormal = $(await rollNormal.getTooltip());
            this.enrichDamageTooltip(rollNormal, type, typeIcon, tooltipNormal);
            tooltipNormalHTML +=
                tooltipNormal.find('.tooltip-part')[0]?.outerHTML || ``;
            if (rollNormal.options.graze) {
                const rollGraze = DamageRoll.fromData(rollNormal.options
                    .graze);
                this.totalDamageGraze += rollGraze.total ?? 0;
                partsGraze.push(rollGraze.formula);
                const tooltipGraze = $(await rollGraze.getTooltip());
                this.enrichDamageTooltip(rollGraze, type, typeIcon, tooltipGraze);
                tooltipGrazeHTML +=
                    tooltipGraze.find('.tooltip-part')[0]?.outerHTML || '';
            }
        }
        const critical = damageRolls.some((d) => d.isCritical);
        const damageHTML = await renderSystemTemplate(TEMPLATES.CHAT_ROLL_DAMAGE, {
            formulaNormal: partsNormal.join(' + '),
            formulaGraze: partsGraze.join(' + '),
            tooltipNormal: tooltipNormalHTML,
            tooltipGraze: tooltipGrazeHTML,
            totalNormal: this.totalDamageNormal,
            totalGraze: this.totalDamageGraze,
            critical,
            showGraze: this.damageRolls.some((roll) => roll.options.graze),
        });
        const footer = getSystemSetting(SETTINGS.CHAT_ENABLE_APPLY_BUTTONS)
            ? await renderSystemTemplate(TEMPLATES.CHAT_CARD_DAMAGE_BUTTONS, {
                overlay: !getSystemSetting(SETTINGS.CHAT_ALWAYS_SHOW_BUTTONS),
            })
            : undefined;
        const isHealing = this.damageRolls.some((r) => r.damageType === DamageType.Healing);
        const sectionHTML = await renderSystemTemplate(TEMPLATES.CHAT_CARD_SECTION, {
            type: 'damage',
            // This will need to be handled better when we do proper multi damage support
            icon: `fas ${isHealing ? 'fa-heart' : 'fa-heart-crack'}`,
            title: game.i18n.localize(isHealing ? 'GENERIC.Healing' : 'GENERIC.Damage'),
            content: damageHTML,
            footer,
            critical,
            damageTypes: Array.from(types)
                .map((type) => `${type[0]} ${type[1]}`)
                .sort()
                .join(' | '),
        });
        const section = $(sectionHTML);
        section.find('.dice-subtotal').on('click', (event) => {
            this.onSwitchDamageMode(event);
        });
        section.find('.apply-buttons button').on('click', async (event) => {
            await this.onClickApplyButton(event);
        });
        html.find('.chat-card').append(section);
    }
    async enrichInjury(html) {
        if (!this.hasInjury)
            return;
        const injury = TableResult.fromSource(this.getFlag(SYSTEM_ID, 'injury.details'));
        const injuryRoll = Roll.fromData(this.getFlag(SYSTEM_ID, 'injury.roll'));
        const data = injury?.getFlag(SYSTEM_ID, 'injury-data');
        const durationRoll = this.rolls.find((r) => !(r instanceof D20Roll) && !(r instanceof DamageRoll));
        let title;
        const actor = this.actorSource?.name ?? 'Actor';
        switch (data.type) {
            case "death" /* InjuryType.Death */:
                title = game.i18n.format('COSMERE.ChatMessage.InjuryDuration.Dead', { actor });
                break;
            case "permanent_injury" /* InjuryType.PermanentInjury */:
                title = game.i18n.format('COSMERE.ChatMessage.InjuryDuration.Permanent', { actor });
                break;
            default: {
                title = game.i18n.format('COSMERE.ChatMessage.InjuryDuration.Temporary', { actor, days: durationRoll?.total ?? 0 });
                break;
            }
        }
        const sectionHTML = await renderSystemTemplate(TEMPLATES.CHAT_CARD_INJURY, {
            title,
            img: injury.img,
            description: injury.text,
            formula: injuryRoll?.formula,
            total: injuryRoll?.total,
            tooltip: await injuryRoll?.getTooltip(),
            type: game.i18n.localize(CONFIG.COSMERE.injury.types[data.type].label),
        });
        const section = $(sectionHTML);
        const tooltip = section.find('.dice-tooltip');
        this.enrichD20Tooltip(injuryRoll, tooltip[0]);
        tooltip.prepend(section.find('.dice-formula'));
        if (game.user.isGM || this.isAuthor) {
            section.find('.icon.clickable').on('click', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                // Handle interaction hook
                if (this.onInteraction(event) === false)
                    return;
                const button = event.currentTarget;
                const action = button.dataset.action;
                if (action === 'apply') {
                    const duration = durationRoll?.total ?? 0;
                    /**
                     * Hook: preApplyInjury
                     *
                     * Passes the injury data
                     */
                    if (Hooks.call(HOOKS.PRE_APPLY_INJURY, this, this.actorSource, { type: data.type, duration }) === false)
                        return;
                    const injuryItem = (await Item.create({
                        type: "injury" /* ItemType.Injury */,
                        name: game.i18n.localize(CONFIG.COSMERE.injury.types[data.type].label),
                        system: {
                            duration: {
                                remaining: duration,
                            },
                        },
                    }, { parent: this.actorSource }));
                    /**
                     * Hook: applyInjury
                     *
                     * Passes the created injury item
                     */
                    Hooks.callAll(HOOKS.APPLY_INJURY, this, this.actorSource, injuryItem);
                }
            });
        }
        else {
            section.find('.icon.clickable').remove();
        }
        html.find('.chat-card').append(section);
    }
    async enrichDamageTaken(html) {
        if (!this.hasDamageTaken)
            return;
        const { health, damageTaken, damageDeflect, damageIgnore, damageImmune, appliedImmunities, target, undo, } = this.getFlag(SYSTEM_ID, MESSAGE_TYPES.DAMAGE_TAKEN);
        const actor = (await fromUuid(target));
        if (!actor)
            return;
        // Whether or not the damage is actually healing
        const isHealing = damageTaken < 0;
        let immunityList = Object.entries(appliedImmunities);
        immunityList = immunityList.sort(([, amountA], [, amountB]) => amountB - amountA);
        const immunitiesBreakdown = `<span class="immunity-total">${damageImmune} <i class="fas fa-shield"></i></span>`;
        const calculationDeflect = damageDeflect > 0
            ? `${actor.deflect} <i data-tooltip="COSMERE.Actor.Statistics.Deflect" class='fas fa-shield-halved'></i>`
            : undefined;
        const calculationIgnore = damageIgnore > 0
            ? `${damageIgnore} <i data-tooltip="COSMERE.Damage.IgnoreDeflect" class='fas fa-shield-slash'></i>`
            : undefined;
        const calculationImmune = damageImmune > 0 ? immunitiesBreakdown : undefined;
        // Combine calculations
        const calculation = [
            [
                damageDeflect + damageImmune,
                calculationDeflect,
                calculationImmune,
            ]
                .filter((v) => !!v)
                .join(' - '),
            calculationIgnore,
        ]
            .filter((v) => !!v)
            .join(' + ');
        const sectionHTML = await renderSystemTemplate(TEMPLATES.CHAT_CARD_DAMAGE_TAKEN, {
            type: isHealing ? 'healing' : 'injury',
            img: isHealing
                ? 'icons/magic/life/cross-beam-green.webp'
                : 'icons/skills/wounds/injury-stitched-flesh-red.webp',
            title: game.i18n.format(`COSMERE.ChatMessage.${isHealing ? 'ApplyHealing' : 'ApplyDamage'}`, { actor: actor.name, amount: Math.abs(damageTaken) }),
            subtitle: isHealing
                ? undefined
                : game.i18n.format('COSMERE.ChatMessage.DamageCalculation', { calculation }),
            tooltip: isHealing
                ? 'COSMERE.ChatMessage.Buttons.UndoHealing'
                : 'COSMERE.ChatMessage.Buttons.UndoDamage',
            undo,
        });
        const section = $(sectionHTML);
        if (game.user.isGM || this.isAuthor) {
            section.find('.icon.clickable').on('click', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                // Handle interaction hook
                if (this.onInteraction(event) === false)
                    return;
                const button = event.currentTarget;
                const action = button.dataset.action;
                if (action === 'undo') {
                    await actor.update({
                        'system.resources.hea.value': actor.system.resources["hea" /* Resource.Health */].value +
                            (health > damageTaken ? damageTaken : health),
                    });
                    await this.setFlag(SYSTEM_ID, 'taken.undo', false);
                    void this.update({ flags: this.flags });
                }
            });
        }
        else {
            section.find('.icon.clickable').remove();
        }
        const immunitiesTooltip = document.createElement('div');
        immunitiesTooltip.classList.add('immunity-tooltip');
        immunitiesTooltip.innerHTML = `
            <span>${game.i18n?.localize('COSMERE.Actor.Statistics.Immunities')}</span>
            ${immunityList
            .map(([damageType, amount]) => `
                <div class="immunity">
                    <i class="fas fa-shield"></i>
                    <span>${game.i18n.localize(CONFIG.COSMERE.damageTypes[damageType].label)} ${amount}</span>
                </div>
                `)
            .join('')}`;
        section.find('.immunity-total').on('mouseover', (event) => {
            game.tooltip?.activate(event.target, {
                content: immunitiesTooltip,
            });
        });
        html.find('.chat-card').append(section);
    }
    /**
     * Augment damage roll tooltips with some additional information and styling.
     * @param {DamageRoll} roll The roll instance.
     * @param {string} type The type of the damage as a string.
     * @param {string} icon The icon of the damage type as a path string.
     * @param {JQuery} html The roll tooltip markup.
     * @returns
     */
    enrichDamageTooltip(roll, type, icon, html) {
        html.find('.label').text(type);
        html.find('.label').parent().prepend(icon);
        const constant = getConstantFromRoll(roll);
        if (constant === 0)
            return;
        const sign = constant < 0 ? '-' : '+';
        const newTotal = Number(html.find('.value').text()) + constant;
        if (roll.hasDice)
            html.find('.value').text(newTotal);
        html.find('.dice-rolls').append(`<li class="constant">
                ${roll.hasDice || constant < 0
            ? `<span class="sign">${sign}</span>`
            : ''}
                ${constant}
            </li>`);
    }
    /**
     * Augment d20 roll tooltips with some additional information and styling.
     * @param {Roll} roll The roll instance.
     * @param {HTMLElement} html The roll tooltip markup.
     */
    enrichD20Tooltip(roll, html) {
        const constant = getConstantFromRoll(roll);
        if (constant === 0)
            return;
        const sign = constant < 0 ? '-' : '+';
        const part = document.createElement('section');
        part.classList.add('tooltip-part', 'constant');
        part.innerHTML = `
            <div class="dice">
                <ol class="dice-rolls"></ol>
                <div class="total">
                <span class="value"><span class="sign">${sign}</span>${Math.abs(constant)}</span>
                </div>
            </div>
            `;
        html.appendChild(part);
    }
    /**
     * Adds overlay buttons to a chat card for retroactively making a roll into a multi roll or a crit.
     * @param {JQuery} html The object to add overlay buttons to.
     */
    async enrichCardOverlay(html) {
        if (!getSystemSetting(SETTINGS.CHAT_ENABLE_OVERLAY_BUTTONS))
            return;
        const overlayD20 = await renderSystemTemplate(TEMPLATES.CHAT_OVERLAY_D20, {
            imgAdvantage: `systems/${SYSTEM_ID}/assets/icons/svg/dice/retro_adv.svg`,
            imgDisadvantage: `systems/${SYSTEM_ID}/assets/icons/svg/dice/retro_dis.svg`,
        });
        html.find('.dice-roll-d20 .dice-total').append($(overlayD20));
        html.find('.overlay-d20 div').on('click', async (event) => {
            await this.onClickOverlayD20(event);
        });
        const overlayCrit = await renderSystemTemplate(TEMPLATES.CHAT_OVERLAY_CRIT, {
            imgCrit: `systems/${SYSTEM_ID}/assets/icons/svg/dice/retro_crit.svg`,
        });
        html.find('.dice-roll-damage .dice-total').append($(overlayCrit));
        html.find('.overlay-crit div').on('click', async (event) => {
            await this.onClickOverlayCrit(event);
        });
    }
    /**
     * Listen for shift key being pressed to show the chat message "delete" icon, or released (or focus lost) to hide it.
     */
    static activateListeners() {
        window.addEventListener('keydown', () => this.toggleModifiers({ releaseAll: false }), { passive: true });
        window.addEventListener('keyup', () => this.toggleModifiers({ releaseAll: false }), { passive: true });
        window.addEventListener('blur', () => this.toggleModifiers({ releaseAll: true }), { passive: true });
    }
    /**
     * Toggles attributes on the chatlog based on which modifier keys are being held.
     * @param {object} [options]
     * @param {boolean} [options.releaseAll=false]  Force all modifiers to be considered released.
     */
    static toggleModifiers({ releaseAll = false }) {
        document.querySelectorAll('.chat-sidebar > ol').forEach((chatlog) => {
            const chatlogHTML = chatlog;
            for (const key of Object.values(KeyboardManager.MODIFIER_KEYS)) {
                if (game.keyboard.isModifierActive(key) && !releaseAll)
                    chatlogHTML.dataset[`modifier${key}`] = '';
                else
                    delete chatlogHTML.dataset[`modifier${key}`];
            }
        });
    }
    /* --- Handlers --- */
    /**
     * Handles a d20 overlay button click event.
     * @param {JQuery.ClickEvent} event The originating event of the button click.
     */
    async onClickOverlayD20(event) {
        event.preventDefault();
        event.stopPropagation();
        const button = event.currentTarget;
        const action = button.dataset.action;
        const state = button.dataset.state;
        if (action === 'retro' && state) {
            const roll = this.d20Rolls[0];
            const d20BaseTerm = roll.terms.find((d) => d instanceof foundry.dice.terms.Die && d.faces === 20);
            if (!d20BaseTerm || d20BaseTerm.number === 2)
                return;
            const d20Additional = await new Roll(`${2 - d20BaseTerm.number}d20${d20BaseTerm.modifiers.join('')}`).evaluate();
            const modifiers = new Array();
            d20BaseTerm.modifiers.forEach((m) => modifiers.push(m));
            const d20Forced = new foundry.dice.terms.Die({
                number: 2,
                faces: 20,
                results: [
                    ...d20BaseTerm.results,
                    ...d20Additional.dice[0].results,
                ],
                modifiers,
            });
            d20Forced.keep(state);
            d20Forced.modifiers.push(state);
            roll.terms[roll.terms.indexOf(d20BaseTerm)] = d20Forced;
            roll.options.advantageMode =
                state === 'kh'
                    ? AdvantageMode.Advantage
                    : state === 'kl'
                        ? AdvantageMode.Disadvantage
                        : AdvantageMode.None;
            roll.resetFormula();
            roll.resetTotal();
            void this.update({ rolls: this.rolls });
        }
    }
    /**
     * Handles a crit overlay button click event.
     * @param {JQuery.ClickEvent} event The originating event of the button click.
     */
    async onClickOverlayCrit(event) {
        event.preventDefault();
        event.stopPropagation();
        const button = event.currentTarget;
        const action = button.dataset.action;
        if (action === 'retro') {
            const clone = await Promise.all(this.rolls.map(async (roll) => {
                if (!(roll instanceof DamageRoll))
                    return roll;
                const crit = new DamageRoll(roll.formula, roll.data, {
                    damageType: roll.damageType,
                    mod: roll.mod,
                    damageSourceName: roll.damageSourceName,
                    advantageMode: roll.options.advantageMode ?? AdvantageMode.None,
                    maximize: true,
                    minimize: false,
                    critical: true,
                });
                roll.dice.forEach((die, index) => {
                    die.results.forEach((r) => (r.result = die.faces ?? 0));
                    crit.dice[index].results = die.results;
                });
                await crit.evaluate();
                if (roll.graze) {
                    const graze = new DamageRoll(roll.graze.formula, roll.graze.data, {
                        damageType: roll.graze.damageType,
                        mod: roll.graze.mod,
                        damageSourceName: roll.graze.damageSourceName,
                        advantageMode: roll.graze.options.advantageMode ??
                            AdvantageMode.None,
                        maximize: true,
                        minimize: false,
                        critical: true,
                    });
                    DamageRoll.fromData(roll.graze).dice.forEach((die, index) => {
                        die.results.forEach((r) => (r.result = die.faces ?? 0));
                        graze.dice[index].results = die.results;
                    });
                    await graze.evaluate();
                    crit.graze = graze;
                }
                return crit;
            }));
            void this.update({ rolls: clone });
        }
    }
    /**
     * Handles a click event on the toggle between using graze damage and full damage.
     * @param {JQuery.ClickEvent} event The originating event of the button click.
     * @returns
     */
    onSwitchDamageMode(event) {
        const toggle = $(event.currentTarget);
        if (toggle.hasClass('active'))
            return;
        event.preventDefault();
        event.stopPropagation();
        this.useGraze = !this.useGraze;
        toggle.addClass('active');
        toggle.siblings('.dice-subtotal').removeClass('active');
        if (toggle.siblings('.overlay-crit').first().hasClass('left')) {
            toggle
                .siblings('.overlay-crit.left')
                .removeClass('left')
                .addClass('right');
        }
        else if (toggle.siblings('.overlay-crit').first().hasClass('right')) {
            toggle
                .siblings('.overlay-crit.right')
                .removeClass('right')
                .addClass('left');
        }
    }
    /**
     * Handles a repeat button click event.
     * @param {JQuery.ClickEvent} event The originating event of the button click.
     */
    async onClickRepeat(event) {
        event.preventDefault();
        event.stopPropagation();
        // Handle interaction hook
        if (this.onInteraction(event) === false)
            return;
        const clone = await Promise.all(this.rolls.map(async (roll) => await roll.reroll()));
        void ChatMessage.create({
            user: game.user.id,
            speaker: this.speaker,
            flags: this.flags,
            rolls: clone,
        });
    }
    /**
     * Handles an apply button click event.
     * @param {JQuery.ClickEvent} event The originating event of the button click.
     */
    async onClickApplyButton(event, forceRolls = null) {
        event.preventDefault();
        event.stopPropagation();
        // Handle interaction hook
        if (this.onInteraction(event) === false)
            return;
        const button = event.currentTarget;
        const promptModify = !getSystemSetting(SETTINGS.DIALOG_DAMAGE_MODIFIER_SKIP_DEFAULT) ||
            areKeysPressed(KEYBINDINGS.SKIP_DIALOG_DEFAULT);
        const action = button.dataset.action;
        const multiplier = Number(button.dataset.multiplier);
        const targets = getApplyTargets();
        if (targets.size === 0)
            return;
        if (action === 'apply-damage' && multiplier) {
            const modifier = promptModify
                ? await DamageModifierDialog.show({
                    isHealing: multiplier < 0,
                    action: action,
                })
                : 0;
            const damageRolls = forceRolls ?? this.damageRolls;
            const damageToApply = damageRolls.map((r) => ({
                amount: (this.useGraze
                    ? (r.graze?.total ?? 0) + modifier
                    : (r.total ?? 0) + modifier) * Math.abs(multiplier),
                type: multiplier < 0 ? DamageType.Healing : r.damageType,
            }));
            await Promise.all(Array.from(targets).map(async (t) => {
                const target = t.actor;
                return await target.applyDamage(damageToApply, {
                    originatingItem: this.itemSource ?? undefined,
                });
            }));
        }
        if (action === 'reduce-focus') {
            const modifier = promptModify
                ? await DamageModifierDialog.show({
                    isHealing: multiplier < 0,
                    action: action,
                })
                : 0;
            await Promise.all(Array.from(targets).map(async (t) => {
                const target = t.actor;
                return await target.update({
                    'system.resources.foc.value': target.system.resources.foc.value - (1 + modifier),
                });
            }));
        }
    }
    /**
     * Handles collapsible sections expansion on click event.
     * @param {JQuery.ClickEvent} event  The triggering event.
     */
    onClickCollapsible(event) {
        const directTarget = event.target;
        if (directTarget.hasAttribute('data-link') ||
            directTarget.classList.contains('inline-roll')) {
            return;
        }
        event.stopPropagation();
        const target = event.currentTarget;
        target?.classList.toggle('expanded');
    }
    /**
     * Handle target selection and panning.
     * @param {JQuery.ClickEvent} event The triggering event.
     * @returns {Promise} A promise that resolves once the canvas pan has completed.
     * @protected
     */
    async onClickTarget(event) {
        event.stopPropagation();
        const uuid = event.currentTarget.dataset.uuid;
        if (!uuid)
            return;
        const actor = fromUuidSync(uuid);
        const token = actor?.getActiveTokens()[0];
        if (!token)
            return;
        const releaseOthers = !event.shiftKey;
        if (token.controlled)
            token.release();
        else {
            token.control({ releaseOthers });
            return game.canvas.animatePan(token.center);
        }
    }
    /**
     * Handles hover begin events on the given html/jquery object.
     * @param {JQuery} html The object to handle hover begin events for.
     * @private
     */
    onOverlayHoverStart(html) {
        const hasPermission = game.user.isGM || this.isAuthor;
        html.find('.overlay').show();
        html.find('.overlay-d20').toggle(hasPermission &&
            this.hasSkillTest &&
            !(this.d20Rolls[0].hasAdvantage ||
                this.d20Rolls[0].hasDisadvantage));
        html.find('.overlay-crit').toggle(hasPermission &&
            this.hasDamage &&
            this.damageRolls.every((r) => !r.isCritical));
    }
    /**
     * Handles hover end events on the given html/jquery object.
     * @param {JQuery} html The object to handle hover end events for.
     * @private
     */
    onOverlayHoverEnd(html) {
        html.find('.overlay').attr('style', 'display: none;');
    }
    /**
     * Helpers
     */
    /**
     * Call interaction hook
     * @param event
     * @private
     */
    onInteraction(event) {
        /**
         * Hook: chatMessageInteract
         *
         * Pass message and triggering event
         */
        return Hooks.call(HOOKS.MESSAGE_INTERACTED, this, event);
    }
}

const { ApplicationV2: ApplicationV2$f } = foundry.applications.api;
class PickDiceResultDialog extends ComponentHandlebarsApplicationMixin((ApplicationV2$f)) {
    data;
    resolve;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            resizable: false,
            title: 'DIALOG.PickDiceResult.Title',
        },
        classes: ['dialog', 'pick-dice-result'],
        tag: 'dialog',
        position: {
            width: 300,
        },
        actions: {
            'select-result': this.onSelectResult,
            submit: this.onSubmit,
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ROLL_PICK_DICE_RESULT}`,
        },
    });
    rolls;
    submitted = false;
    constructor(data, resolve) {
        super({});
        this.data = data;
        this.resolve = resolve;
        // Mark all results as discarded to begin with
        this.rolls = foundry.utils
            .deepClone(this.data.term.results)
            .map((result) => ({
            ...result,
            discarded: true,
        }));
    }
    /* --- Statics --- */
    static show(data) {
        return new Promise((resolve) => void new this(data, resolve).render(true));
    }
    /* --- Accessors --- */
    get picked() {
        return this.rolls.filter((result) => !result.discarded);
    }
    /* --- Actions --- */
    static onSelectResult(event) {
        // Get index
        const index = $(event.target)
            .closest('[data-index]')
            .data('index');
        if (index === undefined)
            return;
        // Get selected result
        const result = this.rolls[index];
        // Ensure the amount picked is less than the amount to pick
        if (this.picked.length >= this.data.amount && !!result.discarded) {
            return void ui.notifications.error(game.i18n.format('DIALOG.PickDiceResult.Error.TooManyPicked', {
                max: this.data.amount,
            }));
        }
        // Toggle discarded
        result.discarded = !result.discarded;
        // If only 1 result needs to be selected, submit immediately
        void this.render(true);
    }
    static onSubmit() {
        // Apply to term
        this.data.term.results.forEach((result, index) => {
            const match = this.rolls[index];
            result.discarded = match.discarded;
            result.active = match.discarded ? false : result.active;
        });
        // Set submitted
        this.submitted = true;
        // Resolve
        this.resolve(this.data.term.results);
        // Close
        void this.close();
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    _onClose() {
        if (!this.submitted)
            this.resolve(null);
    }
    /* --- Context --- */
    _prepareContext() {
        const isPlotDie = this.data.term instanceof PlotDie;
        return Promise.resolve({
            isPlotDie,
            die: isPlotDie ? 'd6' : this.data.term.denomination,
            faces: this.data.term.faces ?? 0,
            rolls: this.rolls,
            amountLeft: this.data.amount - this.picked.length,
            plotDie: {
                c2: IMPORTED_RESOURCES.PLOT_DICE_C2_IN_CHAT,
                c4: IMPORTED_RESOURCES.PLOT_DICE_C4_IN_CHAT,
                op: IMPORTED_RESOURCES.PLOT_DICE_OP_IN_CHAT,
            },
        });
    }
}

// Dialogs
// Consants
const PICK_MODIFIER_REGEX = /(gm)?p(\d+)?/i;
foundry.dice.terms.Die.MODIFIERS = {
    ...foundry.dice.terms.Die.MODIFIERS,
    p: pick,
    gmp: pick,
};
async function pick(modifier) {
    const rgx = new RegExp(PICK_MODIFIER_REGEX);
    const match = rgx.exec(modifier);
    if (!match)
        return false;
    const [gm, numStr] = match.slice(1);
    const amount = Math.min(parseInt(numStr) || 1, this.number ?? 0);
    // Show dialog
    await PickDiceResultDialog.show({
        term: this,
        amount,
    });
}

async function d20Roll(config) {
    // Handle key modifiers
    const { fastForward, advantageMode, plotDie } = determineConfigurationMode(config.configurable, config.advantageMode
        ? config.advantageMode === AdvantageMode.Advantage
        : undefined, config.advantageMode
        ? config.advantageMode === AdvantageMode.Disadvantage
        : undefined, config.plotDie);
    // Replace config values with key modified values
    config.advantageMode = advantageMode;
    config.plotDie = plotDie;
    // Construct the roll
    const roll = new D20Roll(getFormulaDisplayString(['1d20'].concat(config.parts ?? [])), config.data, { ...config });
    /**
     * Hook: preRoll
     */
    if (Hooks.call(HOOKS.PRE_ROLL(config.data.context), roll, // Roll object
    config.data.source, // Source
    config) === false)
        return null;
    if (!fastForward) {
        /**
         * Hook: preRollConfiguration
         */
        if (Hooks.call(HOOKS.PRE_ROLL_CONFIGURATION(config.data.context), config, // Config
        config.data.source) === false)
            return null;
        // Prompt dialog to configure the d20 roll
        const configured = config.configurable !== false
            ? await roll.configureDialog({
                title: config.title,
                raiseStakes: config.plotDie,
                defaultRollMode: config.rollMode ??
                    game.settings.get('core', 'rollMode'),
                defaultAttribute: config.defaultAttribute ??
                    config.data.skill.attribute,
                skillTest: {
                    data: config.data,
                    parts: [],
                },
                plotDie: {},
            })
            : roll;
        /**
         * Hook: rollConfiguration
         */
        Hooks.callAll(HOOKS.ROLL_CONFIGURATION(config.data.context), config, // Config
        config.data.source);
        if (configured === null)
            return null;
    }
    // Evaluate the configure roll
    await roll.evaluate();
    /**
     * Hook: roll
     */
    Hooks.callAll(HOOKS.ROLL(config.data.context), roll, // Roll object
    config.data.source, // Source
    config);
    if (roll && config.chatMessage !== false) {
        await roll.toMessage(config.messageData, config);
    }
    return roll;
}
async function damageRoll(config) {
    // Construct roll
    const roll = new DamageRoll(config.formula, config.data, {
        damageType: config.damageType,
        mod: config.mod,
        advantageMode: config.advantageMode,
        allowStrings: config.allowStrings,
        maximize: config.maximize,
        minimize: config.minimize,
        damageSourceName: config.damageSourceName,
        critical: config.critical,
    });
    /**
     * Hook: preDamageRoll
     */
    // Note: this setup doesn't allow for early exits from hook listeners,
    // in order to not modify the function signature and not jeopardize
    // the results with additional side effects.
    Hooks.callAll(HOOKS.PRE_DAMAGE_ROLL, roll, // Roll object
    config.data.source, // Source
    config);
    // Evaluate the roll
    await roll.evaluate();
    /**
     * Hook: damageRoll
     */
    Hooks.callAll(HOOKS.DAMAGE_ROLL, roll, // Roll object
    config.data.source, // Source
    config);
    // Return result
    return roll;
}

// Constants
const ITEM_EMBED_TEMPLATES = {
    talent: TEMPLATES.ITEM_TALENT_EMBED,
    action: TEMPLATES.ITEM_ACTION_EMBED,
    path: TEMPLATES.ITEM_PATH_EMBED,
    ancestry: TEMPLATES.ITEM_ANCESTRY_EMBED,
};
const HEADING_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
const DEFAULT_HEADING_TAG = 'h3';
async function buildEmbedHTML$4(item, config, options) {
    // Create the link data string
    const linkDataStr = getLinkDataStr(item);
    // Enrich the description
    let description = null;
    if (item.hasDescription())
        description = await TextEditor.enrichHTML(item.system.description?.value ??
            item.system.description?.short ??
            '', {
            relativeTo: options?.relativeTo,
            documents: options?.documents,
            links: options?.links,
            rollData: options?.rollData,
            rolls: options?.rolls,
            secrets: options?.secrets,
        });
    const headingTag = config.values?.find((v) => HEADING_TAGS.includes(v)) ??
        DEFAULT_HEADING_TAG;
    // Get the template
    const hbsTemplate = ITEM_EMBED_TEMPLATES[item.type] ?? TEMPLATES.ITEM_GENERIC_EMBED;
    // Render template
    const html = await renderSystemTemplate(hbsTemplate, {
        item,
        config,
        options,
        linkDataStr,
        description,
        headingTag,
    });
    // Get elements
    const template = document.createElement('template');
    template.innerHTML = html;
    return template.content.children;
}
function createInlineEmbed$3(item, content, config, options) {
    const section = document.createElement('section');
    if (content instanceof HTMLCollection)
        section.append(...content);
    else
        section.append(content);
    section.classList.add('item-embed', item.type);
    // Parse the uuid
    const { id, uuid, collection } = foundry.utils.parseUuid(item.uuid);
    // Set attributes
    section.setAttribute('draggable', 'true');
    section.setAttribute('data-link', '');
    section.dataset.uuid = uuid;
    section.dataset.id = id;
    section.dataset.type = item.documentName;
    if (collection instanceof CompendiumCollection)
        section.dataset.pack = collection.collection;
    return Promise.resolve(section);
}
function getLinkDataStr(item, dataset) {
    // Generate content link
    const link = item.toAnchor({ dataset });
    // Get the dataset
    const outputDataset = link.dataset;
    // Create data string
    return Object.entries(outputDataset)
        .map(([key, value]) => `data-${key}="${value}"`)
        .join(' ');
}
var genericEmbed = {
    buildEmbedHTML: buildEmbedHTML$4,
    createInlineEmbed: createInlineEmbed$3,
    getLinkDataStr,
};

// Generics
async function buildEmbedHTML$3(item, config, options) {
    // Create the link data string
    const linkDataStr = getLinkDataStr(item);
    // Assign prerequisite based on the config
    let prerequisite = null;
    if (config.tree && typeof config.tree === 'string') {
        const tree = (await fromUuid(config.tree));
        // Find the talent node in the tree (ignore nested trees)
        const node = tree.system.nodes.find((n) => n.type === "talent" /* TalentTree.Node.Type.Talent */ &&
            n.talentId === item.system.id);
        if (node) {
            prerequisite = node.prerequisites;
        }
    }
    else if (config.prerequisite && typeof config.prerequisite === 'string') {
        prerequisite = config.prerequisite;
    }
    // Enrich the description
    const description = await TextEditor.enrichHTML(item.system.description?.value ?? item.system.description?.short ?? '', {
        relativeTo: options?.relativeTo,
        documents: options?.documents,
        links: options?.links,
        rollData: options?.rollData,
        rolls: options?.rolls,
        secrets: options?.secrets,
    });
    // Render template
    const html = await renderSystemTemplate(TEMPLATES.ITEM_TALENT_EMBED, {
        item,
        config,
        options,
        linkDataStr,
        prerequisite,
        description,
    });
    // Get elements
    const template = document.createElement('template');
    template.innerHTML = html;
    return template.content.children;
}
var talentEmbed = {
    buildEmbedHTML: buildEmbedHTML$3,
    createInlineEmbed: createInlineEmbed$3,
};

// Mixins
// ApplicationV2
const { ApplicationV2: ApplicationV2$e } = foundry.applications.api;
class TalentTreeEmbed extends ComponentHandlebarsApplicationMixin(ApplicationV2$e) {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'embed', 'talent-tree'],
        position: {
            width: 600,
            top: 0,
            left: 0,
        },
        window: {
            frame: false,
        },
        tag: 'div',
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_TALENT_TREE_EMBED}`,
        },
    });
    #item;
    view;
    linkedItem;
    constructor(options) {
        // Get the aspect ratio of the talent tree
        const aspectRatio = options.item.system.viewBounds.width /
            options.item.system.viewBounds.height;
        // Get configured width
        const width = (options.position?.width ??
            TalentTreeEmbed.DEFAULT_OPTIONS.position.width);
        // Calculate height based on aspect ratio
        const height = width / aspectRatio;
        super(foundry.utils.mergeObject(options, {
            position: {
                height: height,
            },
        }));
        this.#item = options.item;
        this.view = options.view;
        this.linkedItem = options.linkedItem;
    }
    /* --- Accessors --- */
    get item() {
        return this.#item;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
            item: this.item,
            view: this.view,
            linkDataStr: getLinkDataStr(this.linkedItem ?? this.item, {
                tab: 'talents',
            }),
        };
    }
}

// Application
const EMBEDDED_APPS = {};
async function buildEmbedHTML$2(item, config, options) {
    if (!(options?.relativeTo instanceof JournalEntryPage))
        return null;
    // Create the embedded application
    const embededApp = await getEmbedApp(item, options.relativeTo, config);
    // Return target
    return $(`<div class="embed-talent-tree-target" data-id="${embededApp.id}"></div>`)[0];
}
function createInlineEmbed$2(item, content, config, options) {
    const section = document.createElement('section');
    if (content instanceof HTMLCollection)
        section.append(...content);
    else
        section.append(content);
    section.classList.add('item-embed', 'talent-tree');
    return Promise.resolve(section);
}
async function getEmbedApp(item, page, config) {
    const journalEntry = page.parent;
    if (!EMBEDDED_APPS[journalEntry.uuid])
        EMBEDDED_APPS[journalEntry.uuid] = {};
    if (!EMBEDDED_APPS[journalEntry.uuid][page.id])
        EMBEDDED_APPS[journalEntry.uuid][page.id] = {};
    if (!EMBEDDED_APPS[journalEntry.uuid][page.id][item.id]) {
        EMBEDDED_APPS[journalEntry.uuid][page.id][item.id] =
            new TalentTreeEmbed({
                item,
                position: { width: (config.width ?? 600) },
            });
    }
    const app = EMBEDDED_APPS[journalEntry.uuid][page.id][item.id];
    if (config.x || config.y || config.zoom) {
        app.view = {};
        if (config.x)
            app.view.x = config.x;
        if (config.y)
            app.view.y = config.y;
        if (config.zoom)
            app.view.zoom = config.zoom;
    }
    else {
        app.view = undefined;
    }
    if (config.link) {
        app.linkedItem = (await fromUuid(config.link));
    }
    return app;
}
Hooks.on('renderJournalPageSheet', (app, html) => {
    const page = app.document;
    const journalEntry = page.parent;
    if (!EMBEDDED_APPS[journalEntry.uuid]?.[page.id])
        return;
    // Get all embedded applications for this page
    const embedApps = Object.values(EMBEDDED_APPS[journalEntry.uuid][page.id]);
    setTimeout(() => {
        // Render each embedded application
        embedApps.forEach(async (embedApp) => {
            // Render the application
            await embedApp.render(true);
            // Find and replace the target element in the HTML
            html.find(`.embed-talent-tree-target[data-id="${embedApp.id}"]`).replaceWith(embedApp.element);
        });
    }, 10);
});
Hooks.on('closeJournalSheet', (app) => {
    const journalEntry = app.document;
    if (!EMBEDDED_APPS[journalEntry.uuid])
        return;
    Object.values(EMBEDDED_APPS[journalEntry.uuid]).forEach((pageApps) => {
        Object.values(pageApps).forEach((embedApp) => {
            void embedApp.close();
        });
    });
    delete EMBEDDED_APPS[journalEntry.uuid];
});
var talentTreeEmbed = {
    buildEmbedHTML: buildEmbedHTML$2,
    createInlineEmbed: createInlineEmbed$2,
};

// Talent tree embed
async function buildEmbedHTML$1(item, config, options) {
    if (!(options?.relativeTo instanceof JournalEntryPage))
        return null;
    if (config.values?.includes('talents') && item.system.talentTree) {
        // Get the talent tree item
        const tree = (await fromUuid(item.system.talentTree));
        // Build the talent tree embed HTML
        return buildEmbedHTML$2(tree, foundry.utils.mergeObject(config, {
            link: item.uuid,
        }), options);
    }
    else {
        return buildEmbedHTML$4(item, config, options);
    }
}
async function createInlineEmbed$1(item, content, config, options) {
    if (config.values?.includes('talents') && item.system.talentTree) {
        // Get the talent tree item
        const tree = (await fromUuid(item.system.talentTree));
        // Create the inline embed for the talent tree
        return createInlineEmbed$2(tree, content, foundry.utils.mergeObject(config, {
            link: item.uuid,
        }));
    }
    else {
        // Create the inline embed for the generic item
        return createInlineEmbed$3(item, content);
    }
}
var pathEmbed = {
    buildEmbedHTML: buildEmbedHTML$1,
    createInlineEmbed: createInlineEmbed$1,
};

// Talent tree embed
async function buildEmbedHTML(item, config, options) {
    if (!(options?.relativeTo instanceof JournalEntryPage))
        return null;
    if (config.values?.includes('talents') && item.system.talentTree) {
        // Get the talent tree item
        const tree = (await fromUuid(item.system.talentTree));
        // Build the talent tree embed HTML
        return buildEmbedHTML$2(tree, foundry.utils.mergeObject(config, {
            link: item.uuid,
        }), options);
    }
    else {
        return buildEmbedHTML$4(item, config, options);
    }
}
async function createInlineEmbed(item, content, config, options) {
    if (config.values?.includes('talents') && item.system.talentTree) {
        // Get the talent tree item
        const tree = (await fromUuid(item.system.talentTree));
        // Create the inline embed for the talent tree
        return createInlineEmbed$2(tree, content, foundry.utils.mergeObject(config, {
            link: item.uuid,
        }));
    }
    else {
        return createInlineEmbed$3(item, content);
    }
}
var ancestryEmbed = {
    buildEmbedHTML,
    createInlineEmbed,
};

// Embedders
const EMBEDDERS = {
    ["weapon" /* ItemType.Weapon */]: null,
    ["armor" /* ItemType.Armor */]: null,
    ["equipment" /* ItemType.Equipment */]: null,
    ["loot" /* ItemType.Loot */]: null,
    ["ancestry" /* ItemType.Ancestry */]: ancestryEmbed,
    ["culture" /* ItemType.Culture */]: null,
    ["path" /* ItemType.Path */]: pathEmbed,
    ["specialty" /* ItemType.Specialty */]: null,
    ["talent" /* ItemType.Talent */]: talentEmbed,
    ["trait" /* ItemType.Trait */]: null,
    ["action" /* ItemType.Action */]: null,
    ["injury" /* ItemType.Injury */]: null,
    ["connection" /* ItemType.Connection */]: null,
    ["goal" /* ItemType.Goal */]: null,
    ["power" /* ItemType.Power */]: null,
    ["talent_tree" /* ItemType.TalentTree */]: talentTreeEmbed,
};
function getEmbedHelpers$1(type) {
    return EMBEDDERS[type] ?? genericEmbed;
}

// Embed helpers
function getEmbedHelpers(document) {
    switch (document.documentName) {
        case 'Item':
            return getEmbedHelpers$1(document.type);
        default:
            return {}; // No embed helpers available for this document type
    }
}

var ItemRelationshipType;
(function (ItemRelationshipType) {
    ItemRelationshipType["Parent"] = "parent";
    ItemRelationshipType["Child"] = "child";
})(ItemRelationshipType || (ItemRelationshipType = {}));

class ItemRelationship extends foundry.abstract
    .DataModel {
    static defineSchema() {
        return {
            id: new foundry.data.fields.StringField({
                initial: () => foundry.utils.randomID(),
                required: true,
                blank: false,
            }),
            type: new foundry.data.fields.StringField({
                required: true,
                blank: false,
                choices: [
                    ItemRelationshipType.Parent,
                    ItemRelationshipType.Child,
                ],
            }),
            uuid: new foundry.data.fields.DocumentUUIDField({
                required: true,
                nullable: false,
                blank: false,
            }),
            itemType: new foundry.data.fields.StringField({
                required: true,
                blank: false,
                choices: () => Object.keys(CONFIG.COSMERE.items.types),
            }),
            removalPolicy: new foundry.data.fields.StringField({
                required: false,
                initial: "keep" /* ItemRelationshipRemovalPolicy.Keep */,
                blank: false,
                choices: [
                    "remove" /* ItemRelationshipRemovalPolicy.Remove */,
                    "keep" /* ItemRelationshipRemovalPolicy.Keep */,
                ],
            }),
        };
    }
}
(function (ItemRelationship) {
    ItemRelationship.Type = ItemRelationshipType;
})(ItemRelationship || (ItemRelationship = {}));

class ItemRelationshipField extends foundry.data.fields.ObjectField {
    static getModelForType(type) {
        switch (type) {
            case ItemRelationshipType.Parent:
                return ItemRelationship;
            case ItemRelationshipType.Child:
                return ItemRelationship;
            default:
                throw new Error(`Unknown item relationship type: ${type}`);
        }
    }
    _cleanType(value, options) {
        if (!value || !(typeof value === 'object'))
            return {};
        if (!('type' in value))
            return {};
        // Get type
        const type = value.type;
        // Clean value
        return (ItemRelationshipField.getModelForType(type).cleanData(value, options) ?? value);
    }
    _validateType(value, options) {
        if (!value || !(typeof value === 'object'))
            throw new Error('must be an ItemRelationship object');
        if (!('type' in value))
            throw new Error('must have a type property');
        if (typeof value.type !== 'string')
            throw new Error('field "type" must be a string');
        // Get model
        const cls = ItemRelationshipField.getModelForType(value.type);
        if (!cls)
            throw new Error(`field "type" must be one of: ${Object.keys(ItemRelationshipType).join(', ')}`);
        // Perform validation
        return cls.schema.validate(value, options);
    }
    _cast(value) {
        return typeof value === 'object' ? value : {};
    }
    getInitialValue(data) {
        // Get model
        const cls = ItemRelationshipField.getModelForType(data.type);
        // Get initial value
        return cls.schema.getInitialValue(data);
    }
    initialize(value, model, options) {
        // Get model
        const cls = ItemRelationshipField.getModelForType(value.type);
        // Initialize value
        return cls
            ? value instanceof cls
                ? value
                : new cls(foundry.utils.deepClone(value), {
                    parent: model,
                    ...options,
                })
            : foundry.utils.deepClone(value);
    }
}

/**
 * A collection that is backed by a record object instead of a Map.
 * This allows us to persit it properly and update items easily,
 * while still having the convenience of a collection.
 */
class RecordCollection {
    /**
     * NOTE: Must use `any` here as we need the RecordCollection
     * to be backing record object itself. This ensures its stored
     * properly.
     */
    /* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment */
    constructor(entries) {
        if (entries) {
            entries.forEach(([key, value]) => {
                this[key] = value;
            });
        }
    }
    get contents() {
        return Object.entries(this).map(([key, value]) => 'id' in value ? value : { ...value, _id: key });
    }
    find(condition) {
        return Object.entries(this).find(([key, value], index) => condition('id' in value ? value : { ...value, _id: key }, index, this))?.[1];
    }
    filter(condition) {
        return Object.entries(this)
            .filter(([key, value], index) => condition('id' in value ? value : { ...value, _id: key }, index, this))
            .map(([key, value]) => value);
    }
    has(key) {
        return key in this;
    }
    get(key, options = { strict: false }) {
        if (!this.has(key)) {
            if (options.strict)
                throw new Error(`key ${key} not found`);
            return undefined;
        }
        return this[key];
    }
    getName(name, options = { strict: false }) {
        const record = this.contents.find((value) => value &&
            typeof value === 'object' &&
            'name' in value &&
            value.name === name);
        if (!record) {
            if (options.strict)
                throw new Error(`name ${name} not found`);
            return undefined;
        }
        return record;
    }
    map(transformer) {
        return Object.entries(this).map(([key, value], index) => transformer('id' in value ? value : { ...value, _id: key }, index, this));
    }
    reduce(evaluator, initialValue) {
        return Object.entries(this).reduce((accumulator, [key, value], index) => evaluator(accumulator, 'id' in value ? value : { ...value, _id: key }, index, this), initialValue);
    }
    some(condition) {
        return Object.entries(this).some(([key, value], index) => condition('id' in value ? value : { ...value, _id: key }, index, this));
    }
    set(key, value) {
        this[key] = value;
        return this;
    }
    delete(key) {
        if (!this.has(key))
            return false;
        delete this[key];
        return true;
    }
    clear() {
        Object.keys(this).forEach((key) => delete this[key]);
    }
    get size() {
        return Object.keys(this).length;
    }
    entries() {
        return Object.entries(this);
    }
    keys() {
        return Object.keys(this)[Symbol.iterator]();
    }
    values() {
        return Object.entries(this)
            .map(([key, value]) => 'id' in value ? value : { ...value, _id: key })[Symbol.iterator]();
    }
    forEach(callbackfn, thisArg) {
        Object.entries(this).forEach(([key, value]) => callbackfn.call(thisArg, value, key, this));
    }
    [Symbol.iterator]() {
        return this.values();
    }
    // NOTE: This is implicitly readonly as we don't have a way to set it.
    // eslint-disable-next-line @typescript-eslint/class-literal-property-style
    get [Symbol.toStringTag]() {
        return 'RecordCollection';
    }
    toJSON() {
        return Array.from(this.entries()).reduce((acc, [key, value]) => {
            if (value && typeof value === 'object' && 'toJSON' in value) {
                value = value.toJSON();
            }
            return { ...acc, [key]: value };
        }, {});
    }
}
class CollectionField extends foundry.data.fields.ObjectField {
    model;
    CollectionClass;
    constructor(model, options = {}, context, CollectionClass = RecordCollection) {
        super(options, context);
        this.model = model;
        this.CollectionClass = CollectionClass;
    }
    _cleanType(value, options) {
        Array.from(Object.entries(value)).forEach(([key, v]) => {
            const cleaned = this.model.clean(v, options);
            if (key.startsWith('-=')) {
                value[key] = cleaned;
            }
            else {
                // Determine the key
                const prevKey = key;
                key = this.getItemKey(cleaned) ?? key;
                if (key !== prevKey)
                    delete value[prevKey];
                value[key] = cleaned;
            }
        });
        return value;
    }
    _validateType(value, options) {
        if (foundry.utils.getType(value) !== 'Object')
            throw new Error('must be a RecordCollection object');
        const errors = this._validateValues(value, options);
        if (!foundry.utils.isEmpty(errors)) {
            // Create validatior failure
            const failure = new foundry.data.validation.DataModelValidationFailure();
            // Set fields
            failure.fields = errors;
            // Throw error
            throw new foundry.data.validation.DataModelValidationError(failure);
        }
    }
    _validateValues(value, options) {
        const errors = {};
        Object.entries(value).forEach(([id, v]) => {
            const error = this.model.validate(v, options);
            if (error) {
                errors[id] = error;
            }
        });
        return errors;
    }
    _cast(value) {
        // Get entries
        const entries = value instanceof this.CollectionClass
            ? Array.from(value.entries())
            : foundry.utils.getType(value) === 'Map'
                ? Array.from(value.entries())
                : foundry.utils.getType(value) === 'Object'
                    ? Object.entries(value)
                    : foundry.utils.getType(value) === 'Array'
                        ? value.map((v, i) => [this.getItemKey(v) ?? i, v])
                        : [];
        // Reduce entries to Record<string, unknown>
        return entries.reduce((acc, [key, value]) => ({
            ...acc,
            [key]: value,
        }), {});
    }
    getInitialValue() {
        return new this.CollectionClass();
    }
    initialize(value, model, options) {
        if (!value)
            return new this.CollectionClass();
        value = foundry.utils.deepClone(value);
        const collection = new this.CollectionClass(Object.entries(value));
        Array.from(collection.entries()).forEach(([id, v]) => {
            collection.set(id, this.model.initialize(v, model, options));
        });
        return collection;
    }
    toObject(value) {
        const result = Array.from(value.entries()).reduce((acc, [id, v]) => ({
            ...acc,
            [id]: this.model.toObject(v),
        }), {});
        return result;
    }
    _getField(path) {
        if (path.length === 0)
            return this;
        else if (path.length === 1)
            return this.model;
        path.shift();
        return this.model._getField(path);
    }
    getItemKey(item) {
        return typeof this.options.key === 'function'
            ? this.options.key(item)
            : (item[this.options.key ?? 'id'] ??
                item._id ??
                undefined);
    }
}

// Fields
/**
 * Mixin for items to track relationships with other items.
 * For example, a talent will have a relationship with its path.
 */
function RelationshipsMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                return foundry.utils.mergeObject(super.defineSchema(), {
                    relationships: new CollectionField(new ItemRelationshipField(), {
                        required: true,
                    }),
                });
            }
        };
    };
}

function createRelationshipData(to, type, removalPolicy, id = foundry.utils.randomID()) {
    return {
        id,
        type,
        itemType: to.type,
        uuid: to.uuid,
        removalPolicy,
    };
}
function addRelationship(from, to, type, removalPolicy, source = false) {
    // Ensure the item is not already related
    if (from.isRelatedTo(to, type))
        return;
    return setRelationship(foundry.utils.randomID(), from, to, type, removalPolicy, source);
}
function addRelationshipData(itemData, to, type) {
    return setRelationshipData(foundry.utils.randomID(), itemData, to, type);
}
function setRelationship(id, from, to, type, removalPolicy, source = false) {
    // Ensure the item is not already related
    if (from.system.relationships.some((rel) => rel.id === id))
        return;
    const changes = setRelationshipData(id, {}, to, type, removalPolicy);
    if (!source) {
        return from.update(changes).then(void 0);
    }
    else {
        from.updateSource(changes);
    }
}
function setRelationshipData(id, itemData, to, type, removalPolicy) {
    const rel = createRelationshipData(to, type, removalPolicy, id);
    return foundry.utils.mergeObject(itemData, {
        [`system.relationships.${rel.id}`]: rel,
        ...(type === ItemRelationship.Type.Parent && to.hasId()
            ? {
                [`flags.${SYSTEM_ID}.meta.origin`]: {
                    type: to.type,
                    id: to.system.id,
                },
            }
            : {}),
    });
}
function removeRelationship(from, to, options = {}) {
    const relationship = from.system.relationships.find((rel) => (rel.type === options.relType || !options.relType) &&
        rel.uuid === to.uuid);
    if (relationship) {
        const changes = {
            [`system.relationships.-=${relationship.id}`]: {
                type: relationship.type,
            },
        };
        if (!options.source) {
            return from.update(changes).then(void 0);
        }
        else {
            from.updateSource(changes);
        }
    }
}
var ItemRelationshipUtils = {
    addRelationship,
    removeRelationship,
    setRelationship,
    createRelationshipData,
    addRelationshipData,
    setRelationshipData,
};

const { ApplicationV2: ApplicationV2$d } = foundry.applications.api;
class AttackConfigurationDialog extends ComponentHandlebarsApplicationMixin((ApplicationV2$d)) {
    data;
    resolve;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            resizable: false,
            positioned: true,
        },
        classes: ['dialog', 'roll-configuration'],
        tag: 'dialog',
        position: {
            width: 500,
        },
        actions: {
            submit: this.onSubmit,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ROLL_CONFIGURATION}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    submitted = false;
    originalFormulaSize = 0;
    constructor(data, resolve) {
        super({
            window: {
                title: data.title,
            },
        });
        this.data = data;
        this.resolve = resolve;
        this.data.skillTest.parts.unshift('1d20');
        this.originalFormulaSize = this.data.skillTest.parts.length;
        this.data.skillTest.advantageMode ??= AdvantageMode.None;
        this.data.plotDie.advantageMode ??= AdvantageMode.None;
        this.data.skillTest.formula = foundry.dice.Roll.replaceFormulaData(getFormulaDisplayString(this.data.skillTest.parts), this.data.skillTest.data, {
            missing: '0',
        });
        this.data.damageRoll.formula = foundry.dice.Roll.replaceFormulaData(getFormulaDisplayString(this.data.damageRoll.parts), this.data.damageRoll.data, {
            missing: '0',
        });
        this.data.damageRoll.dice ??= [];
        new foundry.dice.Roll(this.data.damageRoll.formula).dice.forEach((die, index) => {
            for (let i = 0; i < (die.number ?? 0); i++) {
                this.data.damageRoll.dice?.push({
                    poolIndex: index,
                    die: new foundry.dice.terms.Die({
                        number: 1,
                        faces: die.faces,
                    }),
                    advantageMode: AdvantageMode.None,
                });
            }
        });
    }
    /* --- Statics --- */
    static show(data) {
        return new Promise((resolve) => {
            void new this(data, resolve).render(true);
        });
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        const attribute = getNullableFromFormInput(formData.get('attribute'));
        const rollMode = formData.get('rollMode');
        const raiseStakes = formData.get('raiseStakes') === 'true';
        const tempMod = formData.get('temporaryMod')?.valueOf();
        // get rid of existing temp mod formula
        if (this.data.skillTest.parts.length > this.originalFormulaSize)
            this.data.skillTest.parts.pop();
        // add the current ones in for display in the formula bar
        this.data.skillTest.parts.push(tempMod);
        // store it
        this.data.temporaryModifiers = tempMod;
        const skill = this.data.skillTest.data.skill;
        const attributeData = attribute
            ? this.data.skillTest.data.attributes[attribute]
            : { value: 0, bonus: 0 };
        const rank = skill.rank;
        const value = attributeData.value + attributeData.bonus;
        this.data.skillTest.data.mod = rank + value;
        this.data.defaultAttribute = attribute ?? undefined;
        this.data.defaultRollMode = rollMode;
        this.data.raiseStakes = raiseStakes;
        void this.render();
    }
    /* --- Actions --- */
    static onSubmit() {
        const form = this.element.querySelector('form');
        this.resolve({
            attribute: getNullableFromFormInput(form.attribute.value),
            rollMode: form.rollMode?.value ?? 'roll',
            temporaryModifiers: form.temporaryMod.value,
            plotDie: form.raiseStakes.checked,
            advantageMode: this.data.skillTest.advantageMode ?? AdvantageMode.None,
            advantageModePlot: this.data.plotDie.advantageMode ?? AdvantageMode.None,
            advantageModeDamage: this.data.damageRoll.dice ?? [],
        });
        this.submitted = true;
        void this.close();
    }
    /* --- Event handlers --- */
    onClickConfigureDie(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.which !== 1 && event.which !== 3)
            return;
        const target = event.currentTarget;
        const action = target.dataset.action;
        const index = Number.parseInt(target.dataset.index);
        target.classList.remove(AdvantageMode.Advantage);
        target.classList.remove(AdvantageMode.Disadvantage);
        target.classList.remove(AdvantageMode.None);
        switch (action) {
            case 'skill-adv-mode':
                this.data.skillTest.advantageMode = toggleAdvantageMode(this.data.skillTest.advantageMode ?? AdvantageMode.None, event.which === 1);
                target.classList.add(this.data.skillTest.advantageMode);
                break;
            case 'plot-adv-mode':
                this.data.plotDie.advantageMode = toggleAdvantageMode(this.data.plotDie.advantageMode ?? AdvantageMode.None, event.which === 1);
                target.classList.add(this.data.plotDie.advantageMode);
                break;
            case 'damage-adv-mode':
                this.data.damageRoll.dice[index].advantageMode =
                    toggleAdvantageMode(this.data.damageRoll.dice[index].advantageMode ??
                        AdvantageMode.None, event.which === 1);
                target.classList.add(this.data.damageRoll.dice[index].advantageMode);
                break;
        }
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
        $(this.element)
            .find('.roll-config.test .dice-tooltip .dice-rolls .roll.die')
            .addClass(this.data.skillTest.advantageMode ?? AdvantageMode.None);
        $(this.element)
            .find('.roll-config.plot .dice-tooltip .dice-rolls .roll.die')
            .addClass(this.data.plotDie.advantageMode ?? AdvantageMode.None);
        this.data.damageRoll.dice.forEach((die, index) => {
            $(this.element)
                .find(`.roll-config.damage .dice-tooltip .dice-rolls .roll.die[data-index=${index}]`)
                .addClass(die.advantageMode ?? AdvantageMode.None);
        });
        $(this.element)
            .find('.dice-tooltip .dice-rolls .roll.die')
            .on('mousedown', this.onClickConfigureDie.bind(this));
    }
    _onClose() {
        if (!this.submitted)
            this.resolve(null);
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            rollModes: CONFIG.Dice.rollModes,
            defaultRollMode: this.data.defaultRollMode,
            attributes: {
                [NONE]: 'GENERIC.None',
                ...Object.entries(CONFIG.COSMERE.attributes).reduce((acc, [key, config]) => ({
                    ...acc,
                    [key]: config.label,
                }), {}),
            },
            defaultAttribute: this.data.defaultAttribute,
            temporaryModifiers: this.data.temporaryModifiers,
            skillTest: this.data.skillTest.formula
                ? {
                    formula: this.data.skillTest.formula,
                    dice: new foundry.dice.Roll(this.data.skillTest.formula)
                        .dice,
                }
                : undefined,
            plotDie: this.data.raiseStakes
                ? {
                    formula: '1dp',
                    dice: new foundry.dice.Roll('1dp').dice,
                }
                : undefined,
            damageRoll: this.data.damageRoll.formula
                ? {
                    formula: this.data.damageRoll.formula,
                    dice: this.data.damageRoll.dice?.map((die) => die.die),
                }
                : undefined,
        });
    }
}

// Constants
const TEMPLATE$2 = `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ITEM_CONSUME}`;
class ItemConsumeDialog extends foundry.applications.api.DialogV2 {
    item;
    resolve;
    constructor(item, resolve, content, title) {
        super({
            id: `${item.uuid}.consume`,
            window: {
                title: title ?? 'DIALOG.ItemConsume.Title',
            },
            position: {
                width: 350,
            },
            content,
            buttons: [
                {
                    label: 'GENERIC.Button.Continue',
                    action: 'continue',
                    // NOTE: Callback must be async
                    // eslint-disable-next-line @typescript-eslint/require-await
                    callback: async () => this.onContinue(),
                },
            ],
        });
        this.item = item;
        this.resolve = resolve;
    }
    /* --- Lifecycle --- */
    _onClose() {
        this.resolve(null);
    }
    /* --- Statics --- */
    static async show(item, options = []) {
        // Render dialog inner HTML
        const content = await renderTemplate(TEMPLATE$2, {
            resources: options.map((option, i) => {
                const resource = option.resource ?? game.i18n.localize('GENERIC.Unknown');
                let label = game.i18n.localize('DIALOG.ItemConsume.ShouldConsume.None');
                let isVariable = false;
                if (option.amount) {
                    // Static or optional consumption
                    if (option.amount.min === option.amount.max) {
                        label = game.i18n.format('DIALOG.ItemConsume.ShouldConsume.Static', {
                            amount: option.amount.min,
                            resource,
                        });
                    }
                    // Uncapped consumption
                    else if (option.amount.max === -1) {
                        label = game.i18n.format('DIALOG.ItemConsume.ShouldConsume.RangeUncapped', {
                            amount: option.amount.min,
                            resource,
                        });
                        isVariable = true;
                    }
                    // Capped consumption
                    else {
                        label = game.i18n.format('DIALOG.ItemConsume.ShouldConsume.RangeCapped', {
                            ...option.amount,
                            resource,
                        });
                        isVariable = true;
                    }
                }
                const resourceType = option.type ?? 'None';
                const resourceId = option.resourceId ?? 'None';
                const resourceAmount = option.amount
                    ? `${option.amount.min}-${option.amount.max === -1 ? 'INF' : option.amount.max}`
                    : '0-0';
                return {
                    id: `${resourceType}-${resourceId}-${resourceAmount}-${i}`,
                    label,
                    amount: isVariable ? option.amount : null,
                    shouldConsume: option.shouldConsume ?? false,
                };
            }),
        });
        // Render dialog and wrap as promise
        return new Promise((resolve) => {
            void new ItemConsumeDialog(item, resolve, content).render(true);
        });
    }
    /* --- Actions --- */
    onContinue() {
        const form = this.element.querySelector('form');
        try {
            // Collate all valid consumption options, accumulating value
            // for all options which share the exact same target for
            // consumption.
            const collated = [
                ...form.querySelectorAll('#consumables .form-group').values(),
            ]
                .map((elem) => {
                // Get inputs
                const amountInput = elem.querySelector(`#${elem.id}-amount`);
                const shouldConsumeInput = elem.querySelector(`#${elem.id}-shouldConsume`);
                // Only consume checked elements
                if (!(shouldConsumeInput instanceof HTMLInputElement) ||
                    !shouldConsumeInput.checked)
                    return null;
                // Only consume from valid amount inputs, when present
                if (!!amountInput &&
                    !(amountInput instanceof HTMLInputElement))
                    return null;
                // Get any additional information from the id
                // Only destructure the first 4; the last value is the index,
                // which only exists to assert uniqueness.
                const [consumeType, consumeFrom, consumeMin, consumeMax] = elem.id.split('-');
                const consumeData = {
                    ...(consumeType === "resource" /* ItemConsumeType.Resource */
                        ? {
                            resource: consumeFrom,
                        }
                        : {}),
                };
                const min = parseInt(consumeMin);
                const max = parseInt(consumeMax);
                const range = {
                    min: isNaN(min) ? 0 : min,
                    max: isNaN(max) ? -1 : max,
                    actual: 0,
                };
                // Pass actual consumption back to item
                if (range.min === range.max) {
                    range.actual = range.min;
                }
                else if (amountInput) {
                    range.actual = amountInput.valueAsNumber;
                    // Validate input with useful error notification
                    if (isNaN(range.actual)) {
                        throw new Error(`Invalid amount to consume: "${amountInput.value}"`);
                    }
                    else if (range.actual < range.min ||
                        (range.actual > range.max && range.max > -1)) {
                        let error = `Invalid amount "${range.actual}", must consume `;
                        if (range.max === -1) {
                            error += `at least ${range.min}`;
                        }
                        else {
                            error += `between ${range.min} and ${range.max}`;
                        }
                        throw new Error(error);
                    }
                }
                return {
                    type: consumeType,
                    value: range,
                    ...consumeData,
                };
            })
                .filter((elem) => !!elem)
                .reduce((acc, consumable) => {
                // Get specific key, including the consume type and the actual
                // value that's meant to be consumed.
                let key = consumable.type;
                switch (consumable.type) {
                    case "resource" /* ItemConsumeType.Resource */:
                        key += `.${consumable.resource}`;
                        break;
                }
                const existing = acc[key];
                if (!existing) {
                    acc[key] = { ...consumable };
                }
                else {
                    acc[key].value.actual += consumable.value.actual;
                }
                return acc;
            }, {});
            // Reconstruct list
            const consumption = Object.entries(collated).map(([_, v]) => v);
            console.log(consumption);
            // Resolve
            this.resolve({
                consumption,
            });
        }
        catch (error) {
            // Break free upon failed validation
            ui.notifications.warn(error.message);
        }
    }
}

class CosmereItem extends Item {
    /* --- ItemType type guards --- */
    isWeapon() {
        return this.type === "weapon" /* ItemType.Weapon */;
    }
    isArmor() {
        return this.type === "armor" /* ItemType.Armor */;
    }
    isAncestry() {
        return this.type === "ancestry" /* ItemType.Ancestry */;
    }
    isCulture() {
        return this.type === "culture" /* ItemType.Culture */;
    }
    isPath() {
        return this.type === "path" /* ItemType.Path */;
    }
    isSpecialty() {
        return this.type === "specialty" /* ItemType.Specialty */;
    }
    isTalent() {
        return this.type === "talent" /* ItemType.Talent */;
    }
    isConnection() {
        return this.type === "connection" /* ItemType.Connection */;
    }
    isInjury() {
        return this.type === "injury" /* ItemType.Injury */;
    }
    isAction() {
        return this.type === "action" /* ItemType.Action */;
    }
    isTrait() {
        return this.type === "trait" /* ItemType.Trait */;
    }
    isEquipment() {
        return this.type === "equipment" /* ItemType.Equipment */;
    }
    isGoal() {
        return this.type === "goal" /* ItemType.Goal */;
    }
    isPower() {
        return this.type === "power" /* ItemType.Power */;
    }
    isTalentTree() {
        return this.type === "talent_tree" /* ItemType.TalentTree */;
    }
    /* --- Mixin type guards --- */
    /**
     * Can this item be activated?
     */
    hasActivation() {
        return 'activation' in this.system;
    }
    /**
     * Does this item have an attack?
     */
    hasAttack() {
        return 'attack' in this.system;
    }
    /**
     * Does this item deal damage?
     */
    hasDamage() {
        return 'damage' in this.system;
    }
    /**
     * Is this item physical?
     */
    isPhysical() {
        return 'weight' in this.system && 'price' in this.system;
    }
    /**
     * Does this item have a sub-type?
     */
    isTyped() {
        return 'type' in this.system;
    }
    /**
     * Does this item have traits?
     * Not to be confused adversary traits. (Which are their own item type.)
     */
    hasTraits() {
        return 'traits' in this.system;
    }
    /**
     * Does this item have a deflect value?
     */
    hasDeflect() {
        return 'deflect' in this.system;
    }
    /**
     * Can this item be equipped?
     */
    isEquippable() {
        return 'equipped' in this.system;
    }
    /**
     * Does this item have a description?
     */
    hasDescription() {
        return 'description' in this.system;
    }
    /**
     * Does this item have an id in it system?
     */
    hasId() {
        return 'id' in this.system;
    }
    /**
     * Does this item have modality?
     */
    hasModality() {
        return 'modality' in this.system;
    }
    /**
     * Does this item provide talents?
     */
    isTalentsProvider() {
        return 'talentTree' in this.system;
    }
    /**
     * Does this item have events?
     */
    hasEvents() {
        return 'events' in this.system;
    }
    /**
     * Whether or not this item supports linked skills.
     */
    hasLinkedSkills() {
        return 'linkedSkills' in this.system;
    }
    /**
     * Whether or not this item can have relationships.
     */
    hasRelationships() {
        return 'relationships' in this.system;
    }
    /* --- Accessors --- */
    get isFavorite() {
        return this.getFlag(SYSTEM_ID, 'favorites.isFavorite') ?? false;
    }
    /**
     * Checks if the talent item mode is active.
     * Only relevant for talents that have a modality configured.
     */
    get isModeActive() {
        // Check if item is talent
        if (!this.isTalent())
            return false;
        // Check if item has modality
        if (!this.system.modality)
            return false;
        // Check actor
        if (!this.actor)
            return false;
        // Get modality id
        const modalityId = this.system.modality;
        // Check actor modality flag
        const activeMode = this.actor.getFlag(SYSTEM_ID, `mode.${modalityId}`);
        // Check if the actor has the mode active
        return activeMode === this.system.id;
    }
    get sheet() {
        return super.sheet;
    }
    /* --- Lifecycle --- */
    _onClickDocumentLink(event) {
        const target = event.currentTarget;
        return this.sheet?.render(true, { tab: target.dataset.tab });
    }
    _buildEmbedHTML(config, options) {
        const embedHelpers = getEmbedHelpers(this);
        return (embedHelpers.buildEmbedHTML?.(this, config, options) ??
            super._buildEmbedHTML(config, options));
    }
    _createInlineEmbed(content, config, options) {
        const embedHelpers = getEmbedHelpers(this);
        return (embedHelpers.createInlineEmbed?.(this, content, config, options) ??
            super._createInlineEmbed(content, config, options));
    }
    _createFigureEmbed(content, config, options) {
        const embedHelpers = getEmbedHelpers(this);
        return (embedHelpers.createFigureEmbed?.(this, content, config, options) ??
            super._createFigureEmbed(content, config, options));
    }
    /* --- Roll & Usage utilities --- */
    /**
     * Roll utility for activable items.
     * This function **only** performs the roll, it does not consume resources.
     * For item usages with resource consumtion use `item.use` instead.
     */
    async roll(options = {}) {
        if (!this.hasActivation())
            return null;
        // Get the actor to roll for (either assigned through option, the parent of this item, or the first controlled actor)
        const actor = options.actor ??
            this.actor ??
            game.canvas?.tokens?.controlled?.[0]?.actor;
        // Ensure an actor was found
        if (!actor) {
            ui.notifications.warn(game.i18n.localize('GENERIC.Warning.NoActor'));
            return null;
        }
        // Get skill to use
        const skillId = options.skill ?? this.system.activation.resolvedSkill;
        const skill = skillId
            ? actor.system.skills[skillId]
            : { attribute: null, rank: 0 };
        // Get the attribute id
        const attributeId = options.attribute ?? this.system.activation.resolvedAttribute;
        // Set up actor data
        const data = this.getSkillTestRollData(skillId ? skillId : null, attributeId, actor, options.isAttack);
        const parts = ['@mod'].concat(options.parts ?? []);
        if (options.temporaryModifiers)
            parts.push(options.temporaryModifiers);
        // Perform the roll
        const roll = await d20Roll(foundry.utils.mergeObject(options, {
            data,
            chatMessage: false,
            title: `${this.name} (${skillId
                ? game.i18n.localize(CONFIG.COSMERE.skills[skillId].label)
                : `${game.i18n.localize('GENERIC.Custom')} ${game.i18n.localize('GENERIC.Skill')}`})`,
            defaultAttribute: skill.attribute ? skill.attribute : undefined,
            parts: parts,
            plotDie: options.plotDie ?? this.system.activation.plotDie,
            opportunity: options.opportunity ?? this.system.activation.opportunity,
            complication: options.complication ?? this.system.activation.complication,
        }));
        if (roll && options.chatMessage !== false) {
            // Get the speaker
            const speaker = options.speaker ??
                ChatMessage.getSpeaker({ actor });
            // Create chat message
            await roll.toMessage({
                speaker,
            });
        }
        return roll;
    }
    /**
     * Utility for rolling damage.
     * Only works for items that have damage configured.
     */
    async rollDamage(options = {}) {
        if (!this.hasDamage() || !this.system.damage.formula)
            return null;
        // Get the actor to roll for (either assigned through option, the parent of this item, or the first controlled actor)
        const actor = options.actor ??
            this.actor ??
            game.canvas?.tokens?.controlled?.[0]?.actor;
        // Ensure an actor was found
        if (!actor) {
            ui.notifications.warn(game.i18n.localize('GENERIC.Warning.NoActor'));
            return null;
        }
        const activatable = this.hasActivation();
        // Get the skill id
        const skillId = options.skill ??
            (activatable ? this.system.activation.resolvedSkill : null);
        // Get the skill
        skillId ? actor.system.skills[skillId] : undefined;
        // Get the attribute id
        const attributeId = options.attribute ??
            (activatable ? this.system.activation.resolvedAttribute : null);
        // Set up data
        const rollData = this.getDamageRollData(skillId, attributeId, actor);
        const formula = options.overrideFormula ?? this.system.damage.formula;
        // Perform the roll
        const roll = await damageRoll(foundry.utils.mergeObject(options, {
            formula: rollData.mod !== undefined
                ? `${formula} + ${rollData.mod}`
                : formula,
            damageType: this.system.damage.type,
            mod: rollData.mod,
            data: rollData,
            source: this.name,
        }));
        // Gather the formula options for graze rolls
        const unmoddedRoll = roll.clone();
        const diceOnlyRoll = roll.clone();
        rollData.damage = {
            total: roll,
            unmodded: unmoddedRoll,
            dice: diceOnlyRoll,
        };
        unmoddedRoll.removeTermSafely((term) => term instanceof foundry.dice.terms.NumericTerm &&
            term.total === rollData.mod);
        diceOnlyRoll.filterTermsSafely((term) => term instanceof foundry.dice.terms.DiceTerm ||
            term instanceof foundry.dice.terms.OperatorTerm ||
            term instanceof foundry.dice.terms.PoolTerm);
        // Ensure there is at least one term in the unmodded roll
        if (unmoddedRoll.terms.length === 0) {
            unmoddedRoll.terms.push(new foundry.dice.terms.NumericTerm({ number: 0 }));
            unmoddedRoll.resetFormula();
        }
        // Ensure there is at least one term in the dice only roll
        if (diceOnlyRoll.terms.length === 0) {
            diceOnlyRoll.terms.push(new foundry.dice.terms.NumericTerm({ number: 0 }));
            diceOnlyRoll.resetFormula();
        }
        // Get the graze formula
        const grazeFormula = 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.system.damage.grazeOverrideFormula || '@damage.dice';
        const usesBaseDamage = grazeFormula.includes('@damage');
        const grazeRoll = await damageRoll(foundry.utils.mergeObject(options, {
            formula: grazeFormula,
            damageType: this.system.damage.type,
            data: rollData,
        }));
        // update with results from the basic roll if needed and store for display
        if (usesBaseDamage)
            grazeRoll.replaceDieResults(roll.dice);
        roll.graze = grazeRoll;
        if (roll && options.chatMessage !== false) {
            // Get the speaker
            const speaker = options.speaker ??
                ChatMessage.getSpeaker({ actor });
            // Create chat message
            await roll.toMessage({
                speaker,
            });
        }
        // Return the roll
        return [roll];
    }
    /**
     * Utility for rolling attacks with this item.
     * This function rolls both the skill test and the damage.
     */
    async rollAttack(options = {}) {
        if (!this.hasActivation())
            return null;
        if (!this.hasDamage() || !this.system.damage.formula)
            return null;
        // Get the actor to roll for (either assigned through option, the parent of this item, or the first controlled actor)
        const actor = options.actor ??
            this.actor ??
            game.canvas?.tokens?.controlled?.[0]?.actor;
        // Ensure an actor was found
        if (!actor) {
            ui.notifications.warn(game.i18n.localize('GENERIC.Warning.NoActor'));
            return null;
        }
        // Get the skill to use during the skill test
        const skillTestSkillId = options.skillTest?.skill ?? this.system.activation.resolvedSkill;
        // Get the skill to use during the damage roll
        const damageSkillId = options.damage?.skill ??
            this.system.damage.skill ??
            skillTestSkillId;
        // Get the attribute to use during the skill test
        let skillTestAttributeId = options.skillTest?.attribute ??
            this.system.activation.resolvedAttribute;
        // Get the attribute to use during the damage roll
        const damageAttributeId = options.damage?.attribute ??
            this.system.damage.attribute ??
            (damageSkillId
                ? actor.system.skills[damageSkillId].attribute
                : null);
        options.skillTest ??= {};
        options.skillTest.parts ??= this.system.activation.modifierFormula
            ? [this.system.activation.modifierFormula]
            : [];
        options.damage ??= {};
        // Handle key modifiers
        const { fastForward, advantageMode, plotDie } = determineConfigurationMode(options.configurable, options.skillTest.advantageMode
            ? options.skillTest.advantageMode ===
                AdvantageMode.Advantage
            : undefined, options.skillTest.advantageMode
            ? options.skillTest.advantageMode ===
                AdvantageMode.Disadvantage
            : undefined, options.skillTest.plotDie);
        // Replace config values with key modified values
        options.skillTest.advantageMode = advantageMode;
        options.skillTest.plotDie = plotDie;
        // Get damage formula
        const damageFormula = options.damage?.overrideFormula ?? this.system.damage.formula;
        // Perform configuration
        if (!fastForward && options.configurable !== false) {
            /**
             * Hook: preAttackRollConfiguration
             */
            if (Hooks.call(HOOKS.PRE_ATTACK_ROLL_CONFIGURATION, options, // Config
            this) === false)
                return null;
            const parts = ['@mod'].concat(options.skillTest?.parts ?? []);
            if (options.skillTest?.temporaryModifiers)
                parts.push(options.skillTest.temporaryModifiers);
            const attackConfig = await AttackConfigurationDialog.show({
                title: `${this.name} (${skillTestSkillId
                    ? game.i18n.localize(CONFIG.COSMERE.skills[skillTestSkillId].label)
                    : `${game.i18n.localize('GENERIC.Custom')} ${game.i18n.localize('GENERIC.Skill')}`})`,
                defaultAttribute: skillTestAttributeId,
                defaultRollMode: options.rollMode,
                raiseStakes: options.skillTest?.plotDie ??
                    this.system.activation.plotDie,
                skillTest: {
                    ...options.skillTest,
                    parts,
                    data: this.getSkillTestRollData(skillTestSkillId ?? null, skillTestAttributeId, actor, true),
                },
                damageRoll: {
                    ...options.damage,
                    parts: damageFormula.split(' + '),
                    data: this.getDamageRollData(skillTestSkillId, skillTestAttributeId, actor),
                    dice: [],
                },
                plotDie: {},
            });
            // If the dialog was closed, exit out of rolls
            if (!attackConfig)
                return null;
            options.skillTest.temporaryModifiers =
                attackConfig.temporaryModifiers;
            skillTestAttributeId = attackConfig.attribute;
            options.rollMode = attackConfig.rollMode;
            options.skillTest.plotDie = attackConfig.plotDie;
            options.skillTest.advantageMode = attackConfig.advantageMode;
            options.skillTest.advantageModePlot =
                attackConfig.advantageModePlot;
            if (attackConfig.advantageModeDamage.some((a) => (a.advantageMode ?? AdvantageMode.None) !==
                AdvantageMode.None)) {
                const pools = {};
                for (const mode of attackConfig.advantageModeDamage) {
                    pools[mode.poolIndex] ??= [];
                    const state = mode.advantageMode ?? AdvantageMode.None;
                    pools[mode.poolIndex].push(`${state !== AdvantageMode.None ? 2 : 1}${mode.die.denomination}${state === AdvantageMode.Advantage ? 'kh' : state === AdvantageMode.Disadvantage ? 'kl' : ''}`);
                }
                const parts = [];
                for (const pool of Object.values(pools)) {
                    parts.push(pool.length > 1 ? `{${pool.join(',')}}` : pool[0]);
                }
                options.damage.overrideFormula = parts.join(' + ');
            }
            /**
             * Hook: attackRollConfiguration
             */
            Hooks.callAll(HOOKS.ATTACK_ROLL_CONFIGURATION, options, // Config
            this);
        }
        // Roll the skill test
        const skillRoll = (await this.roll({
            ...options.skillTest,
            actor,
            skill: skillTestSkillId,
            attribute: skillTestAttributeId,
            rollMode: options.rollMode,
            speaker: options.speaker,
            configurable: false,
            chatMessage: false,
            isAttack: true,
        }));
        // Roll the damage
        const damageRolls = (await this.rollDamage({
            ...options.damage,
            actor,
            skill: damageSkillId,
            attribute: damageAttributeId,
            rollMode: options.rollMode,
            speaker: options.speaker,
            chatMessage: false,
        }));
        if (options.chatMessage !== false) {
            // Get the speaker
            const speaker = options.speaker ??
                ChatMessage.getSpeaker({ actor });
            const flavor = game
                .i18n.localize('COSMERE.Item.AttackFlavor')
                .replace('[actor]', actor.name)
                .replace('[item]', this.name);
            // Create chat message
            (await ChatMessage.create({
                user: game.user.id,
                speaker,
                content: `<p>${flavor}</p>`,
                rolls: [skillRoll, ...damageRolls],
            }));
        }
        // Return the rolls
        return [skillRoll, damageRolls ?? []];
    }
    /**
     * Utility for using activatable items.
     * This function handles resource validation/consumption and dice rolling.
     */
    async use(options = {}) {
        if (!this.hasActivation())
            return null;
        // Set up post roll actions
        const postRoll = [];
        // Get the actor to use this item for
        const actor = options.actor ??
            this.actor ??
            game.canvas?.tokens?.controlled?.[0]?.actor;
        // Ensure an actor was found
        if (!actor) {
            ui.notifications.warn(game.i18n.localize('GENERIC.Warning.NoActor'));
            return null;
        }
        const { fastForward, advantageMode, plotDie } = determineConfigurationMode(options);
        // Hook: preItemUse
        if (Hooks.call(HOOKS.PRE_USE_ITEM, this, // Source
        {
            ...options,
            configurable: !fastForward,
            advantageMode,
            plotDie,
        }) === false)
            return null;
        // Determine whether or not resource consumption is available
        const consumptionAvailable = options.shouldConsume !== false &&
            !!this.system.activation.consume &&
            this.system.activation.consume.length > 0;
        // Determine if we should handle resource consumption
        let consumeResponse = null;
        if (consumptionAvailable && !options.shouldConsume) {
            consumeResponse = await this.showConsumeDialog();
            // If the dialog was closed, exit out of use action
            if (consumeResponse === null)
                return null;
        }
        // Handle resource consumption
        if (!!consumeResponse && consumeResponse.length > 0) {
            // Process each included resource consumption
            for (const consumption of consumeResponse) {
                // Get the current amount
                let currentAmount;
                switch (consumption.type) {
                    case "resource" /* ItemConsumeType.Resource */:
                        currentAmount =
                            actor.system.resources[consumption.resource].value;
                        break;
                    // case ItemConsumeType.Item:
                    // TODO
                    default:
                        currentAmount = 0;
                }
                // Validate that there's enough resource to consume
                const newAmount = currentAmount - consumption.value.actual;
                if (newAmount < 0) {
                    ui.notifications.warn(game.i18n.localize('GENERIC.Warning.NotEnoughResource'));
                    return null;
                }
                // Add post roll action to consume the resource
                postRoll.push(() => {
                    if (consumption.type === "resource" /* ItemConsumeType.Resource */) {
                        // Handle actor resource consumption
                        void actor.update({
                            system: {
                                resources: {
                                    [consumption.resource]: {
                                        value: newAmount,
                                    },
                                },
                            },
                        });
                    }
                    else if (consumption.type === "item" /* ItemConsumeType.Item */) {
                        // Handle item consumption
                        // TODO: Figure out how to handle item consumption
                        ui.notifications.warn(game
                            .i18n.localize('GENERIC.Warning.NotImplemented')
                            .replace('[action]', 'Item consumption'));
                    }
                });
            }
        }
        // Handle item uses
        if (this.system.activation.uses) {
            // Get the current uses
            const currentUses = this.system.activation.uses.value;
            // Validate we can use the item
            if (currentUses < 1) {
                ui.notifications.warn(game.i18n.localize('GENERIC.Warning.NotEnoughUses'));
                return null;
            }
            // Add post roll action to consume a use
            postRoll.push(() => {
                // Handle use consumption
                void this.update({
                    'system.activation.uses.value': currentUses - 1,
                });
            });
        }
        // Handle talent mode activation
        if (this.hasId() &&
            this.hasModality() &&
            this.system.modality &&
            !!this.actor) {
            // Add post roll action to activate the mode
            postRoll.push(() => {
                // Handle mode activation
                void this.actor?.setMode(this.system.modality, this.system.id);
            });
        }
        // Check if the item has an attack
        const hasAttack = this.hasAttack();
        // Check if the item has damage
        const hasDamage = this.hasDamage() && this.system.damage.formula;
        // Check if a roll is required
        const rollRequired = this.system.activation.type === "skill_test" /* ActivationType.SkillTest */ ||
            hasDamage;
        const messageConfig = {
            user: game.user.id,
            speaker: options.speaker ??
                ChatMessage.getSpeaker({ actor }),
            rolls: [],
            flags: {},
        };
        messageConfig.flags[SYSTEM_ID] = {
            message: {
                type: MESSAGE_TYPES.ACTION,
                description: await this.getDescriptionHTML(),
                targets: getTargetDescriptors(),
                item: this.id,
            },
        };
        // Add hook call to post roll actions
        postRoll.push(() => {
            /**
             * Hook: useItem
             */
            Hooks.callAll(HOOKS.USE_ITEM, this, // Source
            {
                ...options,
                configurable: !fastForward,
                advantageMode,
                plotDie,
            });
        });
        if (rollRequired) {
            const rolls = [];
            let flavor = this.system.activation.flavor;
            if (hasAttack && hasDamage) {
                const attackResult = await this.rollAttack({
                    ...options,
                    actor,
                    skillTest: {
                        parts: options.parts,
                        plotDie: options.plotDie,
                        advantageMode: options.advantageMode,
                        advantageModePlot: options.advantageModePlot,
                        opportunity: options.opportunity,
                        complication: options.complication,
                        temporaryModifiers: options.temporaryModifiers,
                    },
                    damage: options.damage ?? {},
                    chatMessage: false,
                });
                if (!attackResult)
                    return null;
                // Add the rolls to the list
                rolls.push(attackResult[0], ...attackResult[1]);
                // Set the flavor
                flavor = flavor
                    ? flavor
                    : `${game.i18n.localize(`COSMERE.Skill.${attackResult[0].data.skill.id}`)} (${game.i18n.localize(`COSMERE.Attribute.${attackResult[0].data.skill.attribute}`)})`;
            }
            else {
                if (hasDamage) {
                    const damageRolls = await this.rollDamage({
                        ...options,
                        ...options.damage,
                        actor,
                        chatMessage: false,
                    });
                    if (!damageRolls)
                        return null;
                    rolls.push(...damageRolls);
                }
                options.parts ??= this.system.activation.modifierFormula
                    ? [this.system.activation.modifierFormula]
                    : [];
                if (this.system.activation.type === "skill_test" /* ActivationType.SkillTest */) {
                    const roll = await this.roll({
                        ...options,
                        actor,
                        chatMessage: false,
                    });
                    if (!roll)
                        return null;
                    // Add the roll to the list
                    rolls.push(roll);
                    // Set the flavor
                    flavor = flavor
                        ? flavor
                        : `${game.i18n.localize(`COSMERE.Skill.${roll.data.skill.id}`)} (${game.i18n.localize(`COSMERE.Attribute.${roll.data.skill.attribute}`)})`;
                }
            }
            messageConfig.rolls = rolls;
            // Create chat message
            await ChatMessage.create(messageConfig);
            // Perform post roll actions
            postRoll.forEach((action) => action());
            // Return the result
            return hasDamage
                ? rolls
                : rolls[0];
        }
        else {
            // NOTE: Use boolean or operator (`||`) here instead of nullish coalescing (`??`),
            // as flavor can also be an empty string, which we'd like to replace with the default flavor too
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            this.system.activation.flavor || undefined;
            // Create chat message
            const message = (await ChatMessage.create(messageConfig));
            message.applyRollMode('roll');
            // Perform post roll actions
            postRoll.forEach((action) => action());
            return null;
        }
    }
    async showConsumeDialog(options = {}) {
        if (!this.hasActivation())
            return null;
        if (!this.system.activation.consume)
            return null;
        const consumeOptions = this.system.activation.consume.map((consumptionData, i) => {
            const consumeType = options.consumeType ?? consumptionData.type;
            // Only automatically check first option, or anything overridden.
            const shouldConsume = options.shouldConsume ?? i === 0;
            const amount = consumptionData.value;
            const label = consumeType === "resource" /* ItemConsumeType.Resource */
                ? game.i18n.localize(CONFIG.COSMERE.resources[consumptionData.resource].label)
                : consumeType === "item" /* ItemConsumeType.Item */
                    ? '[TODO ITEM]'
                    : game.i18n.localize('GENERIC.Unknown');
            return {
                type: consumeType,
                resource: label,
                resourceId: consumptionData.resource ?? 'unknown',
                amount,
                shouldConsume,
            };
        });
        // Show the dialog if required
        const result = await ItemConsumeDialog.show(this, consumeOptions);
        return result?.consumption ?? null;
    }
    /* --- Functions --- */
    async recharge() {
        if (!this.hasActivation() || !this.system.activation.uses)
            return;
        // Recharge resource
        await this.update({
            'system.activation.uses.value': this.system.activation.uses.max,
        });
    }
    isRelatedTo(item, relType) {
        if (!this.hasRelationships() || !item.hasRelationships())
            return false;
        // Get the relationships of this item
        const relationships = this.system.relationships.filter((r) => r.type === relType || !relType);
        // Check if the item is related to this item
        return relationships.some((rel) => rel.uuid === item.uuid);
    }
    hasRelationshipOfType(type) {
        if (!this.hasRelationships())
            return false;
        return this.system.relationships.some((relationship) => relationship.type === type);
    }
    addRelationship(item, type, removalPolicy, source = false) {
        if (!this.hasRelationships() || !item.hasRelationships())
            return;
        return ItemRelationshipUtils.addRelationship(this, item, type, removalPolicy, source);
    }
    removeRelationship(item, options) {
        if (!this.hasRelationships() || !item.hasRelationships())
            return;
        return ItemRelationshipUtils.removeRelationship(this, item, options);
    }
    async markFavorite(index, render = true) {
        await this.update({
            flags: {
                [SYSTEM_ID]: {
                    favorites: {
                        isFavorite: true,
                        sort: index,
                    },
                },
            },
        }, { render });
    }
    async clearFavorite() {
        await Promise.all([
            this.unsetFlag(SYSTEM_ID, 'favorites.isFavorite'),
            this.unsetFlag(SYSTEM_ID, 'favorites.sort'),
        ]);
    }
    /* --- Helpers --- */
    async getDescriptionHTML() {
        if (!this.hasDescription())
            return undefined;
        // NOTE: We use logical OR's here to catch both nullish values and empty string
        /* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
        const descriptionData = this.system.description
            ?.chat ||
            this.system.description
                ?.short ||
            this.system.description
                ?.value;
        /* eslint-enable @typescript-eslint/prefer-nullish-coalescing */
        const description = await TextEditor.enrichHTML(descriptionData ?? '', {
            relativeTo: this.system.parent,
        });
        const traitsNormal = [];
        const traitsExpert = [];
        const traits = [];
        if (this.hasTraits()) {
            for (const [key, value] of Object.entries(this.system.traits)) {
                if (!value?.active)
                    continue;
                const traitLoc = CONFIG.COSMERE.traits.weaponTraits[key] ??
                    CONFIG.COSMERE.traits.armorTraits[key];
                let label = game.i18n.localize(traitLoc.label);
                if (value.expertise?.toggleActive) {
                    label = `<strong>${label}</strong>`;
                    traitsExpert.push(label);
                }
                else {
                    traitsNormal.push(label);
                }
            }
            traits.push(...traitsNormal.sort(), ...traitsExpert.sort());
        }
        let action;
        if (this.hasActivation() &&
            this.system.activation.cost.value !== undefined) {
            switch (this.system.activation.cost.type) {
                case "act" /* ActionCostType.Action */:
                    action = `action${Math.min(3, this.system.activation.cost.value)}`;
                    break;
                case "rea" /* ActionCostType.Reaction */:
                    action = 'reaction';
                    break;
                case "spe" /* ActionCostType.Special */:
                    action = 'special';
                    break;
                case "fre" /* ActionCostType.FreeAction */:
                    action = 'free';
                    break;
                default:
                    action = 'passive';
                    break;
            }
        }
        const sectionHTML = await renderSystemTemplate(TEMPLATES.CHAT_CARD_DESCRIPTION, {
            title: this.name,
            img: this.img,
            description,
            traits: traits.join(', '),
            action,
        });
        return sectionHTML;
    }
    getSkillTestRollData(skillId, attributeId, actor, isAttack) {
        const skill = skillId
            ? actor.system.skills[skillId]
            : { attribute: null, rank: 0, mod: 0 };
        const attribute = attributeId
            ? actor.system.attributes[attributeId]
            : { value: 0, bonus: 0 };
        const mod = skill.rank + attribute.value + attribute.bonus;
        return {
            ...actor.getRollData(),
            mod,
            skill: {
                id: skillId ?? null,
                rank: skill.rank,
                mod: typeof skill.mod === 'number' ? skill.mod : skill.mod.value,
                attribute: attributeId ? attributeId : skill.attribute,
            },
            attribute: attribute.value,
            // Hook data
            context: isAttack ? 'Attack' : 'Item',
            source: this,
        };
    }
    getDamageRollData(skillId, attributeId, actor) {
        const skill = skillId ? actor.system.skills[skillId] : undefined;
        const attribute = attributeId
            ? attributeId
                ? actor.system.attributes[attributeId]
                : { value: 0, bonus: 0 }
            : undefined;
        const mod = skill !== undefined || attribute !== undefined
            ? (skill?.rank ?? 0) +
                (attribute?.value ?? 0) +
                (attribute?.bonus ?? 0)
            : undefined;
        return {
            ...actor.getRollData(),
            mod,
            skill: skill
                ? {
                    id: skillId,
                    rank: skill.rank,
                    mod: skill.mod.value,
                    attribute: attributeId ? attributeId : skill.attribute,
                }
                : undefined,
            attribute: attribute?.value,
            // Hook data
            source: this,
        };
    }
    getRollData() {
        return foundry.utils.mergeObject(super.getRollData(), {
            actor: this.actor?.getRollData(),
        });
    }
    getEnricherData() {
        let actor = undefined;
        if (this.actor) {
            actor = this.actor.getRollData();
        }
        const targets = getTargetDescriptors();
        return {
            actor,
            item: {
                name: this.name,
                charges: this.hasActivation()
                    ? {
                        value: this.system.activation.uses?.value ?? 0,
                        max: this.system.activation.uses?.max ?? 0,
                    }
                    : undefined,
            },
            target: targets.length > 0 ? targets[0] : undefined,
        };
    }
}

// Constants
const TEMPLATE$1 = `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_CHARACTER_SHORT_REST}`;
class ShortRestDialog extends foundry.applications.api.DialogV2 {
    actor;
    resolve;
    constructor(actor, resolve, content) {
        super({
            id: `${actor.uuid}.rest`,
            window: {
                title: 'COSMERE.Actor.Sheet.ShortRest',
            },
            content,
            buttons: [
                {
                    label: 'GENERIC.Button.Continue',
                    action: 'continue',
                    // NOTE: Callback must be async
                    // eslint-disable-next-line @typescript-eslint/require-await
                    callback: async () => this.onContinue(),
                },
                {
                    label: 'GENERIC.Button.Cancel',
                    action: 'cancel',
                    // eslint-disable-next-line @typescript-eslint/require-await
                    callback: async () => resolve({ performRest: false }),
                },
            ],
        });
        this.actor = actor;
        this.resolve = resolve;
    }
    /* --- Lifecycle --- */
    _onClose() {
        this.resolve(null);
    }
    /* --- Statics --- */
    static async show(actor, options = {}) {
        // Get all player characters (except for the resting character)
        const playerCharacters = game.users
            .map((user) => user.character)
            .filter((character) => character &&
            character instanceof CosmereActor &&
            character.isCharacter())
            .filter((character) => character.id !== actor.id);
        // Render dialog inner HTML
        const content = await renderTemplate(TEMPLATE$1, {
            characters: {
                none: game.i18n.localize('GENERIC.None'),
                ...playerCharacters.reduce((acc, character) => ({
                    ...acc,
                    [character.id]: character.name,
                }), {}),
            },
            tendedBy: options.tendedBy?.id ?? 'none',
            formula: actor.system.recovery.die.value,
        });
        // Render dialog and wrap as promise
        return new Promise((resolve) => {
            void new ShortRestDialog(actor, resolve, content).render(true);
        });
    }
    /* --- Actions --- */
    onContinue() {
        const form = this.element.querySelector('form');
        // Get tended by
        const tendedById = form.tendedBy.value;
        const tendedBy = tendedById !== 'none'
            ? CosmereActor.get(tendedById)
            : undefined;
        // Resolve
        this.resolve({
            performRest: true,
            tendedBy,
        });
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        // Event handler for tended by selection
        $(this.element)
            .find('select[name="tendedBy"]')
            .on('change', (event) => {
            // Get tended by
            const tendedBy = $(event.target).val();
            if (tendedBy === 'none') {
                // Set formula
                $(this.element)
                    .find('input[name="formula"]')
                    .val(this.actor.system.recovery.die.value ?? '');
            }
            else {
                // Get the character
                const character = CosmereActor.get(tendedBy);
                // Get the medicine modifier
                const mod = character.system.skills.med.mod.value ?? 0;
                // Set formula
                $(this.element)
                    .find('input[name="formula"]')
                    .val(`${this.actor.system.recovery.die.value} + ${mod}`);
            }
        });
    }
}

/**
 * Utility function to add a node to the talent tree.
 */
function addNode(node, tree, operation) {
    return tree.update({
        [`system.nodes.${node.id}`]: node,
    }, operation);
}
/**
 * Utility function to remove a node from the talent tree.
 * Automatically manages connections to other nodes.
 */
async function removeNode(node, tree, operation) {
    // Get all connections TO the removed node (if relevant)
    const connections = tree.system.nodes
        .filter((n) => n.type === "talent" /* TalentTree.Node.Type.Talent */)
        .filter((n) => n.connections.some((c) => c.id === node.id))
        .map((n) => n.id);
    // Remove connections
    for (const connection of connections) {
        await removeConnection(connection, node.id, tree, operation);
    }
    return tree.update({
        [`system.nodes.-=${node.id}`]: null,
    }, operation);
}
function addConnection(fromId, toId, tree, operation) {
    // Get the nodes
    const from = tree.system.nodes.find((node) => node.id === fromId);
    const to = tree.system.nodes.find((node) => node.id === toId);
    if (!from || from.type !== "talent" /* TalentTree.Node.Type.Talent */)
        throw new Error(`Failed to add connection: Invalid from node ${fromId}`);
    if (!to || to.type !== "talent" /* TalentTree.Node.Type.Talent */)
        throw new Error(`Failed to add connection: Invalid to node ${toId}`);
    // Ensure there isn't already a connection
    if (from.connections.some((connection) => connection.id === to.id))
        return tree;
    const nodeChanges = {};
    // Find a managed talent prerequisite
    let talentPrereq = from.prerequisites.find((prereq) => prereq.type === "talent" /* TalentTree.Node.Prerequisite.Type.Talent */ &&
        prereq.managed);
    if (!talentPrereq) {
        // Generate id
        const id = foundry.utils.randomID();
        // Add item changes
        nodeChanges[`prerequisites.${id}`] = {
            id,
            type: "talent" /* TalentTree.Node.Prerequisite.Type.Talent */,
            managed: true,
            talents: {
                [to.talentId]: {
                    uuid: to.uuid,
                    id: to.talentId,
                    label: fromUuidSync(to.uuid)
                        .name,
                },
            },
        };
        // Set talentPrereq
        talentPrereq = nodeChanges[`prerequisites.${id}`];
    }
    else {
        // Add item changes
        nodeChanges[`prerequisites.${talentPrereq.id}.talents.${to.talentId}`] =
            {
                uuid: to.uuid,
                id: to.talentId,
                label: fromUuidSync(to.uuid)
                    .name,
            };
    }
    // Add connection
    nodeChanges[`connections.${to.id}`] = {
        id: to.id,
        prerequisiteId: talentPrereq.id,
    };
    // Update the tree
    return tree.update({
        [`system.nodes.${from.id}`]: nodeChanges,
    }, operation);
}
function removeConnection(fromId, toId, tree, operation) {
    // Get the nodes
    const from = tree.system.nodes.find((node) => node.id === fromId);
    const to = tree.system.nodes.find((node) => node.id === toId);
    if (!from || from.type !== "talent" /* TalentTree.Node.Type.Talent */)
        throw new Error(`Failed to remove connection: Invalid from node ${fromId}`);
    if (!to || to.type !== "talent" /* TalentTree.Node.Type.Talent */)
        throw new Error(`Failed to remove connection: Invalid to node ${toId}`);
    // Get the connection
    const connection = from.connections.get(to.id);
    if (!connection)
        return;
    // Get the prereq
    const prereq = from.prerequisites.get(connection.prerequisiteId);
    // Prepare node changes
    const nodeChanges = prereq
        ? Array.from(prereq.talents).length === 1
            ? { [`prerequisites.-=${prereq.id}`]: {} }
            : {
                [`prerequisites.${prereq.id}.talents`]: prereq.talents.filter((talent) => talent.id !== to.talentId),
            }
        : {};
    // Remove the connection
    nodeChanges[`connections.-=${to.id}`] = {};
    // Update the tree
    return tree.update({
        [`system.nodes.${from.id}`]: nodeChanges,
    }, operation);
}
/**
 * Utility function to remove a prerequisite from a node.
 * Automatically manages connections to other nodes.
 */
function removePrerequisite(node, prereqId, tree, operation) {
    // Get the prerequisite
    const prereq = node.prerequisites.get(prereqId);
    if (!prereq)
        throw new Error(`Failed to remove prerequisite: No prerequisite found with id ${prereqId}`);
    // Find all connections that depend on this prerequisite
    const connections = node.connections
        .filter((connection) => connection.prerequisiteId === prereqId)
        .map((connection) => connection.id);
    // Update the tree
    return tree.update({
        [`system.nodes.${node.id}`]: {
            [`prerequisites.-=${prereqId}`]: {},
            ...connections.reduce((acc, id) => ({
                ...acc,
                [`connections.-=${id}`]: {},
            }), {}),
        },
    }, operation);
}
function characterMeetsTalentPrerequisites(actor, prerequisites, tree) {
    return Array.from(prerequisites).every((prereq) => characterMeetsPrerequisiteRule(actor, prereq, tree));
}
function characterMeetsPrerequisiteRule(actor, prereq, tree) {
    switch (prereq.type) {
        case "talent" /* TalentTree.Node.Prerequisite.Type.Talent */:
            return Array.from(prereq.talents).some((ref) => {
                // Find talent
                const refTalent = actor.talents.find((t) => t.system.id === ref.id);
                if (!refTalent)
                    return false;
                // Find the talent in the tree
                const refTalentNode = tree?.system.nodes.find((node) => node.type === "talent" /* TalentTree.Node.Type.Talent */ &&
                    node.talentId === ref.id);
                if (!refTalentNode)
                    return true; // Can't check upstream prerequisites, so assume it's met
                // Check upstream prerequisites
                return characterMeetsTalentPrerequisites(actor, refTalentNode.prerequisites, tree);
            });
        case "attribute" /* TalentTree.Node.Prerequisite.Type.Attribute */:
            return (actor.system.attributes[prereq.attribute].value >= prereq.value);
        case "skill" /* TalentTree.Node.Prerequisite.Type.Skill */:
            return actor.system.skills[prereq.skill].rank >= prereq.rank;
        case "level" /* TalentTree.Node.Prerequisite.Type.Level */:
            return actor.system.level >= prereq.level;
        case "ancestry" /* TalentTree.Node.Prerequisite.Type.Ancestry */:
            return actor.ancestry?.system.id === prereq.ancestry.id;
        case "culture" /* TalentTree.Node.Prerequisite.Type.Culture */:
            return actor.cultures.some((culture) => culture.system.id === prereq.culture.id);
        case "goal" /* TalentTree.Node.Prerequisite.Type.Goal */:
            return Array.from(prereq.goals).some((ref) => actor.hasCompletedGoal(ref.id));
        case "connection" /* TalentTree.Node.Prerequisite.Type.Connection */:
            return true; // No way to check connections
        default:
            return false;
    }
}
/**
 * Is the talent with the given id currently obtained and
 * required as a prerequisite for any other obtained talent?
 */
async function isTalentRequiredAsPrerequisite(actor, talentId, tree) {
    if (!actor.hasTalent(talentId))
        return false;
    // Find any talent nodes that have this talent as a prerequisite
    const dependentNodes = tree.system.nodes.filter((node) => node.type === "talent" /* TalentTree.Node.Type.Talent */ &&
        node.prerequisites.some((prereq) => prereq.type === "talent" /* TalentTree.Node.Prerequisite.Type.Talent */ &&
            prereq.talents.some((t) => t.id === talentId)));
    // Check if any of these nodes are obtained
    const hasDependency = dependentNodes.some((node) => actor.hasTalent(node.talentId));
    if (hasDependency)
        return true;
    // Get all nested talent tree nodes
    const nestedTreeNodes = tree.system.nodes.filter((node) => node.type === "tree" /* TalentTree.Node.Type.Tree */);
    // Resolve all nested talent trees
    const nestedTrees = (await Promise.all(nestedTreeNodes.map((node) => fromUuid(node.uuid)))).filter((tree) => !!tree);
    // Check if any nested trees have the talent as a prerequisite
    for (const nestedTree of nestedTrees) {
        if (await isTalentRequiredAsPrerequisite(actor, talentId, nestedTree)) {
            console.log('Talent is required in nested tree:', nestedTree.id);
            return true;
        }
    }
    // If we reach here, the talent is not required as a prerequisite for any other obtained talent
    return false;
}
/**
 * Get all talents from a talent tree.
 * @param tree The talent tree to get talents from.
 * @param includeNested Whether to include talents from nested trees. Defaults to `true`.
 */
async function getTalents(tree, includeNested = true) {
    // Get all talents from the nodes
    const talents = (await Promise.all(tree.system.nodes
        .filter((node) => node.type === "talent" /* TalentTree.Node.Type.Talent */)
        .map(async (node) => {
        const talent = (await fromUuid(node.uuid));
        if (!talent?.isTalent())
            return null;
        return talent;
    }))).filter((v) => !!v);
    // If includeNested is true, get talents from nested trees
    if (includeNested) {
        const nestedTalents = await Promise.all(tree.system.nodes
            .filter((node) => node.type === "tree" /* TalentTree.Node.Type.Tree */)
            .map(async (node) => {
            const tree = (await fromUuid(node.uuid));
            if (!tree?.isTalentTree())
                return [];
            return getTalents(tree, true);
        }));
        return talents.concat(...nestedTalents);
    }
    return talents;
}

// NOTE: Specifically use a namespace here to merge with interface declaration
var Derived;
(function (Derived) {
    let Mode;
    (function (Mode) {
        Mode["Derived"] = "derived";
        Mode["Override"] = "override";
    })(Mode = Derived.Mode || (Derived.Mode = {}));
    Derived.Modes = {
        [Mode.Derived]: 'GENERIC.DerivedValue.Mode.Derived',
        [Mode.Override]: 'GENERIC.DerivedValue.Mode.Override',
    };
})(Derived || (Derived = {}));
class DerivedValueField extends foundry.data.fields.SchemaField {
    constructor(element, options, context) {
        // Update element options
        element.options.required = true;
        super({
            ...options?.additionalFields,
            derived: element,
            override: new (Object.getPrototypeOf(element)
                .constructor)({
                ...element.options,
                initial: null,
                required: false,
                nullable: true,
            }),
            useOverride: new foundry.data.fields.BooleanField({
                required: true,
                nullable: false,
                initial: false,
            }),
            ...(element instanceof foundry.data.fields.NumberField
                ? {
                    bonus: new foundry.data.fields.NumberField({
                        required: true,
                        nullable: false,
                        initial: 0,
                    }),
                }
                : {}),
        }, options, context);
    }
    initialize(value, model, options) {
        value = super.initialize(value, model, options);
        if (!Object.hasOwn(value, 'value')) {
            Object.defineProperties(value, {
                value: {
                    get: function () {
                        if ('bonus' in this) {
                            return this.base + this.bonus;
                        }
                        else {
                            return this.useOverride
                                ? this.override
                                : this.derived;
                        }
                    },
                },
                base: {
                    get: function () {
                        return this.useOverride ? this.override : this.derived;
                    },
                },
                mode: {
                    get: function () {
                        return this.useOverride
                            ? Derived.Mode.Override
                            : Derived.Mode.Derived;
                    },
                    set: function (mode) {
                        this.useOverride = mode === Derived.Mode.Override;
                    },
                },
            });
        }
        return value;
    }
}

class ExpertisesField extends CollectionField {
    constructor(options) {
        super(new ExpertiseDataField({
            label: 'EXPERTISE',
        }), {
            ...options,
            key: (item) => Expertise.getKey(item),
        });
    }
}
class ExpertiseDataField extends foundry.data.fields.SchemaField {
    constructor(options, context) {
        super(Expertise.defineSchema(), options, context);
    }
    _cast(value) {
        return typeof value === 'object' ? value : {};
    }
    initialize(value, model, options) {
        return new Expertise(foundry.utils.deepClone(value), {
            parent: model,
            ...options,
        });
    }
}
class Expertise extends foundry.abstract.DataModel {
    static defineSchema() {
        return {
            id: new foundry.data.fields.StringField({
                required: true,
                nullable: false,
                blank: false,
            }),
            type: new foundry.data.fields.StringField({
                required: true,
                nullable: false,
                blank: false,
                initial: Object.keys(CONFIG.COSMERE.expertiseTypes)[0],
                choices: Object.entries(CONFIG.COSMERE.expertiseTypes)
                    .map(([typeId, config]) => [typeId, config.label])
                    .reduce((acc, [key, value]) => ({
                    ...acc,
                    [key]: value,
                }), {}),
            }),
            label: new foundry.data.fields.StringField({
                required: false,
                nullable: true,
                blank: false,
            }),
            locked: new foundry.data.fields.BooleanField(),
        };
    }
    static getKey(expertise) {
        if (!expertise.id || !expertise.type)
            return null;
        return `${expertise.type}:${expertise.id}`;
    }
    /* --- Accessors --- */
    get key() {
        return Expertise.getKey(this);
    }
    get isCustom() {
        // Get the registry key
        const registryKey = CONFIG.COSMERE.expertiseTypes[this.type].configRegistryKey;
        if (!registryKey)
            return true;
        // Check if the expertise is registered in the config, a custom expertise is not registered
        return !foundry.utils.hasProperty(foundry.utils.getProperty(CONFIG.COSMERE, registryKey), this.id);
    }
    get typeLabel() {
        return CONFIG.COSMERE.expertiseTypes[this.type].label;
    }
    /* --- Lifecycle --- */
    _initialize(options) {
        super._initialize(options);
        // Override the label field
        Object.defineProperty(this, 'label', {
            get: () => {
                // If the expertise is custom, use the label from the config
                if (this.isCustom)
                    return this._source.label ?? this.id;
                // Get the registry key
                const registryKey = CONFIG.COSMERE.expertiseTypes[this.type].configRegistryKey;
                if (!registryKey)
                    return this.id;
                // Get the label from the config
                return foundry.utils.getProperty(CONFIG.COSMERE, `${registryKey}.${this.id}.label`);
            },
            set: (value) => {
                // If the expertise is custom, use the label from the config
                if (this.isCustom) {
                    this._source.label = value;
                }
            },
            configurable: true,
        });
    }
}

// Fields
class CommonActorDataModel extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        return {
            size: new foundry.data.fields.StringField({
                required: true,
                nullable: false,
                blank: false,
                initial: "medium" /* Size.Medium */,
                choices: Object.keys(CONFIG.COSMERE.sizes),
            }),
            type: new foundry.data.fields.SchemaField({
                id: new foundry.data.fields.StringField({
                    required: true,
                    nullable: false,
                    blank: false,
                    initial: "humanoid" /* CreatureType.Humanoid */,
                    choices: Object.keys(CONFIG.COSMERE.creatureTypes),
                }),
                custom: new foundry.data.fields.StringField({ nullable: true }),
                subtype: new foundry.data.fields.StringField({
                    nullable: true,
                }),
            }),
            tier: new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                min: 0,
                integer: true,
                initial: 1,
            }),
            senses: new foundry.data.fields.SchemaField({
                range: new DerivedValueField(new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    min: 0,
                    initial: 5,
                })),
                obscuredAffected: new foundry.data.fields.BooleanField({
                    required: true,
                    nullable: false,
                    initial: true,
                }),
            }),
            immunities: this.getImmunitiesSchema(),
            attributes: this.getAttributesSchema(),
            defenses: this.getDefensesSchema(),
            resources: this.getResourcesSchema(),
            skills: this.getSkillsSchema(),
            currency: this.getCurrencySchema(),
            deflect: new DerivedValueField(new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                integer: true,
                min: 0,
                initial: 0,
            }), {
                additionalFields: {
                    natural: new foundry.data.fields.NumberField({
                        required: false,
                        nullable: true,
                        integer: true,
                        initial: 0,
                        label: 'COSMERE.Deflect.Natural.Label',
                        hint: 'COSMERE.Deflect.Natural.Hint',
                    }),
                    source: new foundry.data.fields.StringField({
                        initial: "armor" /* DeflectSource.Armor */,
                        choices: Object.keys(CONFIG.COSMERE.deflect.sources),
                    }),
                    types: this.getDamageDeflectTypesSchema(),
                },
            }),
            movement: this.getMovementSchema(),
            injuries: new DerivedValueField(new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                integer: true,
                min: 0,
                initial: 0,
            })),
            injuryRollBonus: new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                integer: true,
                initial: 0,
            }),
            encumbrance: new foundry.data.fields.SchemaField({
                lift: new DerivedValueField(new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    min: 0,
                    initial: 0,
                })),
                carry: new DerivedValueField(new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    min: 0,
                    initial: 0,
                })),
            }),
            expertises: new ExpertisesField({
                required: true,
            }),
            languages: new foundry.data.fields.ArrayField(new foundry.data.fields.StringField()),
            /**
             * HTML Fields
             */
            biography: new foundry.data.fields.HTMLField({
                label: 'COSMERE.Actor.Biography.Label',
                initial: '',
            }),
            appearance: new foundry.data.fields.HTMLField({
                label: 'COSMERE.Actor.Appearance.Label',
                initial: '',
            }),
            notes: new foundry.data.fields.HTMLField({
                label: 'COSMERE.Actor.Notes.Label',
                initial: '',
            }),
        };
    }
    static getAttributesSchema() {
        const attributes = CONFIG.COSMERE.attributes;
        return new foundry.data.fields.SchemaField(Object.keys(attributes).reduce((schemas, key) => {
            schemas[key] = new foundry.data.fields.SchemaField({
                value: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    min: 0,
                    max: 10,
                    initial: 0,
                }),
                bonus: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    initial: 0,
                }),
            });
            return schemas;
        }, {}));
    }
    static getDefensesSchema() {
        const defenses = CONFIG.COSMERE.attributeGroups;
        return new foundry.data.fields.SchemaField(Object.keys(defenses).reduce((schemas, key) => {
            schemas[key] = new DerivedValueField(new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                integer: true,
                min: 0,
                initial: 0,
            }));
            return schemas;
        }, {}));
    }
    static getResourcesSchema() {
        const resources = CONFIG.COSMERE.resources;
        return new foundry.data.fields.SchemaField(Object.keys(resources).reduce((schemas, key) => {
            schemas[key] = new foundry.data.fields.SchemaField({
                value: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    min: 0,
                    initial: 0,
                }),
                max: new DerivedValueField(new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    min: 0,
                    initial: 0,
                })),
                bonus: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    initial: 0,
                }),
            });
            return schemas;
        }, {}));
    }
    static getSkillsSchema() {
        const skills = CONFIG.COSMERE.skills;
        return new foundry.data.fields.SchemaField(Object.keys(skills).reduce((schemas, key) => {
            schemas[key] = new foundry.data.fields.SchemaField({
                attribute: new foundry.data.fields.StringField({
                    required: true,
                    nullable: false,
                    blank: false,
                    initial: skills[key].attribute,
                }),
                rank: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    min: 0,
                    max: 5,
                    initial: 0,
                }),
                mod: new DerivedValueField(new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    min: 0,
                    initial: 0,
                })),
                // Only present for non-core skills
                ...(!skills[key].core
                    ? {
                        unlocked: new foundry.data.fields.BooleanField({
                            required: true,
                            nullable: false,
                            initial: false,
                        }),
                    }
                    : {}),
            });
            return schemas;
        }, {}));
    }
    static getCurrencySchema() {
        const currencies = CONFIG.COSMERE.currencies;
        return new foundry.data.fields.SchemaField(Object.keys(currencies).reduce((schemas, key) => {
            schemas[key] = new foundry.data.fields.SchemaField({
                denominations: new foundry.data.fields.ArrayField(this.getCurrencyDenominationSchema(key)),
                total: new DerivedValueField(new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: false,
                    min: 0,
                    initial: 0,
                })),
            });
            return schemas;
        }, {}));
    }
    static getCurrencyDenominationSchema(currency) {
        const denominations = CONFIG.COSMERE.currencies[currency].denominations;
        return new foundry.data.fields.SchemaField({
            id: new foundry.data.fields.StringField({
                required: true,
                nullable: false,
                choices: denominations.primary.map((d) => d.id),
            }),
            secondaryId: new foundry.data.fields.StringField({
                required: false,
                nullable: false,
                choices: denominations.secondary?.map((d) => d.id) ?? [],
            }),
            amount: new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                integer: true,
                min: 0,
                initial: 0,
            }),
            conversionRate: new DerivedValueField(new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                integer: false, // Support subdenominations of the "base", e.g. 1 chip = 0.2 marks
                min: 0,
                initial: 0,
            })),
            convertedValue: new DerivedValueField(new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                integer: false,
                min: 0,
                initial: 0,
            })),
        });
    }
    static getDamageDeflectTypesSchema() {
        const damageTypes = Object.keys(CONFIG.COSMERE.damageTypes);
        return new foundry.data.fields.SchemaField(damageTypes.reduce((schema, type) => ({
            ...schema,
            [type]: new foundry.data.fields.BooleanField({
                required: true,
                nullable: false,
                initial: !CONFIG.COSMERE.damageTypes[type].ignoreDeflect,
            }),
        }), {}), {
            required: true,
        });
    }
    static getImmunitiesSchema() {
        return new foundry.data.fields.SchemaField({
            damage: this.getDamageImmunitiesSchema(),
            condition: this.getConditionImmunitiesSchema(),
        }, {
            required: true,
        });
    }
    static getDamageImmunitiesSchema() {
        const damageTypes = Object.keys(CONFIG.COSMERE.damageTypes);
        return new foundry.data.fields.SchemaField(damageTypes.reduce((schema, type) => ({
            ...schema,
            [type]: new foundry.data.fields.BooleanField({
                required: true,
                nullable: false,
                initial: false,
            }),
        }), {}), {
            required: true,
        });
    }
    static getConditionImmunitiesSchema() {
        const conditions = Object.keys(CONFIG.COSMERE.statuses);
        return new foundry.data.fields.SchemaField(conditions.reduce((schema, condition) => ({
            ...schema,
            [condition]: new foundry.data.fields.BooleanField({
                required: true,
                nullable: false,
                initial: false,
            }),
        }), {}), {
            required: true,
        });
    }
    static getMovementSchema() {
        const movementTypeConfigs = CONFIG.COSMERE.movement.types;
        return new foundry.data.fields.SchemaField(Object.entries(movementTypeConfigs).reduce((schema, [type, config]) => ({
            ...schema,
            [type]: new foundry.data.fields.SchemaField({
                rate: new DerivedValueField(new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    min: 0,
                    initial: 0,
                })),
            }),
        }), {}));
    }
    prepareDerivedData() {
        super.prepareDerivedData();
        // Derive non-core skill unlocks
        Object.keys(this.skills).forEach((skill) => {
            if (CONFIG.COSMERE.skills[skill].core)
                return;
            // Check if the actor has a power that unlocks this skill
            const unlocked = this.parent.powers.some((power) => power.system.skill === skill);
            // Set unlocked status
            this.skills[skill].unlocked = unlocked;
        });
        // Lock other movement types to always use override
        Object.keys(CONFIG.COSMERE.movement.types)
            .filter((type) => type !== "walk" /* MovementType.Walk */)
            .forEach((type) => (this.movement[type].rate.useOverride = true));
        // Injury count
        this.injuries.derived = this.parent.items.filter((item) => item.type === "injury" /* ItemType.Injury */).length;
        const money = this.parent.items.filter((item) => item.type === "loot" /* ItemType.Loot */ &&
            item.system.isMoney);
        // Derive currency conversion values
        Object.keys(this.currency).forEach((currency) => {
            // Get currency data
            const currencyData = this.currency[currency];
            let total = 0;
            money.forEach((item) => {
                if (item.system.price.currency !== currency)
                    return;
                total += parseFloat((item.system.price.baseValue * item.system.quantity).toFixed(2));
            });
            // Update derived total
            currencyData.total.derived = total;
        });
    }
    /**
     * Apply secondary data derivations to this Data Model.
     * This is called after Active Effects are applied.
     */
    prepareSecondaryDerivedData() {
        // Senses range
        this.senses.range.derived = awarenessToSensesRange(this.attributes.awa);
        // Lifting & Carrying
        this.encumbrance.lift.derived = strengthToLiftingCapacity(this.attributes.str);
        this.encumbrance.carry.derived = strengthToCarryingCapacity(this.attributes.str);
        // Movement
        this.movement["walk" /* MovementType.Walk */].rate.derived = speedToMovementRate(this.attributes.spd);
        // Derive defenses
        Object.keys(this.defenses).forEach((group) => {
            // Get attributes
            const attrs = CONFIG.COSMERE.attributeGroups[group].attributes;
            // Get attribute values
            const attrValues = attrs.map((key) => this.attributes[key].value);
            // Sum attribute values
            const attrsSum = attrValues.reduce((sum, v) => sum + v, 0);
            // Assign defense
            this.defenses[group].derived = 10 + attrsSum;
        });
        // Derive skill modifiers
        Object.keys(this.skills).forEach((skill) => {
            // Get the skill config
            const skillConfig = CONFIG.COSMERE.skills[skill];
            // Get the attribute associated with this skill
            const attributeId = skillConfig.attribute;
            // Get attribute
            const attribute = this.attributes[attributeId];
            // Get skill rank
            const rank = this.skills[skill].rank;
            // Get attribute value
            const attrValue = attribute.value + attribute.bonus;
            // Calculate mod
            this.skills[skill].mod.derived = attrValue + rank;
        });
        // Get deflect source, defaulting to armor
        const source = this.deflect.source ?? "armor" /* DeflectSource.Armor */;
        // Derive deflect value
        if (source === "armor" /* DeflectSource.Armor */) {
            // Get natural deflect value
            const natural = this.deflect.natural ?? 0;
            this.deflect.types = Object.keys(CONFIG.COSMERE.damageTypes).reduce((obj, type) => {
                obj[type] = false;
                return obj;
            }, {});
            // Find equipped armor with the highest deflect value
            const armor = this.parent.items
                .filter((item) => item.isArmor())
                .filter((item) => item.system.equipped)
                .reduce((highest, item) => {
                return !highest ||
                    item.system.deflect > highest.system.deflect
                    ? item
                    : highest;
            }, null);
            // Get armor deflect value and types
            const armorDeflect = armor?.system.deflect ?? 0;
            if (armor) {
                Object.keys(armor.system.deflects).forEach((type) => (this.deflect.types[type] =
                    armor.system.deflects[type].active));
            }
            else {
                Object.keys(CONFIG.COSMERE.damageTypes).forEach((type) => (this.deflect.types[type] = !(CONFIG.COSMERE.damageTypes[type]
                    .ignoreDeflect ?? false)));
            }
            // Derive deflect
            this.deflect.derived = Math.max(natural, armorDeflect);
        }
        // Clamp resource values to their max values
        Object.keys(this.resources).forEach((key) => {
            // Get the resource
            const resource = this.resources[key];
            // Get max
            const max = resource.max.value;
            // Ensure resource value is between max mand min
            resource.value = Math.max(0, Math.min(max, resource.value));
        });
    }
}
const SENSES_RANGES = [5, 10, 20, 50, 100, Number.MAX_VALUE];
function awarenessToSensesRange(attr) {
    const awareness = attr.value + attr.bonus;
    return SENSES_RANGES[Math.min(Math.ceil(awareness / 2), SENSES_RANGES.length)];
}
const MOVEMENT_RATES = [20, 25, 30, 40, 60, 80];
function speedToMovementRate(attr) {
    const speed = attr.value + attr.bonus;
    return MOVEMENT_RATES[Math.min(Math.ceil(speed / 2), MOVEMENT_RATES.length)];
}
const LIFTING_CAPACITIES = [100, 200, 500, 1000, 5000, 10000];
function strengthToLiftingCapacity(attr) {
    const strength = attr.value + attr.bonus;
    return LIFTING_CAPACITIES[Math.min(Math.ceil(strength / 2), LIFTING_CAPACITIES.length)];
}
const CARRYING_CAPACITIES = [50, 100, 250, 500, 2500, 5000];
function strengthToCarryingCapacity(attr) {
    const strength = attr.value + attr.bonus;
    return CARRYING_CAPACITIES[Math.min(Math.ceil(strength / 2), CARRYING_CAPACITIES.length)];
}

function getTypeLabel(type) {
    // Check if type is a custom type
    const isCustom = type.id === "custom" /* CreatureType.Custom */;
    // Get subtype
    const subtype = type.subtype;
    // Get config
    const typeConfig = CONFIG.COSMERE.creatureTypes[type.id];
    // Get primary type label
    const primaryLabel = isCustom && type.custom
        ? type.custom
        : game.i18n.localize(typeConfig.label);
    // Construct type label
    return `${primaryLabel} ${subtype ? `(${subtype})` : ''}`.trim();
}
async function getActor(uuid) {
    const { collection, documentId, id, type } = foundry.utils.parseUuid(uuid);
    const document = collection instanceof CompendiumCollection
        ? (await collection.getDocument(documentId))
        : collection.get(documentId);
    return document instanceof Scene
        ? document.tokens.get(uuid.split('.')[3]).actor
        : document;
}
function containsExpertise(collection, ...rest) {
    const [type, id] = rest.length === 1 ? [rest[0].type, rest[0].id] : rest;
    return collection.has(Expertise.getKey({ type, id }));
}

// Constants
/**
 * Item types of which only a single instance can be
 * embedded in an actor.
 */
const SINGLETON_ITEM_TYPES = ["ancestry" /* ItemType.Ancestry */];
class CosmereActor extends Actor {
    /* --- Accessors --- */
    get conditions() {
        return this.statuses;
    }
    get applicableEffects() {
        const effects = new Array();
        for (const effect of this.allApplicableEffects()) {
            effects.push(effect);
        }
        return effects;
    }
    get favorites() {
        return this.items
            .filter((i) => i.isFavorite)
            .sort((a, b) => (a.getFlag(SYSTEM_ID, 'favorites.sort') ??
            Number.MAX_VALUE) -
            (b.getFlag(SYSTEM_ID, 'favorites.sort') ??
                Number.MAX_VALUE));
    }
    get deflect() {
        return this.system.deflect.value;
    }
    get ancestry() {
        return this.items.find((i) => i.isAncestry());
    }
    get cultures() {
        return this.items.filter((i) => i.isCulture());
    }
    get paths() {
        return this.items.filter((i) => i.isPath());
    }
    get goals() {
        return this.items.filter((i) => i.isGoal());
    }
    get powers() {
        return this.items.filter((i) => i.isPower());
    }
    get talents() {
        return this.items.filter((i) => i.isTalent());
    }
    get skillLinkedItems() {
        return this.items
            .filter((item) => !item.isPath() && !item.isAncestry() && !item.isCulture())
            .filter((item) => item.hasLinkedSkills() &&
            item.system.linkedSkills.length > 0 &&
            item.system.linkedSkills.some((skill) => this.unlockedSkills.includes(skill)));
    }
    /**
     * List of all non-core (unlocked) skills of this actor.
     */
    get unlockedSkills() {
        return Object.entries(this.system.skills)
            .filter(([, skill]) => skill.unlocked)
            .map(([skill]) => skill);
    }
    /**
     * A list of all non-core (unlocked) skills of this actor that
     * do not have an associated path.
     */
    get orphanedSkills() {
        return this.unlockedSkills.filter((skill) => !this.items
            .filter((item) => item.hasLinkedSkills())
            .some((path) => path.system.linkedSkills.includes(skill)));
    }
    /* --- Type Guards --- */
    isCharacter() {
        return this.type === "character" /* ActorType.Character */;
    }
    isAdversary() {
        return this.type === "adversary" /* ActorType.Adversary */;
    }
    /* --- Lifecycle --- */
    prepareEmbeddedDocuments() {
        /**
         * NOTE: This is a workaround for the fact that in base Foundry, the Actor invokes
         * the applyActiveEffects method during the prepareEmbeddedDocuments method, leaving
         * us unable to access derived values in ActiveEffects.
         */
        /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */
        // Grab the Actor's parent class' prepareEmbeddedDocuments method
        const parentProto = Object.getPrototypeOf(Object.getPrototypeOf(this));
        const grandparentProto = Object.getPrototypeOf(parentProto);
        const f = grandparentProto.prepareEmbeddedDocuments;
        /* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */
        // Call the parent class' prepareEmbeddedDocuments method
        f.call(this);
    }
    prepareDerivedData() {
        super.prepareDerivedData();
        this.applyActiveEffects();
        this.system.prepareSecondaryDerivedData();
    }
    _initialize(options) {
        super._initialize(options);
        // Migrate goals
        void this.migrateGoals();
    }
    async _preCreate(data, options, user) {
        if ((await super._preCreate(data, options, user)) === false)
            return false;
        // Configure prototype token settings
        const prototypeToken = {};
        if (this.isCharacter()) {
            foundry.utils.mergeObject(prototypeToken, {
                sight: {
                    enabled: true,
                },
                actorLink: true,
                disposition: CONST.TOKEN_DISPOSITIONS.FRIENDLY,
            });
        }
        this.updateSource({ prototypeToken });
    }
    async createEmbeddedDocuments(embeddedName, data, opertion) {
        // Pre create actions
        if (this.preCreateEmbeddedDocuments(embeddedName, data, opertion) ===
            false)
            return [];
        // Perform create
        const result = await super.createEmbeddedDocuments(embeddedName, data, opertion);
        // Post create actions
        this.postCreateEmbeddedDocuments(embeddedName, result);
        // Return result
        return result;
    }
    async modifyTokenAttribute(attribute, value, isDelta, isBar) {
        if (isBar) {
            // Get the attribute object
            const attr = foundry.utils.getProperty(this.system, attribute);
            const current = attr.value;
            const max = attr.max.value;
            const update = Math.clamp(isDelta ? current + value : value, 0, max);
            if (update === current)
                return this;
            // Set up updates
            const updates = {
                [`system.${attribute}.value`]: update,
            };
            // Allow a hook to override these changes
            const allowed = Hooks.call('modifyTokenAttribute', { attribute, value, isDelta, isBar }, updates);
            return allowed !== false
                ? (await this.update(updates))
                : this;
        }
        else {
            await super.modifyTokenAttribute(attribute, value, isDelta, isBar);
        }
    }
    toggleStatusEffect(statusId, options) {
        // Check if actor is immune to status effect
        if (statusId in this.system.immunities.condition &&
            this.system.immunities.condition[statusId]) {
            // Notify
            ui.notifications.warn(game.i18n.format('GENERIC.Warning.ActorConditionImmune', {
                actor: this.name,
                condition: game.i18n.localize(CONFIG.COSMERE.statuses[statusId].label),
            }));
            return Promise.resolve(false);
        }
        // Handle as normal
        return super.toggleStatusEffect(statusId, options);
    }
    /* --- Handlers --- */
    preCreateEmbeddedDocuments(embeddedName, data, opertion) {
        if (embeddedName === 'Item') {
            const itemData = data;
            // Check for singleton items
            SINGLETON_ITEM_TYPES.forEach((type) => {
                // Get the first item of this type
                const item = itemData.find((d) => d.type === type);
                // Filter out any other items of this type
                data = item
                    ? itemData.filter((d) => d.type !== type || d === item)
                    : itemData;
            });
            // Pre add powers
            itemData.forEach((d, i) => {
                if (d.type === "power" /* ItemType.Power */) {
                    if (this.preAddPower(d) === false) {
                        itemData.splice(i, 1);
                    }
                }
            });
        }
    }
    preAddPower(data) {
        // Ensure a power with the same id does not already exist
        if (this.powers.some((i) => i.hasId() && i.system.id === data.system?.id)) {
            ui.notifications.error(game.i18n.format('COSMERE.Item.Power.Notification.PowerExists', {
                actor: this.name,
                identifier: data.system.id,
            }));
            return false;
        }
    }
    postCreateEmbeddedDocuments(embeddedName, documents) {
        documents.forEach((doc) => {
            if (embeddedName === 'Item') {
                const item = doc;
                if (item.isAncestry()) {
                    this.onAncestryAdded(item);
                }
            }
        });
    }
    onAncestryAdded(item) {
        // Find any other ancestry items
        const otherAncestries = this.items.filter((i) => i.isAncestry() && i.id !== item.id);
        // Remove other ancestries
        otherAncestries.forEach((i) => {
            void i.delete();
        });
    }
    /* --- Functions --- */
    async setMode(modality, mode) {
        await this.setFlag(SYSTEM_ID, `mode.${modality}`, mode);
        // Check if modality update was blocked
        if (this.getMode(modality) !== mode)
            return;
        // Get all effects for this modality
        const effects = this.applicableEffects.filter((effect) => effect.parent instanceof CosmereItem &&
            effect.parent.hasModality() &&
            effect.parent.system.modality === modality);
        // Get the effect for the new mode
        const modeEffect = effects.find((effect) => effect.parent.system.id === mode);
        // Deactivate all other effects
        for (const effect of effects) {
            if (effect !== modeEffect && !effect.disabled) {
                void effect.update({ disabled: true });
            }
        }
        // Activate the mode effect
        if (modeEffect) {
            void modeEffect.update({ disabled: false });
        }
    }
    async clearMode(modality) {
        await this.unsetFlag(SYSTEM_ID, `mode.${modality}`);
        // Check if modality update was blocked
        if (this.getMode(modality))
            return;
        // Get all effects for this modality
        const effects = this.effects.filter((effect) => effect.parent instanceof CosmereItem &&
            effect.parent.isTalent() &&
            effect.parent.system.id === modality);
        // Deactivate all effects
        for (const effect of effects) {
            void effect.update({ disabled: true });
        }
    }
    getMode(modality) {
        return this.getFlag(SYSTEM_ID, `mode.${modality}`);
    }
    async rollInjury() {
        // Get roll table
        const table = (await fromUuid(CONFIG.COSMERE.injury.durationTable));
        // Get injury roll bonus
        const bonus = this.system.injuryRollBonus;
        // Get injuries modifier
        const injuriesModifier = this.system.injuries.value * -5;
        // Build formula
        const formula = ['1d20', this.deflect, bonus, injuriesModifier].join(' + ');
        // Roll
        const roll = new foundry.dice.Roll(formula);
        /**
         * Hook: preRollInjuryType
         */
        if (Hooks.call(HOOKS.PRE_INJURY_TYPE_ROLL, roll, // Roll object
        this) === false)
            return;
        // NOTE: Draw function type definition is wrong, must use `any` type as a workaround
        /* eslint-disable @typescript-eslint/no-explicit-any */
        const draw = await table.draw({
            roll,
            displayChat: false,
        });
        /* eslint-Enable @typescript-eslint/no-explicit-any */
        // Get result
        const result = draw.results[0];
        /**
         * Hook: rollInjuryType
         */
        Hooks.callAll(HOOKS.INJURY_TYPE_ROLL, roll, // Evaluated roll
        result, // Table result
        this);
        // Get injury data
        const data = result.getFlag(SYSTEM_ID, 'injury-data');
        const rolls = [];
        if (data.type !== "death" /* InjuryType.Death */ &&
            data.type !== "permanent_injury" /* InjuryType.PermanentInjury */) {
            // Roll duration
            const durationRoll = new foundry.dice.Roll(data.durationFormula);
            /**
             * Hook: preRollInjuryDuration
             */
            if (Hooks.call(HOOKS.PRE_INJURY_DURATION_ROLL, durationRoll, // Roll object
            this) === false)
                return;
            await durationRoll.evaluate();
            rolls.push(durationRoll);
            /**
             * Hook: rollInjuryDuration
             *
             * Passes the evaluated roll
             */
            Hooks.callAll(HOOKS.INJURY_DURATION_ROLL, durationRoll, // Roll object
            this, // Source
            {});
        }
        const flags = {};
        flags[SYSTEM_ID] = {
            message: {
                type: MESSAGE_TYPES.INJURY,
            },
            injury: {
                details: result,
                roll: draw.roll,
            },
        };
        // Chat message
        await ChatMessage.create({
            user: game.user.id,
            speaker: ChatMessage.getSpeaker({
                actor: this,
            }),
            flags,
            rolls,
        });
    }
    /**
     * Utility function to apply damage to this actor.
     * This function will automatically apply deflect & immunities and
     * send a chat message.
     */
    async applyDamage(instances, options = {}) {
        if (!Array.isArray(instances))
            instances = [instances];
        // Get health resource
        const health = this.system.resources["hea" /* Resource.Health */].value;
        // Get immunities
        const immunities = this.system.immunities;
        let damageDeflect = 0;
        let damageIgnore = 0;
        let damageImmune = 0;
        let healing = 0;
        const appliedImmunities = new Map();
        instances.forEach((instance) => {
            // Get damage config
            const damageConfig = instance.type
                ? CONFIG.COSMERE.damageTypes[instance.type]
                : { ignoreDeflect: false };
            const pierce = options.originatingItem?.isWeapon() &&
                (options.originatingItem?.system?.traits?.pierce?.active ??
                    false);
            // Checks if damage should be deflected or not
            const ignoreDeflect = (pierce ?? false) ||
                (instance.type
                    ? this.system.deflect.types
                        ? !this.system.deflect.types[instance.type]
                        : damageConfig.ignoreDeflect
                    : false);
            const amount = Math.floor(instance.amount);
            // Check if actor is immune to damage type
            if (!!instance.type && immunities.damage[instance.type]) {
                // Add to total immune damage
                damageImmune += instance.amount;
                // Add individual immunities
                appliedImmunities.set(instance.type, (appliedImmunities.get(instance.type) ?? 0) +
                    instance.amount);
                return;
            }
            if (instance.type === DamageType.Healing) {
                healing += amount;
                return;
            }
            if (ignoreDeflect) {
                damageIgnore += amount;
            }
            else {
                damageDeflect += amount;
            }
        });
        const damageTaken = damageIgnore + Math.max(0, damageDeflect - this.deflect) - healing;
        // Store in an object to pass by reference into hooks
        const damage = {
            // Unadjusted damage calculation
            calculated: damageTaken,
        };
        /**
         * Hook: preApplyDamage
         */
        if (Hooks.call(HOOKS.PRE_APPLY_DAMAGE, this, damage) === false)
            return;
        // Apply damage
        const newHealth = Math.max(0, health - damage.calculated);
        await this.update({
            'system.resources.hea.value': newHealth,
        });
        // Actual damage that was applied
        damage.dealt = health - newHealth;
        /**
         * Hook: applyDamage
         */
        Hooks.callAll(HOOKS.APPLY_DAMAGE, this, damage);
        if (options.chatMessage ?? true) {
            const messageConfig = {
                user: game.user.id,
                speaker: ChatMessage.getSpeaker({
                    actor: this,
                }),
                flags: {},
            };
            messageConfig.flags[SYSTEM_ID] = {
                message: {
                    type: MESSAGE_TYPES.DAMAGE_TAKEN,
                },
                taken: {
                    health,
                    damageTaken: damage.calculated,
                    damageDeflect,
                    damageIgnore,
                    damageImmune,
                    appliedImmunities: Object.fromEntries(appliedImmunities),
                    target: this.uuid,
                    undo: true,
                },
            };
            // Create chat message
            await ChatMessage.create(messageConfig);
        }
    }
    async applyHealing(amount) {
        return this.applyDamage([
            { amount, type: DamageType.Healing },
        ]);
    }
    /**
     * Utility function to get the modifier for a given attribute for this actor.
     * @param attribute The attribute to get the modifier for
     */
    getAttributeMod(attribute) {
        // Get attribute
        const attr = this.system.attributes[attribute];
        return attr.value + attr.bonus;
    }
    /**
     * Utility function to get the modifier for a given skill for this actor.
     * @param skill The skill to get the modifier for
     * @param attributeOverride An optional attribute override, used instead of the default attribute
     */
    getSkillMod(skill, attributeOverride) {
        // Get attribute id
        const attributeId = attributeOverride ?? CONFIG.COSMERE.skills[skill].attribute;
        // Get skill rank
        const rank = this.system.skills[skill]?.rank ?? 0;
        // Get attribute value
        const attrValue = this.getAttributeMod(attributeId);
        return attrValue + rank;
    }
    /**
     * Roll a skill for this actor
     */
    async rollSkill(skillId, options = {}) {
        const skill = this.system.skills[skillId];
        const attribute = this.system.attributes[options.attribute ?? skill.attribute];
        const data = this.getRollData();
        // Add attribute mod
        data.mod = options.attribute
            ? attribute.value + attribute.bonus + skill.rank
            : skill.mod.value;
        data.skill = {
            id: skillId,
            rank: skill.rank,
            mod: data.mod,
            attribute: skill.attribute,
        };
        data.attribute = attribute.value + attribute.bonus;
        data.attributes = this.system.attributes;
        data.context = 'Skill';
        // Prepare roll data
        const flavor = `${game.i18n.localize(CONFIG.COSMERE.skills[skillId].label)} ${game.i18n.localize('GENERIC.SkillTest')}`;
        const rollData = foundry.utils.mergeObject({
            data: data,
            title: flavor,
            defaultAttribute: options.attribute ?? skill.attribute,
            messageData: {
                speaker: options.speaker ??
                    ChatMessage.getSpeaker({
                        actor: this,
                    }),
                flags: {},
            },
        }, options);
        rollData.parts = [`@mod`].concat(options.parts ?? []);
        rollData.messageData.flags[SYSTEM_ID] = {
            message: {
                type: MESSAGE_TYPES.SKILL,
                targets: getTargetDescriptors(),
            },
        };
        // Perform roll
        const roll = await d20Roll(rollData);
        // Return roll
        return roll;
    }
    /**
     * Utility function to roll an item for this actor
     */
    async rollItem(item, options) {
        return item.roll({ ...options, actor: this });
    }
    async modifySkillRank(skillId, param1 = true, render = true) {
        const incrementBool = typeof param1 === 'boolean' ? param1 : true;
        const changeAmount = typeof param1 === 'number' ? param1 : 1;
        const skillpath = `system.skills.${skillId}.rank`;
        const skill = this.system.skills[skillId];
        if (incrementBool) {
            await this.update({ [skillpath]: Math.clamp(skill.rank + changeAmount, 0, 5) }, { render });
        }
        else {
            await this.update({ [skillpath]: Math.clamp(skill.rank - changeAmount, 0, 5) }, { render });
        }
    }
    /**
     * Utility function to use an item for this actor
     */
    async useItem(item, options) {
        // Checks for relevant Active Effects triggers/manual toggles will go here
        // E.g. permanent/conditional: attack bonuses, damage riders, auto opportunity/complications, etc.
        return item.use({ ...options, actor: this });
    }
    /**
     * Utility function to handle short resting.
     * This function takes care of rolling the recovery die.
     * Automatically applies the appropriate Medicine modifier.
     */
    async shortRest(options = {}) {
        if (!this.isCharacter())
            return;
        // Defaults
        options.dialog = options.dialog ?? true;
        // Show the dialog if required
        if (options.dialog) {
            const result = await ShortRestDialog.show(this, options);
            if (!result?.performRest)
                return;
            options.tendedBy = result.tendedBy;
        }
        /**
         * Hook: preRest
         */
        if (Hooks.call(HOOKS.PRE_REST, this, "short" /* RestType.Short */) === false) {
            return;
        }
        // Get Medicine mod, if required
        const mod = options.tendedBy
            ? options.tendedBy.system.skills.med.mod.value
            : undefined;
        // Construct formula
        const formula = [this.system.recovery.die.value, mod]
            .filter((v) => !!v)
            .join(' + ');
        // Configure the roll
        const roll = Roll.create(formula);
        /**
         * Hook: preShortRestRecoveryRoll
         */
        if (Hooks.call(HOOKS.PRE_SHORT_REST_RECOVERY_ROLL, roll, // Roll object
        this) === false)
            return;
        // Evaluate the roll
        await roll.evaluate();
        /**
         * Hook: shortRestRecoveryRoll
         */
        Hooks.callAll(HOOKS.SHORT_REST_RECOVERY_ROLL, roll, // Roll object
        this, // Source
        {});
        // Set up flavor
        let flavor = game
            .i18n.localize('ROLLS.Recovery')
            .replace('[character]', this.name);
        if (options.tendedBy) {
            flavor += ` ${game
                .i18n.localize('ROLLS.RecoveryTend')
                .replace('[tender]', options.tendedBy.name)}`;
        }
        // Chat message
        await roll.toMessage({
            flavor,
        });
        /**
         * Hook: rest
         */
        Hooks.callAll(HOOKS.REST, this, "short" /* RestType.Short */);
    }
    /**
     * Utility function to handle long resting.
     * Long resting grants the following benefits:
     * - Recover all lost health
     * - Recover all lost focus
     * - Reduce Exhausted penalty by 1 (TODO)
     */
    async longRest(options = {}) {
        // Defaults
        options.dialog = options.dialog ?? true;
        // Show the confirm dialog if required
        if (options.dialog) {
            const shouldContinue = await new Promise((resolve) => {
                void new foundry.applications.api.DialogV2({
                    window: {
                        title: 'COSMERE.Actor.Sheet.LongRest',
                    },
                    content: `<span>${game.i18n.localize('DIALOG.LongRest.ShouldPerform')}</span>`,
                    buttons: [
                        {
                            label: 'GENERIC.Button.Continue',
                            action: 'continue',
                            // NOTE: Callback must be async
                            // eslint-disable-next-line @typescript-eslint/require-await
                            callback: async () => resolve(true),
                        },
                        {
                            label: 'GENERIC.Button.Cancel',
                            action: 'cancel',
                            // eslint-disable-next-line @typescript-eslint/require-await
                            callback: async () => resolve(false),
                        },
                    ],
                }).render(true);
            });
            if (!shouldContinue)
                return;
        }
        /**
         * Hook: preRest
         */
        if (Hooks.call(HOOKS.PRE_REST, this, "long" /* RestType.Long */) === false)
            return;
        // Update the actor
        await this.update({
            'system.resources.hea.value': this.system.resources.hea.max.value,
            'system.resources.foc.value': this.system.resources.foc.max.value,
        });
        /**
         * Hook: rest
         */
        Hooks.callAll(HOOKS.REST, this, "long" /* RestType.Long */);
    }
    getRollData() {
        const tokens = this.getActiveTokens();
        return {
            ...super.getRollData(),
            name: this.name,
            // Attributes shorthand
            attr: Object.keys(CONFIG.COSMERE.attributes).reduce((data, attrId) => ({
                ...data,
                [attrId]: this.system.attributes[attrId].value,
            }), {}),
            // Skills
            skills: Object.keys(CONFIG.COSMERE.skills).reduce((data, skillId) => ({
                ...data,
                [skillId]: {
                    rank: this.system.skills[skillId].rank,
                    mod: this.system.skills[skillId].mod.value,
                },
            }), {}),
            // Scalars
            scalar: {
                damage: {
                    unarmed: this.getFormulaFromScalarAttribute("str" /* Attribute.Strength */, CONFIG.COSMERE.scaling.damage.unarmed.strength),
                },
                power: {
                    ...this.powers.reduce((scaling, power) => {
                        // Get the power skill id
                        const skillId = power.system.skill;
                        if (!skillId)
                            return scaling;
                        // Get the skill
                        const skill = this.system.skills[skillId];
                        if (!skill?.unlocked)
                            return scaling;
                        // Add scaling
                        scaling[power.system.id] = {
                            die: this.getFormulaFromScalar(skill.rank, CONFIG.COSMERE.scaling.power.die.ranks),
                            'effect-size': this.getFormulaFromScalar(skill.rank, CONFIG.COSMERE.scaling.power.effectSize
                                .ranks),
                        };
                        return scaling;
                    }, {}),
                },
            },
            token: tokens.length > 0
                ? { name: tokens[0]?.name }
                : undefined,
            // Hook data
            source: this,
        };
    }
    getEnricherData() {
        const actor = this.getRollData();
        const targets = getTargetDescriptors();
        return {
            actor,
            target: targets.length > 0 ? targets[0] : undefined,
        };
    }
    // public *allApplicableEffects() {
    //     for (const effect of super.allApplicableEffects()) {
    //         if (
    //             !(effect.parent instanceof CosmereItem) ||
    //             !effect.parent.isEquippable() ||
    //             effect.parent.system.equipped
    //         ) {
    //             yield effect;
    //         }
    //     }
    // }
    /**
     * Utility Function to determine a formula value based on a scalar plot of an attribute value
     */
    getFormulaFromScalarAttribute(attrId, scale) {
        // Get the attribute
        const attr = this.system.attributes[attrId];
        const value = attr.value + attr.bonus;
        return this.getFormulaFromScalar(value, scale);
    }
    getFormulaFromScalar(value, scale) {
        for (const range of scale) {
            if (('value' in range && value === range.value) ||
                ('min' in range && value >= range.min && value <= range.max)) {
                return range.formula;
            }
        }
        // Default to the first (assumed lowest) formula
        return scale[0].formula;
    }
    hasExpertise(...args) {
        return containsExpertise(this.system.expertises, ...args);
    }
    /**
     * Utility function to determine if an actor has a given immunity
     * I know there's a neater way to do this...
     */
    hasImmunity(type, name) {
        return type === "damage" /* ImmunityType.Damage */
            ? this.system.immunities[type][name]
            : this.system.immunities[type][name];
    }
    /**
     * Utility function to determine if an actor has a given talent
     */
    hasTalent(id) {
        return this.talents.some((talent) => talent.system.id === id);
    }
    /**
     * Utility function to determine if the actor meets the
     * given talent prerequisites.
     */
    hasTalentPreRequisites(prerequisites, tree) {
        if (!this.isCharacter())
            return false;
        return characterMeetsTalentPrerequisites(this, prerequisites, tree);
    }
    /**
     * Utility function to determine if an actor has a given goal
     */
    hasGoal(id) {
        return this.goals.some((goal) => goal.system.id === id);
    }
    /**
     * Utility function to determine if an actor has completed a given goal
     */
    hasCompletedGoal(id) {
        return this.goals.some((goal) => goal.system.id === id && goal.system.level === 3);
    }
    /* --- Helpers --- */
    /**
     * Migrate goals from the system object to individual items.
     *
     */
    async migrateGoals() {
        if (!this.isCharacter() || !this.system.goals)
            return;
        const goals = this.system.goals;
        // Remove goals from data
        await this.update({
            'system.goals': null,
        });
        // Create goal items
        goals.forEach((goalData) => {
            void Item.create({
                type: "goal" /* ItemType.Goal */,
                name: goalData.text,
                system: {
                    level: goalData.level,
                },
            }, { parent: this });
        });
    }
}

// Constants
class CosmereCombat extends Combat {
    /**
     * Sets all defeated combatants activation status to true (already activated),
     * and all others to false (hasn't activated yet)
     */
    resetActivations() {
        this.turns.forEach((combatant) => void combatant.resetActivation());
    }
    async startCombat() {
        this.resetActivations();
        return super.startCombat();
    }
    async nextRound() {
        this.resetActivations();
        return super.nextRound();
    }
    setupTurns() {
        this.turns ??= [];
        const turns = Array.from(this.combatants)
            .flatMap((c) => {
            if (c.isBoss) {
                // If the combatant is a boss, clone it to create a fast turn beside its slow turn
                const clone = new CONFIG.Combatant
                    .documentClass(foundry.utils.mergeObject(c.toObject(), {
                    [`flags.${SYSTEM_ID}.turnSpeed`]: "fast" /* TurnSpeed.Fast */,
                }), { parent: c.parent });
                return [clone, c];
            }
            else {
                return c;
            }
        })
            .sort(this._sortCombatants);
        if (this.turn !== null)
            this.turn = Math.clamp(this.turn, 0, turns.length - 1);
        // Update state tracking
        const c = turns[this.turn];
        this.current = this._getCurrentState(c);
        // One-time initialization of the previous state
        if (!this.previous)
            this.previous = this.current;
        // Return the array of prepared turns
        return (this.turns = turns);
    }
}

// Constants
let _schema;
class CosmereCombatant extends Combatant {
    static defineSchema() {
        const schema = super.defineSchema();
        // Remove the initiative field from the schema as we handle it using a getter
        delete schema.initiative;
        return schema;
    }
    static get schema() {
        if (!_schema) {
            _schema = new foundry.data.fields.SchemaField(this.defineSchema());
        }
        return _schema;
    }
    /* --- Accessors --- */
    get actor() {
        return super.actor;
    }
    get isBoss() {
        return (this.actor.isAdversary() &&
            this.actor.system.role === "boss" /* AdversaryRole.Boss */);
    }
    get initiative() {
        const spd = this.actor.system.attributes.spd;
        let initiative = spd.value + spd.bonus;
        if (this.actor.type === "character" /* ActorType.Character */)
            initiative += 500;
        if (this.turnSpeed === "fast" /* TurnSpeed.Fast */)
            initiative += 1000;
        return initiative;
    }
    get turnSpeed() {
        return this.getFlag(SYSTEM_ID, 'turnSpeed') ?? "slow" /* TurnSpeed.Slow */;
    }
    get activated() {
        return this.getFlag(SYSTEM_ID, 'activated') ?? false;
    }
    get bossFastActivated() {
        return this.getFlag(SYSTEM_ID, 'bossFastActivated') ?? false;
    }
    /* --- Life cycle --- */
    rollInitiative() {
        // Initiative is static and does not require rolling
        return Promise.resolve(this);
    }
    /* --- System functions --- */
    /**
     * Utility function to flip the combatants current turn speed between slow and fast. It then updates initiative to force an update of the combat-tracker ui
     */
    async toggleTurnSpeed() {
        const newSpeed = this.turnSpeed === "slow" /* TurnSpeed.Slow */ ? "fast" /* TurnSpeed.Fast */ : "slow" /* TurnSpeed.Slow */;
        // Update the turn speed
        await this.setFlag(SYSTEM_ID, 'turnSpeed', newSpeed);
    }
    async markActivated(bossFastActivated = false) {
        if (bossFastActivated && this.isBoss) {
            await this.setFlag(SYSTEM_ID, 'bossFastActivated', true);
        }
        else {
            await this.setFlag(SYSTEM_ID, 'activated', true);
        }
    }
    async resetActivation() {
        await this.update({
            [`flags.${SYSTEM_ID}`]: {
                activated: false,
                bossFastActivated: false,
            },
        });
    }
}

class CosmereTokenDocument extends TokenDocument {
    getBarAttribute(barName, options) {
        const attr = super.getBarAttribute(barName, options);
        if (attr && attr.type === 'bar') {
            // Get data
            const data = foundry.utils.getProperty(this.actor.system, attr.attribute);
            if (typeof data.max === 'object') {
                attr.max = data.max.value;
            }
        }
        return attr;
    }
}

function tryApplyRollData(source, changeOrValue, async = false) {
    const rollData = 'getRollData' in source
        ? source.getRollData()
        : source;
    if (typeof changeOrValue === 'object') {
        const value = changeOrValue.value;
        if (async) {
            return tryApplyRollData(rollData, value, async).then((resolvedValue) => ({
                ...changeOrValue,
                value: resolvedValue,
            }));
        }
        else {
            return {
                ...changeOrValue,
                value: tryApplyRollData(rollData, value, async),
            };
        }
    }
    else {
        if (async) {
            return new Roll(changeOrValue, rollData)
                .evaluate()
                .then((roll) => roll.total.toString())
                .catch(() => changeOrValue);
        }
        else {
            try {
                // Treat the change value as a formula and evaluate it
                return new Roll(changeOrValue, rollData)
                    .evaluateSync()
                    .total.toString();
            }
            catch {
                return changeOrValue;
            }
        }
    }
}
function getChangeValue(change, source) {
    // Get the current value
    const currentValue = foundry.utils.getProperty(source, change.key);
    const valueType = foundry.utils.getType(currentValue);
    switch (change.mode) {
        case CONST.ACTIVE_EFFECT_MODES.ADD:
            return valueType === 'number'
                ? currentValue + tryParseNumber(change.value)
                : valueType === 'string'
                    ? currentValue + String(change.value)
                    : valueType === 'Array'
                        ? currentValue.concat(change.value)
                        : valueType === 'Object'
                            ? foundry.utils.mergeObject(currentValue, JSON.parse(change.value))
                            : currentValue;
        case CONST.ACTIVE_EFFECT_MODES.MULTIPLY:
            return valueType === 'number'
                ? currentValue * tryParseNumber(change.value)
                : currentValue;
        case CONST.ACTIVE_EFFECT_MODES.UPGRADE:
            return valueType === 'number'
                ? Math.max(currentValue, tryParseNumber(change.value))
                : valueType === 'string'
                    ? currentValue.localeCompare(change.value) > 0
                        ? currentValue
                        : change.value
                    : currentValue;
        case CONST.ACTIVE_EFFECT_MODES.DOWNGRADE:
            return valueType === 'number'
                ? Math.min(currentValue, tryParseNumber(change.value))
                : valueType === 'string'
                    ? currentValue.localeCompare(change.value) < 0
                        ? currentValue
                        : change.value
                    : currentValue;
        case CONST.ACTIVE_EFFECT_MODES.OVERRIDE:
        case CONST.ACTIVE_EFFECT_MODES.CUSTOM:
        default:
            return change.value;
    }
}
function tryParseNumber(value) {
    const parsed = Number(value);
    return isNaN(parsed) ? 0 : parsed;
}

// Utils
class CosmereActiveEffect extends ActiveEffect {
    /* --- Accessors --- */
    /**
     * The number of stacked instances of this effect. Used for stackable effects.
     * Shorthand for `system.stacks`.
     */
    get stacks() {
        return this.system.stacks ?? 1;
    }
    /**
     * Whether this effect is a system defined status effect.
     */
    get isStatusEffect() {
        return (this.statuses.size === 1 &&
            this.id.startsWith(`cond${this.statuses.first()}`));
    }
    /**
     * Whether this effect is a system defined condition.
     * This is an alias for `isStatusEffect`.
     */
    get isCondition() {
        return this.isStatusEffect;
    }
    /**
     * Whether this effect is stackable.
     * Shorthand for `system.isStackable`.
     */
    get isStackable() {
        return this.system.isStackable;
    }
    /* --- Lifecylce --- */
    async _preCreate(data, options, user) {
        if ((await super._preCreate(data, options, user)) === false)
            return false;
        if (this.isCondition && this.isStackable && this.stacks >= 1) {
            const config = CONFIG.COSMERE.statuses[this.statuses.first()];
            this.updateSource({
                name: `${game.i18n.localize(config.label)} [${config.stacksDisplayTransform
                    ? config.stacksDisplayTransform(this.stacks)
                    : this.stacks}]`,
            });
        }
    }
    async _preUpdate(data, options, user) {
        if (foundry.utils.hasProperty(data, 'system.stacks') &&
            this.isCondition &&
            this.isStackable) {
            const stacks = foundry.utils.getProperty(data, 'system.stacks');
            const config = CONFIG.COSMERE.statuses[this.statuses.first()];
            data.name = `${game.i18n.localize(config.label)} [${config.stacksDisplayTransform
                ? config.stacksDisplayTransform(stacks)
                : stacks}]`;
        }
        return await super._preUpdate(data, options, user);
    }
    async _onUpdate(changed, options, userId) {
        await super._onUpdate(changed, options, userId);
        if (foundry.utils.hasProperty(changed, 'system.stacks') &&
            this.isCondition &&
            this.isStackable) {
            this._displayScrollingStatus(this.active);
        }
    }
    apply(actor, change) {
        // Update the change
        const newChange = tryApplyRollData(actor, change);
        if (this.isStackable) {
            newChange.value = `( ${newChange.value} ) * ${this.stacks}`;
        }
        // Execute the standard ActiveEffect application logic
        return super.apply(actor, newChange);
    }
}

// Constant to improve UI consistency
const NONE = 'none';
var MouseButton;
(function (MouseButton) {
    /**
     * Usually the left mouse button.
     */
    MouseButton[MouseButton["Primary"] = 0] = "Primary";
    /**
     * Usually the right mouse button.
     */
    MouseButton[MouseButton["Secondary"] = 2] = "Secondary";
})(MouseButton || (MouseButton = {}));
const COSMERE_DOCUMENT_CLASSES = {
    Actor: CosmereActor,
    Item: CosmereItem,
};

function cloneCollection(source) {
    // Get the entries
    const entries = Array.from(source.entries()).map(([key, value]) => [
        key,
        value instanceof foundry.abstract.DataModel
            ? value.clone()
            : foundry.utils.deepClone(value),
    ]);
    return source instanceof RecordCollection
        ? new RecordCollection(entries)
        : new Collection(entries);
}
/**
 * Utility function to get the changes between two objects for a Foundry update call.
 */
function getObjectChanges(original, updated) {
    // Flatten the objects
    const originalFlat = foundry.utils.flattenObject(original);
    const updatedFlat = foundry.utils.flattenObject(updated);
    const originalKeys = Object.keys(originalFlat);
    const updatedKeys = Object.keys(updatedFlat);
    // Determine all changed keys (updated or added)
    const changedKeys = updatedKeys.filter((key) => {
        const originalValue = originalFlat[key];
        const updatedValue = updatedFlat[key];
        // Check if the value is different
        return updatedValue !== originalValue && updatedValue !== undefined;
    });
    // Construct all keys paths in the updated object
    const updatedKeyPaths = updatedKeys
        .map((key) => {
        const keyParts = key.split('.');
        return keyParts.map((_, index) => {
            return keyParts.slice(0, index + 1).join('.');
        });
    })
        .flat()
        .filter((v, i, self) => self.indexOf(v) === i);
    // Determine all removed keys
    const removedKeys = originalKeys
        .filter((key) => {
        return (!(key in updatedFlat) ||
            (updatedFlat[key] === undefined &&
                originalFlat[key] !== undefined));
    })
        .map((key) => {
        // Determine to which depth the key is removed
        const keyParts = key.split('.');
        const removalDepth = [...keyParts]
            .reverse()
            .findIndex((_, i, self) => {
            if (i === 0)
                return false; // Skip the last key
            // Construct the key path
            const path = self.slice(i).reverse().join('.');
            // Check if the path is in the updated object
            return updatedKeyPaths.includes(path);
        });
        return removalDepth === -1
            ? `-=${keyParts[0]}`
            : `${keyParts.slice(0, -removalDepth).join('.')}.-=${keyParts.at(-removalDepth)}`;
    })
        .filter((v, i, self) => self.indexOf(v) === i);
    // Construct the changes object
    const changes = {};
    // Add changed keys
    changedKeys.forEach((key) => {
        changes[key] = updatedFlat[key];
    });
    // Add removed keys
    removedKeys.forEach((key) => {
        let keyParts = key.split('.');
        keyParts = [...keyParts.slice(0, -1), keyParts.at(-1).slice(2)];
        // Add the removal operator
        changes[key] = foundry.utils.getProperty(original, keyParts.join('.'));
    });
    return foundry.utils.expandObject(changes);
}
/**
 * Helper function to get a given WorldCollection
 */
function getCollectionForDocumentType(documentType) {
    const collection = game.collections?.get(documentType);
    if (!collection) {
        throw new Error(`Failed to retrieve "${documentType}" collection`);
    }
    return collection;
}
async function getRawDocumentSources(documentType, packID) {
    const operation = {
        query: {},
    };
    if (packID)
        operation.pack = packID;
    // NOTE: Use any type here as it keeps resolving to ManageCompendiumRequest instead of DocumentSocketRequest
    const { result } = await SocketInterface.dispatch('modifyDocument', {
        type: documentType,
        operation,
        action: 'get',
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    });
    return result ?? [];
}
/**
 * Retrieve a document, allowing invalid results.
 */
async function getPossiblyInvalidDocument(documentType, id, compendium) {
    if (compendium) {
        if (compendium.invalidDocumentIds.has(id)) {
            return compendium.getInvalid(id, { strict: true });
        }
        return (await compendium.getDocument(id));
    }
    else {
        return getCollectionForDocumentType(documentType).get(id, {
            strict: true,
            invalid: true,
        });
    }
}
/**
 * Determine if a document is being tracked as invalid.
 */
function isDocumentInvalid(documentType, id, compendium) {
    return (compendium ??
        getCollectionForDocumentType(documentType)).invalidDocumentIds.has(id);
}
/**
 * Manually build a document from source and add it to the relevant collection.
 */
function addDocumentToCollection(documentType, id, document, compendium) {
    // Get the correct document class for the static fromSource call.
    // This is extremely important for foundry to recognize the new
    // document as an actual instance of the documentClass that the
    // collection stores.
    const documentClass = COSMERE_DOCUMENT_CLASSES[documentType];
    // Build from source; cast to CosmereDocument because the static
    // method declarations in Actor, Item, etc. must return `this`.
    // We want an instance of the actual class we're calling from.
    const documentToAdd = documentClass.fromSource(document._source);
    // Manually update collection with document.
    const collection = compendium ?? getCollectionForDocumentType(documentType);
    collection.set(id, documentToAdd);
    // Stop tracking this id as invalid.
    // This is mostly just to clean up the warning
    // at the bottom of the sidebar.
    collection.invalidDocumentIds.delete(id);
}
/**
 * Ensure that, if invalid, a given document is reinstantiated.
 * This eliminates the need to reload after migrations finish,
 * in order for those actors to appear in the sidebar.
 */
function fixInvalidDocument(documentType, document, compendium) {
    if (isDocumentInvalid(documentType, document.id, compendium)) {
        addDocumentToCollection(documentType, document.id, document, compendium);
    }
}

function handleDocumentMigrationError(error, documentType, document) {
    console.log(document);
    ui.notifications.warn(game.i18n.format('COSMERE.Migration.DocumentMigrationFailed', {
        name: document.name,
        sort: game.i18n.localize(`DOCUMENT.${documentType}`),
        type: game.i18n.localize(`TYPES.${documentType}.${document.type}`),
        error: error instanceof Error
            ? `${error.name}: ${error.message}`
            : 'Unknown error',
    }));
    console.warn(`[${SYSTEM_ID}] Failed to migrate document`, error, document);
}

// Utils
var MIGRATE_0_2__0_3 = {
    from: '0.2',
    to: '0.3',
    execute: async (packID) => {
        // Get relevant compendium, if any
        let compendium;
        if (packID) {
            compendium = game.packs?.get(packID);
        }
        /**
         * Items
         */
        if (!compendium || compendium.documentName === 'Item') {
            const items = await getRawDocumentSources('Item', packID);
            /* --- Talent Trees --- */
            await migrateTalentTrees(items, compendium);
        }
        /**
         * Actors
         */
        if (!compendium || compendium.documentName === 'Actor') {
            const actors = await getRawDocumentSources('Actor', packID);
            await migrateActors(actors, compendium);
        }
    },
};
/**
 * Helpers
 */
/**
 * Helper function to process talent trees
 */
async function migrateTalentTrees(items, compendium) {
    // Get all talent tree items
    const talentTreeItems = items.filter((i) => i.type === "talent_tree" /* ItemType.TalentTree */);
    // Migrate talent tree items
    await Promise.all(talentTreeItems.map(async (treeItem) => {
        try {
            const changes = {};
            // Migrate nodes
            await Promise.all(Object.entries(treeItem.system.nodes).map(async ([id, node]) => {
                if (!node.uuid)
                    throw new Error(`Node "${node.id}" is missing required field UUID`);
                // Get the item
                const item = (await fromUuid(node.uuid));
                if (!item?.isTalent())
                    throw new Error(`Could not find talent item "${node.uuid}" referenced by node "${node.id}"`);
                changes[`system.nodes.${id}`] = {
                    id: id,
                    type: "talent" /* TalentTree.Node.Type.Talent */,
                    position: {
                        x: node.position.column * 50 * 2,
                        y: node.position.row * 50 * 2,
                    },
                    talentId: item.system.id,
                    uuid: node.uuid,
                    size: {
                        width: 50,
                        height: 50,
                    },
                    prerequisites: {},
                    connections: {},
                };
            }));
            // Determine width and height
            const width = Math.max(...Object.entries(treeItem.system.nodes).map(([id, node]) => node.position.column)) *
                50 *
                2;
            const height = Math.max(...Object.entries(treeItem.system.nodes).map(([id, node]) => node.position.row)) *
                50 *
                2;
            // Set view bounds
            changes['system.viewBounds'] = {
                x: 0,
                y: 0,
                width: width + 50,
                height: height + 50,
            };
            // Set display size
            changes['system.display'] = {
                width: width + 50,
                height: height + 50,
            };
            // Retrieve document
            const document = await getPossiblyInvalidDocument('Item', treeItem._id, compendium);
            // Apply changes
            document.updateSource(changes, { diff: false });
            await document.update(changes, { diff: false });
            // Ensure invalid documents are properly instantiated
            fixInvalidDocument('Item', document, compendium);
        }
        catch (err) {
            handleDocumentMigrationError(err, 'Item', treeItem);
        }
    }));
}
// NOTE: Use any here as we're dealing with raw actor data
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment */
async function migrateActors(actors, compendium) {
    await Promise.all(actors.map(async (actor) => {
        try {
            const changes = {};
            /**
             * Common Actor Data
             */
            /* --- Movement --- */
            if ('rate' in actor.system.movement) {
                foundry.utils.mergeObject(changes, {
                    ['system.movement.walk.rate']: actor.system.movement.rate,
                    ['system.movement.fly.rate']: 0,
                    ['system.movement.swim.rate']: 0,
                    ['system.movement.-=rate']: null,
                });
            }
            /* --- Damage Immunities --- */
            migrateImmunities(changes, true);
            /* --- Condition Immunities --- */
            migrateImmunities(changes, false);
            /**
             * Character Data
             */
            if (actor.type === "character" /* ActorType.Character */) {
                /* --- Advancement ---*/
                if (!actor.system.level ||
                    isNaN(actor.system.level)) {
                    foundry.utils.mergeObject(changes, {
                        ['system.level']: 1,
                    });
                }
            }
            // Retrieve document
            const document = await getPossiblyInvalidDocument('Actor', actor._id, compendium);
            // Apply changes
            document.updateSource(changes, { diff: false });
            await document.update(changes, { diff: false });
            // Ensure invalid documents are properly instantiated
            fixInvalidDocument('Actor', document, compendium);
        }
        catch (err) {
            handleDocumentMigrationError(err, 'Actor', actor);
        }
    }));
}
/* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment */
/**
 * Helper function for immunities code reuse. Updates the `changes` object
 * according to the requested immunity type
 */
function migrateImmunities(changes, isDamage) {
    const config = isDamage ? COSMERE.damageTypes : COSMERE.statuses;
    foundry.utils.mergeObject(changes, Object.keys(config).reduce((acc, key) => ({
        ...acc,
        [`system.immunities.${isDamage ? 'damage' : 'condition'}.${key}`]: false,
    }), {
        // Note: the key for conditions is mismatched because it was
        // renamed in this version. Damage was unchanged in name.
        [`system.immunities.-=${isDamage ? 'damage' : 'conditions'}`]: null,
    }));
}

var MIGRATE_0_3__1_0 = {
    from: '0.3',
    to: '1.0',
    execute: async (packID) => {
        // Get relevant compendium, if any
        let compendium;
        if (packID) {
            compendium = game.packs?.get(packID);
        }
        /**
         * Items
         */
        if (!compendium || compendium.documentName === 'Item') {
            const items = await getRawDocumentSources('Item', packID);
            await migrateItems(items, compendium);
        }
        /**
         * Embedded Items
         */
        if (!compendium || compendium.documentName === 'Actor') {
            const actors = await getRawDocumentSources('Actor', packID);
            await migrateEmbeddedItems(actors, compendium);
        }
    },
};
/**
 * Helpers
 */
// NOTE: Use any here as we're dealing with raw actor data
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */
async function migrateItems(items, compendium) {
    for (const item of items) {
        try {
            const changes = {};
            migrateItemData(item, changes);
            // Retrieve document
            const document = await getPossiblyInvalidDocument('Item', item._id, compendium);
            // Apply changes
            document.updateSource(changes, { diff: false });
            await document.update(changes, { diff: false });
            // Ensure invalid documents are properly instantiated
            fixInvalidDocument('Item', document, compendium);
        }
        catch (err) {
            handleDocumentMigrationError(err, 'Item', item);
        }
    }
}
async function migrateEmbeddedItems(actors, compendium) {
    for (const actor of actors) {
        if (actor.items.length === 0)
            return;
        try {
            const changes = [];
            for (const item of actor.items) {
                const itemChanges = { _id: item._id };
                migrateItemData(item, itemChanges);
                changes.push(itemChanges);
            }
            // Retrieve document
            const document = await getPossiblyInvalidDocument('Actor', actor._id, compendium);
            // Apply changes
            await document.updateEmbeddedDocuments('Item', changes);
        }
        catch (err) {
            handleDocumentMigrationError(err, 'Actor', actor);
        }
    }
}
function migrateItemData(item, changes) {
    /**
     * Activation
     */
    if ('activation' in item.system) {
        /* --- Consumption Options --- */
        if ('consume' in item.system.activation) {
            // Consumption options can be fully migrated, not migrated
            // at all, or in a halfway state (array, but not a number range).
            // Use AnyObject here to allow us to catch all three cases.
            const consumptionToMigrate = Array.isArray(item.system.activation.consume)
                ? item.system.activation.consume
                : [item.system.activation.consume];
            const newConsumption = consumptionToMigrate
                .filter((consume) => !!consume)
                .map((consume) => {
                const value = {
                    min: 0,
                    max: 0,
                };
                if (consume.value) {
                    if (typeof consume.value === 'object') {
                        if ('min' in consume.value)
                            value.min = consume.value.min;
                        if ('max' in consume.value)
                            value.max = consume.value.max;
                    }
                    else {
                        value.min = consume.value;
                        value.max = consume.value;
                    }
                }
                return {
                    type: consume.type,
                    value,
                    ...(consume.resource
                        ? {
                            resource: consume.resource,
                        }
                        : {}),
                };
            });
            foundry.utils.mergeObject(changes, {
                ['system.activation.consume']: newConsumption,
            });
        }
    }
    if (item.type === 'goal') {
        if ('rewards' in item.system) {
            // Get rewards
            const rewards = item.system.rewards;
            // Set up events
            const events = {};
            // Iterate over rewards
            Object.entries(rewards).forEach(([id, reward]) => {
                if (reward.type === 'items') {
                    events[id] = {
                        id,
                        description: game.i18n.localize('COSMERE.Item.EventSystem.Event.Handler.Types.grant-items.Title'),
                        event: 'goal-complete',
                        handler: {
                            type: 'grant-items',
                            items: reward.items,
                        },
                    };
                }
                else if (reward.type === 'skill-ranks') {
                    events[id] = {
                        id,
                        description: game.i18n.localize('COSMERE.Item.EventSystem.Event.Handler.Types.update-actor.Title'),
                        event: 'goal-complete',
                        handler: {
                            type: 'update-actor',
                            target: 'parent',
                            changes: [
                                {
                                    key: `system.skills.${reward.skill}.rank`,
                                    value: reward.ranks,
                                    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
                                },
                            ],
                            uuid: null,
                        },
                    };
                }
            });
            // Set events
            foundry.utils.mergeObject(changes, {
                ['system.events']: events,
            });
        }
    }
    if (item.type === 'talent') {
        if ('grantRules' in item.system) {
            // Migrate grant rules to event system
            let grantRules = item.system.grantRules;
            if (Array.isArray(grantRules)) {
                grantRules = Object.fromEntries(grantRules.map((rule) => [rule._id, rule]));
            }
            // Prepare the events object
            const events = {};
            // Iterate over grant rules and create events
            Object.entries(grantRules).forEach(([id, rule], i) => {
                events[id] = {
                    id,
                    description: game.i18n.localize('COSMERE.Item.EventSystem.Event.Handler.Types.grant-items.Title'),
                    event: 'add-to-actor',
                    handler: {
                        type: 'grant-items',
                        items: rule.items || [],
                    },
                };
            });
            // Merge the events into the changes
            foundry.utils.mergeObject(changes, {
                ['system.events']: events,
            });
        }
    }
}

// Constants
const EVENTS = [
    // General CRUD operations
    { type: 'create', hook: 'createItem' },
    { type: 'update', hook: 'updateItem' },
    { type: 'delete', hook: 'deleteItem' },
    // Item <-> Actor events
    {
        type: 'add-to-actor',
        hook: 'createItem',
        condition: (_, options) => !!options.parent,
    },
    {
        type: 'remove-from-actor',
        hook: 'deleteItem',
        condition: (_, options) => !!options.parent,
    },
    {
        type: 'equip',
        hook: 'updateItem',
        filter: (item) => item.isEquippable(),
        condition: (_, change) => {
            return (foundry.utils.getProperty(change, 'system.equipped') === true);
        },
    },
    {
        type: 'unequip',
        hook: 'updateItem',
        filter: (item) => item.isEquippable(),
        condition: (_, change) => {
            return (foundry.utils.getProperty(change, 'system.equipped') === false);
        },
    },
    {
        type: 'use',
        hook: HOOKS.USE_ITEM,
        filter: (item) => item.hasActivation(),
    },
    {
        type: 'mode-activate',
        hook: HOOKS.MODE_ACTIVATE_ITEM,
        filter: (item) => item.hasModality(),
    },
    {
        type: 'mode-deactivate',
        hook: HOOKS.MODE_DEACTIVATE_ITEM,
        filter: (item) => item.hasModality(),
    },
    {
        type: 'goal-complete',
        hook: HOOKS.COMPLETE_GOAL,
        filter: (item) => item.isGoal(),
    },
    {
        type: 'goal-progress',
        hook: HOOKS.PROGRESS_GOAL,
        filter: (item) => item.isGoal(),
    },
    // General Actor events
    { type: 'update-actor', hook: 'updateActor' },
    {
        type: 'apply-damage-actor',
        hook: HOOKS.APPLY_DAMAGE,
        transform: (actor) => ({ document: actor }),
    },
    {
        type: 'apply-injury-actor',
        hook: HOOKS.APPLY_INJURY,
        transform: (actor) => ({ document: actor }),
    },
    {
        type: 'short-rest-actor',
        hook: HOOKS.REST,
        condition: (_, duration) => duration === "short" /* RestType.Short */,
        transform: (actor) => ({ document: actor }),
    },
    {
        type: 'long-rest-actor',
        hook: HOOKS.REST,
        condition: (_, duration) => duration === "long" /* RestType.Long */,
        transform: (actor) => ({ document: actor }),
    },
];
function registerEventTypes() {
    EVENTS.forEach(({ type, hook, host, filter, condition, transform }) => {
        cosmereRPG.api.registerItemEventType({
            source: SYSTEM_ID,
            type,
            hook,
            host,
            filter,
            condition,
            transform,
            label: `COSMERE.Item.EventSystem.Event.Types.${type}.Label`,
            description: `COSMERE.Item.EventSystem.Event.Types.${type}.Description`,
        });
    });
}

class PickDialog extends ComponentHandlebarsApplicationMixin((foundry.applications.api.ApplicationV2)) {
    data;
    resolve;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            resizable: false,
            title: 'DIALOG.PickDialog.Title',
        },
        classes: ['dialog', 'pick-dialog'],
        tag: 'dialog',
        position: {
            width: 300,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_PICK}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    submitted = false;
    constructor(data, resolve) {
        super({
            window: {
                title: data.title,
            },
        });
        this.data = data;
        this.resolve = resolve;
    }
    /* --- Statics --- */
    static show(data) {
        return new Promise((resolve) => {
            const dialog = new this(data, resolve);
            void dialog.render(true);
        });
    }
    /* --- Actions --- */
    static onFormEvent(event, form, formData) {
        if (!(event instanceof SubmitEvent))
            return;
        // Get choice
        const choice = formData.get('choice');
        // Resolve with choice
        this.resolve(choice ?? null);
        // Mark as submitted
        this.submitted = true;
        // Close dialog
        void this.close();
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    _onClose() {
        if (!this.submitted)
            this.resolve(null);
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            ...this.data,
        });
    }
}

function register$j() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "grant-items" /* HandlerType.GrantItems */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.Description`,
        config: {
            schema: {
                allowDuplicates: new foundry.data.fields.BooleanField({
                    required: true,
                    initial: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.AllowDuplicates.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.AllowDuplicates.Hint`,
                }),
                increaseQuantity: new foundry.data.fields.BooleanField({
                    required: true,
                    initial: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.IncreaseQuantity.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.IncreaseQuantity.Hint`,
                }),
                pickOne: new foundry.data.fields.BooleanField({
                    required: false,
                    initial: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.PickOne.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.PickOne.Hint`,
                }),
                pickPromptTitle: new foundry.data.fields.StringField({
                    required: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.PickPromptTitle.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.PickPromptTitle.Hint`,
                }),
                notify: new foundry.data.fields.BooleanField({
                    required: false,
                    initial: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.Notify.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.Notify.Hint`,
                }),
                items: new foundry.data.fields.ArrayField(new foundry.data.fields.SchemaField({
                    uuid: new foundry.data.fields.DocumentUUIDField({
                        type: 'Item',
                    }),
                    quantity: new foundry.data.fields.StringField({
                        required: false,
                    }),
                }), {
                    required: true,
                    initial: [],
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.Items.Label`,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_GRANT_ITEMS}`,
        },
        executor: async function (event) {
            if (!event.item.actor)
                return;
            // Get the actor
            const actor = event.item.actor;
            // Get the items to grant
            let items = (await Promise.all(this.items.map(({ uuid }) => fromUuid(uuid))))
                .filter((v) => !!v)
                .filter((item, i, self) => {
                if (this.allowDuplicates)
                    return true;
                if (self.findIndex((o) => areSameItems(item, o, true)) !== i)
                    return false;
                return ((item.isPhysical() && this.increaseQuantity) ||
                    !actor.items.some((other) => areSameItems(item, other, true)));
            });
            // Construct map of quantities by UUID
            const quantities = await this.items.reduce(async (prev, ref) => {
                const acc = await prev;
                // Get the quantity to grant
                const quantityFormula = ref.quantity ?? '1';
                // Resolve quantity
                let quantity = parseInt(await tryApplyRollData(actor, quantityFormula, true));
                if (isNaN(quantity) || quantity < 1)
                    quantity = 1;
                return {
                    ...acc,
                    [ref.uuid]: quantity,
                };
            }, Promise.resolve({}));
            if (this.pickOne) {
                const picked = await PickDialog.show({
                    title: 
                    // NOTE: Use logical OR to provide a default title if field is empty string
                    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                    this.pickPromptTitle ||
                        game.i18n.localize(`COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-items" /* HandlerType.GrantItems */}.PickPromptTitle.Default`),
                    options: items.map((item) => ({
                        id: item.uuid,
                        label: `<span>${item.name}${item.isPhysical() ? ` <span style="font-size:.65em;opacity:.65;">x${quantities[item.uuid]}</span>` : ''}</span>`,
                    })),
                });
                if (!picked)
                    return;
                // Filter items to only the picked item
                items = items.filter((item) => item.uuid === picked);
            }
            // Split out the physical items
            const physicalItems = items.filter((item) => item.isPhysical());
            const nonPhysicalItems = items.filter((item) => !item.isPhysical());
            const documentUpdates = [];
            const documentsToCreate = [];
            // Handle physical items
            physicalItems.forEach((item) => {
                const quantity = quantities[item.uuid];
                // Find the existing item in the actor
                const existingItem = actor.items.find((other) => areSameItems(item, other, true));
                // If the item already exists and we're increasing the quantity, update it, otherwise create a new item
                if (this.increaseQuantity && existingItem) {
                    documentUpdates.push({
                        _id: existingItem.id,
                        'system.quantity': Math.max(existingItem.system.quantity + quantity, 1),
                    });
                }
                else {
                    const itemData = foundry.utils.mergeObject(item.toObject(), {
                        'system.quantity': quantity,
                    });
                    if (event.item.hasRelationships() &&
                        item.hasRelationships()) {
                        ItemRelationshipUtils.addRelationshipData(itemData, event.item, ItemRelationship.Type.Parent);
                    }
                    // Create a new item
                    documentsToCreate.push(itemData);
                }
            });
            // Handle non-physical items (always create new items)
            nonPhysicalItems.forEach((item) => {
                const itemData = item.toObject();
                if (event.item.hasRelationships() && item.hasRelationships()) {
                    ItemRelationshipUtils.addRelationshipData(itemData, event.item, ItemRelationship.Type.Parent);
                }
                documentsToCreate.push(itemData);
            });
            // Grant the items to the actor
            await Promise.all([
                actor.updateEmbeddedDocuments('Item', documentUpdates, event.op),
                actor.createEmbeddedDocuments('Item', documentsToCreate, event.op),
            ]);
            // Notify the user if enabled
            if (this.notify !== false) {
                items.forEach((item) => {
                    ui.notifications.info(game.i18n.format('GENERIC.Notification.AddedItem', {
                        item: item.name,
                        quantity: item.isPhysical() && quantities[item.uuid] > 1
                            ? ` (x${quantities[item.uuid]})`
                            : '',
                        actor: actor.name,
                    }));
                });
            }
        },
    });
}
/* --- Helpers --- */
function areSameItems(a, b, matchName = false) {
    if (a === b)
        return true;
    if (a.type !== b.type)
        return false;
    return a.hasId() && b.hasId()
        ? a.system.id === b.system.id
        : matchName
            ? a.name === b.name
            : a.id === b.id;
}

// Constants
function register$i() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "remove-items" /* HandlerType.RemoveItems */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"remove-items" /* HandlerType.RemoveItems */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"remove-items" /* HandlerType.RemoveItems */}.Description`,
        config: {
            schema: {
                reduceQuantity: new foundry.data.fields.BooleanField({
                    required: true,
                    initial: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"remove-items" /* HandlerType.RemoveItems */}.ReduceQuantity.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"remove-items" /* HandlerType.RemoveItems */}.ReduceQuantity.Hint`,
                }),
                amount: new foundry.data.fields.NumberField({
                    required: true,
                    initial: 1,
                    min: 1,
                    integer: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"remove-items" /* HandlerType.RemoveItems */}.Amount.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"remove-items" /* HandlerType.RemoveItems */}.Amount.Hint`,
                }),
                items: new foundry.data.fields.ArrayField(new foundry.data.fields.DocumentUUIDField({
                    type: 'Item',
                }), {
                    required: true,
                    initial: [],
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"remove-items" /* HandlerType.RemoveItems */}.Items.Label`,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_REMOVE_ITEMS}`,
        },
        executor: async function (event) {
            if (!event.item.actor)
                return;
            // Get the actor
            const actor = event.item.actor;
            // Get the items to remove
            const referenceItems = (await Promise.all(this.items.map((uuid) => fromUuid(uuid))))
                .filter((v) => !!v)
                .filter((item, i, self) => self.findIndex((o) => item.type === o.type &&
                (item.hasId() && o.hasId()
                    ? item.system.id === o.system.id
                    : item.name === o.name)) === i);
            const itemUpdates = [];
            const itemRemovals = [];
            referenceItems.forEach((item) => {
                // Try to find a matching item on the actor
                const matchingItem = actor.items.find((o) => item.type === o.type &&
                    (item.hasId() && o.hasId()
                        ? item.system.id === o.system.id
                        : item.name === o.name));
                if (!matchingItem)
                    return;
                if (this.reduceQuantity && matchingItem.isPhysical()) {
                    // Calculate the new quantity
                    const newQuantity = Math.max(matchingItem.system.quantity - this.amount, 0);
                    // If the new quantity is 0, remove the item
                    if (newQuantity === 0) {
                        itemRemovals.push(matchingItem.id);
                    }
                    else {
                        // Otherwise, update the item quantity
                        itemUpdates.push({
                            _id: matchingItem.id,
                            'system.quantity': newQuantity,
                        });
                    }
                }
                else {
                    // Remove the item outright
                    itemRemovals.push(matchingItem.id);
                }
            });
            // Remove the items from the actor
            await Promise.all([
                actor.deleteEmbeddedDocuments('Item', itemRemovals, event.op),
                actor.updateEmbeddedDocuments('Item', itemUpdates, event.op),
            ]);
        },
    });
}

// Constants
function register$h() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "modify-attribute" /* HandlerType.ModifyAttribute */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-attribute" /* HandlerType.ModifyAttribute */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-attribute" /* HandlerType.ModifyAttribute */}.Description`,
        config: {
            schema: {
                attribute: new foundry.data.fields.StringField({
                    required: true,
                    blank: false,
                    initial: () => Object.keys(CONFIG.COSMERE.attributes)[0],
                    choices: () => Object.entries(CONFIG.COSMERE.attributes)
                        .map(([attrId, config]) => [attrId, config.label])
                        .reduce((acc, [key, value]) => ({
                        ...acc,
                        [key]: value,
                    }), {}),
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-attribute" /* HandlerType.ModifyAttribute */}.Attribute.Label`,
                }),
                amount: new foundry.data.fields.NumberField({
                    required: true,
                    initial: 1,
                    integer: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-attribute" /* HandlerType.ModifyAttribute */}.Amount.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-attribute" /* HandlerType.ModifyAttribute */}.Amount.Hint`,
                }),
                bonus: new foundry.data.fields.BooleanField({
                    required: true,
                    initial: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-attribute" /* HandlerType.ModifyAttribute */}.Bonus.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-attribute" /* HandlerType.ModifyAttribute */}.Bonus.Hint`,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_MODIFY_ATTRIBUTE}`,
        },
        executor: async function (event) {
            if (!event.item.actor)
                return;
            if (this.amount === 0)
                return;
            // Get the actor
            const actor = event.item.actor;
            // Modify the attribute
            await actor.update({
                [`system.attributes.${this.attribute}`]: {
                    [this.bonus ? 'bonus' : 'value']: actor.system.attributes[this.attribute][this.bonus ? 'bonus' : 'value'] + this.amount,
                },
            }, event.op);
        },
    });
}

// Constants
function register$g() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "set-attribute" /* HandlerType.SetAttribute */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-attribute" /* HandlerType.SetAttribute */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-attribute" /* HandlerType.SetAttribute */}.Description`,
        config: {
            schema: {
                attribute: new foundry.data.fields.StringField({
                    required: true,
                    blank: false,
                    initial: () => Object.keys(CONFIG.COSMERE.attributes)[0],
                    choices: () => Object.entries(CONFIG.COSMERE.attributes)
                        .map(([attrId, config]) => [attrId, config.label])
                        .reduce((acc, [key, value]) => ({
                        ...acc,
                        [key]: value,
                    }), {}),
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-attribute" /* HandlerType.SetAttribute */}.Attribute.Label`,
                }),
                value: new foundry.data.fields.NumberField({
                    required: true,
                    initial: 1,
                    integer: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-attribute" /* HandlerType.SetAttribute */}.Value.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-attribute" /* HandlerType.SetAttribute */}.Value.Hint`,
                }),
                bonus: new foundry.data.fields.BooleanField({
                    required: true,
                    initial: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-attribute" /* HandlerType.SetAttribute */}.Bonus.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-attribute" /* HandlerType.SetAttribute */}.Bonus.Hint`,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_SET_ATTRIBUTE}`,
        },
        executor: async function (event) {
            if (!event.item.actor)
                return;
            // Get the actor
            const actor = event.item.actor;
            // Modify the attribute
            await actor.update({
                [`system.attributes.${this.attribute}`]: {
                    [this.bonus ? 'bonus' : 'value']: this.value,
                },
            }, event.op);
        },
    });
}

// Constants
function register$f() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "modify-skill-rank" /* HandlerType.ModifySkillRank */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-skill-rank" /* HandlerType.ModifySkillRank */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-skill-rank" /* HandlerType.ModifySkillRank */}.Description`,
        config: {
            schema: {
                skill: new foundry.data.fields.StringField({
                    required: true,
                    blank: false,
                    initial: () => Object.keys(CONFIG.COSMERE.skills)[0],
                    choices: () => Object.entries(CONFIG.COSMERE.skills)
                        .map(([skillId, config]) => [skillId, config.label])
                        .reduce((acc, [key, value]) => ({
                        ...acc,
                        [key]: value,
                    }), {}),
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-skill-rank" /* HandlerType.ModifySkillRank */}.Skill.Label`,
                }),
                amount: new foundry.data.fields.NumberField({
                    required: true,
                    initial: 1,
                    integer: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-skill-rank" /* HandlerType.ModifySkillRank */}.Amount.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"modify-skill-rank" /* HandlerType.ModifySkillRank */}.Amount.Hint`,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_MODIFY_SKILL_RANK}`,
        },
        executor: async function (event) {
            if (!event.item.actor)
                return;
            if (this.amount === 0)
                return;
            // Get the actor
            const actor = event.item.actor;
            // Modify the skill rank
            await actor.update({
                [`system.skills.${this.skill}.rank`]: actor.system.skills[this.skill].rank + this.amount,
            }, event.op);
        },
    });
}

// Constants
function register$e() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "set-skill-rank" /* HandlerType.SetSkillRank */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-skill-rank" /* HandlerType.SetSkillRank */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-skill-rank" /* HandlerType.SetSkillRank */}.Description`,
        config: {
            schema: {
                skill: new foundry.data.fields.StringField({
                    required: true,
                    blank: false,
                    initial: () => Object.keys(CONFIG.COSMERE.skills)[0],
                    choices: () => Object.entries(CONFIG.COSMERE.skills)
                        .map(([skillId, config]) => [skillId, config.label])
                        .reduce((acc, [key, value]) => ({
                        ...acc,
                        [key]: value,
                    }), {}),
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-skill-rank" /* HandlerType.SetSkillRank */}.Skill.Label`,
                }),
                value: new foundry.data.fields.NumberField({
                    required: true,
                    initial: 1,
                    integer: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-skill-rank" /* HandlerType.SetSkillRank */}.Value.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"set-skill-rank" /* HandlerType.SetSkillRank */}.Value.Hint`,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_SET_SKILL_RANK}`,
        },
        executor: async function (event) {
            if (!event.item.actor)
                return;
            if (this.value === 0)
                return;
            // Get the actor
            const actor = event.item.actor;
            // Set the skill rank
            await actor.update({
                [`system.skills.${this.skill}.rank`]: this.value,
            }, event.op);
        },
    });
}

const { ApplicationV2: ApplicationV2$c, HandlebarsApplicationMixin: HandlebarsApplicationMixin$9 } = foundry.applications.api;
class EditExpertisesDialog extends HandlebarsApplicationMixin$9((ApplicationV2$c)) {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            positioned: true,
        },
        classes: ['edit-expertises', 'dialog'],
        tag: 'dialog',
        position: {
            width: 300,
            height: 800,
        },
        /**
         * NOTE: Unbound methods is the standard for defining actions and forms
         * within ApplicationV2
         */
        /* eslint-disable @typescript-eslint/unbound-method */
        actions: {
            'add-custom-expertise': this.onAddCustomExpertise,
            'remove-custom-expertise': this.onRemoveCustomExpertise,
            'update-expertises': this.onSave,
        },
        /* eslint-enable @typescript-eslint/unbound-method */
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_EDIT_EXPERTISES}`,
            scrollable: [''],
            // See note above
            /* eslint-disable @typescript-eslint/unbound-method */
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
            /* eslint-enable @typescript-eslint/unbound-method */
        },
    });
    data;
    updater;
    liveUpdate;
    availableTypes;
    submitButtonLabel;
    maxExpertises;
    resolve;
    constructor(config) {
        super({
            id: config.id ?? '{id}',
            window: {
                title: config.title ?? 'COSMERE.Actor.Sheet.EditExpertises',
            },
        });
        this.data = config.data;
        this.resolve = config.resolve;
        this.updater = config.updater;
        this.liveUpdate = config.liveUpdate ?? false;
        this.availableTypes =
            config.types ??
                new Set(Object.keys(CONFIG.COSMERE.expertiseTypes));
        this.submitButtonLabel =
            config.submitButtonLabel ?? 'GENERIC.Button.Update';
        this.maxExpertises = config.maxExpertises;
    }
    static show(...args) {
        // Init config from args
        const config = args[0] instanceof CosmereActor
            ? { actor: args[0] }
            : args[0] instanceof foundry.abstract.Document
                ? {
                    document: args[0],
                    fieldPath: args[1],
                }
                : args[0];
        // Validate field path if required
        if ('document' in config) {
            const field = config.document.schema.getField(config.fieldPath);
            // Ensure field is correct type
            if (!(field instanceof ExpertisesField)) {
                throw new Error(`Field "${config.fieldPath}" is not a valid ExpertisesField`);
            }
        }
        // Get data
        const data = 'actor' in config
            ? config.actor.system.expertises
            : 'document' in config
                ? foundry.utils.getProperty(config.document, config.fieldPath)
                : config.data;
        // Determine the id
        const id = 'actor' in config
            ? `${config.actor.uuid}.system.expertises`
            : 'document' in config
                ? `${config.document.uuid}.${config.fieldPath}`
                : undefined;
        // Determine the updater
        const updater = 'actor' in config
            ? (data) => this.updateDocument(config.actor, 'system.expertises', data)
            : 'document' in config
                ? (data) => this.updateDocument(config.document, config.fieldPath, data)
                : config.updater;
        // Show the dialog
        return new Promise((resolve) => {
            const dialog = new EditExpertisesDialog({
                data: cloneCollection(data),
                resolve,
                id,
                liveUpdate: config.liveUpdate ??
                    ('actor' in config || 'document' in config),
                updater,
                title: config.title,
                submitButtonLabel: config.submitButtonLabel,
                types: config.types,
                maxExpertises: config.maxExpertises,
            });
            void dialog.render(true);
        });
    }
    static updateDocument(document, fieldPath, data) {
        // Get changes
        const changes = getObjectChanges(foundry.utils.getProperty(document, fieldPath).toJSON(), data.toJSON());
        // Update the document
        void document.update({
            [fieldPath]: changes,
        });
    }
    /* --- Accessors --- */
    get shouldUpdateSource() {
        return !!this.updater;
    }
    /* --- Actions --- */
    static onRemoveCustomExpertise(event) {
        // Get action element
        const actionElement = $(event.target).closest('[data-action]');
        // Get id and type
        const id = actionElement.data('id');
        const type = actionElement.data('category');
        // Remove the expertise
        this.data.delete(Expertise.getKey({ type, id }));
        // Update the source, if applicable
        if (this.liveUpdate) {
            this.preformSourceUpdate();
        }
        // Remove
        $(event.target).closest('li').remove();
    }
    static onAddCustomExpertise(event) {
        if (this.maxExpertises !== undefined &&
            this.data.size >= this.maxExpertises) {
            return void ui.notifications.warn(game.i18n.format('DIALOG.EditExpertise.Warning.MaxExpertises', {
                max: this.maxExpertises,
            }));
        }
        // Look up the category
        const category = $(event.target)
            .closest('[data-category]')
            .data('category');
        // Generate element
        const el = $(`
            <li id="temp-custom" class="form-group custom temp">                
                <i class="bullet fade icon faded fa-solid fa-diamond"></i>
                <input type="text" placeholder="${game.i18n.localize('DIALOG.EditExpertise.AddPlaceholder')}">
                <a><i class="fa-solid fa-trash"></i></a>
            </li>
        `).get(0);
        // Insert element
        $(event.target).closest('li').before(el);
        // Find input element
        const inputEl = $(el).find('input');
        // Focus
        inputEl.trigger('focus');
        inputEl.on('focusout', () => {
            const val = inputEl.val();
            if (val) {
                const label = val;
                const id = val.toLowerCase();
                // Initialize expertise
                const expertise = new Expertise({
                    id,
                    type: category,
                    label,
                });
                if (!expertise.isCustom ||
                    containsExpertise(this.data, expertise)) {
                    ui.notifications.warn(game.i18n.localize('GENERIC.Warning.NoDuplicateExpertises'));
                }
                else {
                    // Add expertise
                    this.data.set(expertise.key, expertise);
                    // Update the source, if applicable
                    if (this.liveUpdate) {
                        this.preformSourceUpdate();
                    }
                    // Render
                    void this.render();
                }
            }
            // Clean up
            inputEl.off('focusout');
            el.remove();
        });
        inputEl.on('keypress', (event) => {
            if (event.which !== 13)
                return; // Enter key
            event.preventDefault();
            event.stopPropagation();
            inputEl.trigger('focusout');
        });
    }
    static onSave(event) {
        if (this.liveUpdate)
            return;
        // Close the dialog
        void this.close();
        if (this.shouldUpdateSource) {
            this.preformSourceUpdate();
            this.resolve();
        }
        else {
            // Resolve the promise
            this.resolve(this.data);
        }
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        event.preventDefault();
        const expertisesKeys = Object.keys(formData.object).filter((key) => !!formData.object[key]);
        // Determine added expertises
        const addedExpertises = expertisesKeys.filter((key) => !this.data.has(key));
        // Determine removed expertises
        const removedExpertises = Array.from(this.data.keys()).filter((key) => !expertisesKeys.includes(key));
        // Ensure the maximum number of expertises is not exceeded
        if (this.maxExpertises !== undefined &&
            this.data.size + addedExpertises.length - removedExpertises.length >
                this.maxExpertises) {
            ui.notifications.warn(game.i18n.format('DIALOG.EditExpertise.Warning.MaxExpertises', {
                max: this.maxExpertises,
            }));
            // Re-render
            return void this.render();
        }
        // Add new expertises
        addedExpertises.forEach((key) => {
            const [type, id] = key.split(':');
            this.data.set(key, new Expertise({
                id,
                type,
                label: typeof formData.object[key] === 'string'
                    ? formData.object[key]
                    : null,
            }));
        });
        // Remove expertises
        removedExpertises.forEach((key) => {
            this.data.delete(key);
        });
        if (this.liveUpdate) {
            this.preformSourceUpdate();
        }
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            showSubmitButton: !this.liveUpdate,
            submitButtonLabel: this.submitButtonLabel,
            categories: this.availableTypes.map((type) => {
                const config = CONFIG.COSMERE.expertiseTypes[type];
                return {
                    type,
                    label: config.label,
                    icon: config.icon,
                    configuredExpertises: this.getConfiguredExpertisesForType(type),
                    customExpertises: this.getCustomExpertisesForType(type),
                };
            }),
        });
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
        $(this.element)
            .find('input')
            .on('keypress', (event) => {
            if (event.which !== 13)
                return; // Enter key
            event.preventDefault();
            event.stopPropagation();
            $(event.target).trigger('blur');
        });
    }
    _onClose(options) {
        super._onClose(options);
        // Resolve the promise
        this.resolve(this.shouldUpdateSource ? void 0 : this.data);
    }
    /* --- Helpers --- */
    preformSourceUpdate() {
        void this.updater?.(this.data);
    }
    getConfiguredExpertisesForType(type) {
        // Get the registry key
        const registryKey = CONFIG.COSMERE.expertiseTypes[type].configRegistryKey;
        if (!registryKey)
            return [];
        return Object.entries(CONFIG.COSMERE[registryKey]).map(([id, config]) => ({
            id,
            ...config,
            hasExpertise: containsExpertise(this.data, type, id),
            locked: this.data.get(id)?.locked ?? false,
        }));
    }
    getCustomExpertisesForType(type) {
        return this.data.filter((expertise) => expertise.type === type && !!expertise.isCustom);
    }
}

// Fields
function register$d() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "grant-expertises" /* HandlerType.GrantExpertises */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.Description`,
        config: {
            schema: {
                pick: new foundry.data.fields.BooleanField({
                    required: false,
                    initial: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.Pick.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.Pick.Hint`,
                }),
                pickAmount: new foundry.data.fields.NumberField({
                    required: false,
                    initial: 1,
                    min: 1,
                    integer: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.PickAmount.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.PickAmount.Hint`,
                }),
                expertises: new ExpertisesField({
                    required: true,
                }),
                allowReplacement: new foundry.data.fields.BooleanField({
                    required: false,
                    initial: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.AllowReplacement.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.AllowReplacement.Hint`,
                }),
                availableTypes: new foundry.data.fields.SetField(new foundry.data.fields.StringField({
                    blank: false,
                    choices: () => Object.entries(CONFIG.COSMERE.expertiseTypes).reduce((acc, [key, config]) => ({
                        ...acc,
                        [key]: config.label,
                    }), {}),
                }), {
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.AvailableTypes.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.AvailableTypes.Hint`,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_GRANT_EXPERTISES}`,
        },
        executor: async function (event) {
            if (!event.item.actor)
                return;
            // Get the actor
            const actor = event.item.actor;
            let expertises;
            if (this.pick) {
                const result = await EditExpertisesDialog.show({
                    data: new RecordCollection(),
                    types: this.availableTypes.size > 0
                        ? this.availableTypes
                        : undefined,
                    maxExpertises: this.pickAmount ?? 1,
                    title: game.i18n.format(`COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.PickDialog.Title`, {
                        amount: this.pickAmount ?? 1,
                    }),
                    submitButtonLabel: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.PickDialog.Button`,
                });
                if (!result || result.size === 0)
                    return;
                // If the user picked expertises, use those
                expertises = Array.from(result.values());
            }
            else {
                // Get the expertises to grant, replacing any that the actor already has if allowed
                expertises = await this.expertises.reduce(async (prev, expertise) => {
                    const acc = await prev;
                    const hasExpertise = actor.hasExpertise(expertise);
                    if (hasExpertise && this.allowReplacement) {
                        const result = await EditExpertisesDialog.show({
                            data: new RecordCollection(),
                            types: this.availableTypes.size > 0
                                ? this.availableTypes
                                : undefined,
                            maxExpertises: 1,
                            title: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.ReplaceExpertise.Title`,
                            submitButtonLabel: `COSMERE.Item.EventSystem.Event.Handler.Types.${"grant-expertises" /* HandlerType.GrantExpertises */}.ReplaceExpertise.Button`,
                        });
                        if (!result || result.size === 0)
                            return acc;
                        // If the user chose a replacement, use that instead
                        const replacement = Array.from(result.values())[0];
                        acc.push(replacement);
                    }
                    else if (!hasExpertise) {
                        // Add the expertise to the list
                        acc.push(expertise);
                    }
                    return acc;
                }, Promise.resolve([]));
            }
            if (expertises.length === 0)
                return;
            // Grant the expertises
            await actor.update({
                'system.expertises': expertises.reduce((acc, expertise) => ({
                    ...acc,
                    [expertise.key]: expertise.toObject(),
                }), {}),
            }, event.op);
        },
    });
}

// Fields
function register$c() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "remove-expertises" /* HandlerType.RemoveExpertises */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"remove-expertises" /* HandlerType.RemoveExpertises */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"remove-expertises" /* HandlerType.RemoveExpertises */}.Description`,
        config: {
            schema: {
                expertises: new ExpertisesField({
                    required: true,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_REMOVE_EXPERTISES}`,
        },
        executor: async function (event) {
            if (!event.item.actor)
                return;
            if (this.expertises.size === 0)
                return;
            // Get the actor
            const actor = event.item.actor;
            // Get the expertises to grant (filter out any the actor already has)
            const expertises = this.expertises.filter((expertise) => actor.hasExpertise(expertise));
            // Remove the expertises
            await actor.update({
                'system.expertises': expertises.reduce((acc, expertise) => ({
                    ...acc,
                    [`-=${expertise.key}`]: expertise.toObject(),
                }), {}),
            }, event.op);
        },
    });
}

async function matchItems(item, target, uuid, matchMode, matchAll) {
    if (target === "self" /* ItemTarget.Self */) {
        return [item];
    }
    else if (target === "sibling" /* ItemTarget.Sibling */ && item.actor && uuid) {
        // Look up the reference item from uuid
        const referenceItem = (await fromUuid(uuid));
        if (!referenceItem)
            return [];
        const siblings = item.actor.items;
        // Determine the match mode
        matchMode =
            matchMode === "identifier" /* MatchMode.Identifier */ && !referenceItem.hasId()
                ? "name" /* MatchMode.Name */
                : matchMode;
        // Get the matcher function
        const matcher = matchMode === "identifier" /* MatchMode.Identifier */
            ? getIdentifierMatcher(referenceItem)
            : matchMode === "name" /* MatchMode.Name */
                ? getNameMatcher(referenceItem)
                : getUUIDMatcher(referenceItem);
        // Get the items to update
        return matchAll
            ? siblings.filter(matcher)
            : [siblings.find(matcher)].filter((item) => !!item);
    }
    else if (target === "equipped-weapon" /* ItemTarget.EquippedWeapon */ && item.actor) {
        const condition = (item) => item.isWeapon() && item.system.equipped;
        return matchAll
            ? item.actor.items.filter(condition)
            : [
                item.actor.items.filter(condition)
                    .sort(compareWeaponEquipType)
                    .find(() => true),
            ].filter((item) => !!item);
    }
    else if (target === "equipped-armor" /* ItemTarget.EquippedArmor */ && item.actor) {
        const condition = (item) => item.isArmor() && item.system.equipped;
        return matchAll
            ? item.actor.items.filter(condition)
            : [item.actor.items.find(condition)].filter((item) => !!item);
    }
    else if (target === "global" /* ItemTarget.Global */ && uuid) {
        // Look up the target item from uuid
        return [(await fromUuid(uuid))].filter((item) => !!item);
    }
    else {
        throw new Error('Invalid target');
    }
}
function getIdentifierMatcher(referenceItem) {
    return (item) => item.hasId() && item.system.id === referenceItem.system.id;
}
function getNameMatcher(referenceItem) {
    return (item) => item.name === referenceItem.name;
}
function getUUIDMatcher(referenceItem) {
    return (item) => item.uuid === referenceItem.uuid;
}
function compareWeaponEquipType(a, b) {
    const holdA = a.system.equip.hold;
    const holdB = b.system.equip.hold;
    if (holdA === "two_handed" /* HoldType.TwoHanded */)
        return -1;
    if (holdB === "two_handed" /* HoldType.TwoHanded */)
        return 1;
    const handA = a.system.equip.hand;
    const handB = b.system.equip.hand;
    if (handA === "main_hand" /* EquipHand.Main */ && handB === "off_hand" /* EquipHand.Off */)
        return -1;
    if (handA === "off_hand" /* EquipHand.Off */ && handB === "main_hand" /* EquipHand.Main */)
        return 1;
    return 0;
}

function register$b() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "use-item" /* HandlerType.UseItem */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"use-item" /* HandlerType.UseItem */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"use-item" /* HandlerType.UseItem */}.Description`,
        config: {
            schema: {
                target: new foundry.data.fields.StringField({
                    choices: {
                        ["self" /* ItemTarget.Self */]: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Choices.${"self" /* ItemTarget.Self */}`,
                        ["sibling" /* ItemTarget.Sibling */]: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Choices.${"sibling" /* ItemTarget.Sibling */}`,
                        ["equipped-weapon" /* ItemTarget.EquippedWeapon */]: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Choices.${"equipped-weapon" /* ItemTarget.EquippedWeapon */}`,
                        ["equipped-armor" /* ItemTarget.EquippedArmor */]: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Choices.${"equipped-armor" /* ItemTarget.EquippedArmor */}`,
                        ["global" /* ItemTarget.Global */]: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Choices.${"global" /* ItemTarget.Global */}`,
                    },
                    initial: "sibling" /* ItemTarget.Sibling */,
                    required: true,
                    blank: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Label`,
                }),
                uuid: new foundry.data.fields.DocumentUUIDField({
                    type: 'Item',
                    initial: null,
                    nullable: true,
                    label: 'Item',
                }),
                matchMode: new foundry.data.fields.StringField({
                    nullable: true,
                    initial: "identifier" /* MatchMode.Identifier */,
                    choices: {
                        ["identifier" /* MatchMode.Identifier */]: `COSMERE.Item.EventSystem.Event.Handler.General.MatchMode.Choices.${"identifier" /* MatchMode.Identifier */}`,
                        ["name" /* MatchMode.Name */]: `COSMERE.Item.EventSystem.Event.Handler.General.MatchMode.Choices.${"name" /* MatchMode.Name */}`,
                        ["uuid" /* MatchMode.UUID */]: `COSMERE.Item.EventSystem.Event.Handler.General.MatchMode.Choices.${"uuid" /* MatchMode.UUID */}`,
                    },
                    label: `COSMERE.Item.EventSystem.Event.Handler.General.MatchMode.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.General.MatchMode.Hint`,
                }),
                matchAll: new foundry.data.fields.BooleanField({
                    initial: false,
                    nullable: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.General.MatchAll.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.General.MatchAll.Hint`,
                }),
                fastForward: new foundry.data.fields.BooleanField({
                    initial: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"use-item" /* HandlerType.UseItem */}.FastForward.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"use-item" /* HandlerType.UseItem */}.FastForward.Hint`,
                }),
                advantageMode: new foundry.data.fields.StringField({
                    initial: AdvantageMode.None,
                    choices: {
                        [AdvantageMode.None]: `DICE.AdvantageMode.None`,
                        [AdvantageMode.Advantage]: `DICE.AdvantageMode.Advantage`,
                        [AdvantageMode.Disadvantage]: `DICE.AdvantageMode.Disadvantage`,
                    },
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"use-item" /* HandlerType.UseItem */}.AdvantageMode.Label`,
                }),
                plotDie: new foundry.data.fields.BooleanField({
                    initial: false,
                    label: 'DICE.Plot.RaiseTheStakes',
                }),
                temporaryModifiers: new foundry.data.fields.StringField({
                    initial: '',
                    label: `DICE.TemporaryBonus.Label`,
                    hint: `DICE.TemporaryBonus.Hint`,
                }),
                temporaryDamageModifiers: new foundry.data.fields.StringField({
                    initial: '',
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"use-item" /* HandlerType.UseItem */}.TemporaryDamageModifiers.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.Types.${"use-item" /* HandlerType.UseItem */}.TemporaryDamageModifiers.Hint`,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_USE_ITEM}`,
        },
        executor: async function (event) {
            if (!event.item.actor &&
                (this.target === "sibling" /* ItemTarget.Sibling */ ||
                    this.target === "equipped-weapon" /* ItemTarget.EquippedWeapon */ ||
                    this.target === "equipped-armor" /* ItemTarget.EquippedArmor */))
                return;
            if (!this.uuid &&
                (this.target === "sibling" /* ItemTarget.Sibling */ ||
                    this.target === "global" /* ItemTarget.Global */))
                return;
            if (this.target === "self" /* ItemTarget.Self */ && event.type === 'use')
                return;
            // Get the item(s) to use
            const itemsToUse = await matchItems(event.item, this.target, this.uuid ?? null, this.matchMode ?? "identifier" /* MatchMode.Identifier */, this.matchAll ?? false);
            const configurable = !this.fastForward || (event.options?.configurable ?? true);
            const advantageMode = this.advantageMode && this.advantageMode !== AdvantageMode.None
                ? this.advantageMode
                : (event.options?.advantageMode ?? AdvantageMode.None);
            const plotDie = this.plotDie || !!event.options?.plotDie;
            await Promise.all(itemsToUse.map((item) => item.use({
                configurable,
                advantageMode,
                plotDie,
                temporaryModifiers: this.temporaryModifiers,
                ...(item.hasDamage()
                    ? {
                        damage: {
                            overrideFormula: [
                                item.system.damage.formula ?? '',
                                this.temporaryDamageModifiers,
                            ]
                                .filter((v) => !!v)
                                .join(' + '),
                        },
                    }
                    : {}),
                ...event.op,
            })));
        },
    });
}

class ChangeDataModel extends foundry.abstract.DataModel {
    static defineSchema() {
        return {
            key: new foundry.data.fields.StringField({
                required: true,
                blank: true,
                initial: '',
            }),
            value: new foundry.data.fields.StringField({
                required: true,
                blank: true,
                initial: '',
            }),
            mode: new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                initial: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
                choices: Object.entries(CONST.ACTIVE_EFFECT_MODES).reduce((acc, [key, value]) => ({
                    ...acc,
                    [value]: `EFFECT.MODE_${key}`,
                }), {}),
            }),
        };
    }
}

function register$a() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "update-item" /* HandlerType.UpdateItem */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"update-item" /* HandlerType.UpdateItem */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"update-item" /* HandlerType.UpdateItem */}.Description`,
        config: {
            schema: {
                target: new foundry.data.fields.StringField({
                    choices: {
                        ["self" /* ItemTarget.Self */]: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Choices.${"self" /* ItemTarget.Self */}`,
                        ["sibling" /* ItemTarget.Sibling */]: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Choices.${"sibling" /* ItemTarget.Sibling */}`,
                        ["equipped-weapon" /* ItemTarget.EquippedWeapon */]: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Choices.${"equipped-weapon" /* ItemTarget.EquippedWeapon */}`,
                        ["equipped-armor" /* ItemTarget.EquippedArmor */]: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Choices.${"equipped-armor" /* ItemTarget.EquippedArmor */}`,
                        ["global" /* ItemTarget.Global */]: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Choices.${"global" /* ItemTarget.Global */}`,
                    },
                    initial: "self" /* ItemTarget.Self */,
                    required: true,
                    blank: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.General.Target.Label`,
                }),
                uuid: new foundry.data.fields.DocumentUUIDField({
                    type: 'Item',
                    initial: null,
                    nullable: true,
                    label: 'Item',
                }),
                matchMode: new foundry.data.fields.StringField({
                    nullable: true,
                    initial: "identifier" /* MatchMode.Identifier */,
                    choices: {
                        ["identifier" /* MatchMode.Identifier */]: `COSMERE.Item.EventSystem.Event.Handler.General.MatchMode.Choices.${"identifier" /* MatchMode.Identifier */}`,
                        ["name" /* MatchMode.Name */]: `COSMERE.Item.EventSystem.Event.Handler.General.MatchMode.Choices.${"name" /* MatchMode.Name */}`,
                        ["uuid" /* MatchMode.UUID */]: `COSMERE.Item.EventSystem.Event.Handler.General.MatchMode.Choices.${"uuid" /* MatchMode.UUID */}`,
                    },
                    label: `COSMERE.Item.EventSystem.Event.Handler.General.MatchMode.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.General.MatchMode.Hint`,
                }),
                matchAll: new foundry.data.fields.BooleanField({
                    initial: false,
                    nullable: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.General.MatchAll.Label`,
                    hint: `COSMERE.Item.EventSystem.Event.Handler.General.MatchAll.Hint`,
                }),
                changes: new foundry.data.fields.ArrayField(new foundry.data.fields.SchemaField(ChangeDataModel.defineSchema()), {
                    required: true,
                    initial: [],
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"update-item" /* HandlerType.UpdateItem */}.Changes.Label`,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_UPDATE_ITEM}`,
        },
        executor: async function (event) {
            if (this.changes.length === 0)
                return;
            if (this.target === "sibling" /* ItemTarget.Sibling */ && !event.item.actor)
                return;
            if (this.target !== "self" /* ItemTarget.Self */ && !this.uuid)
                return;
            // Get the item(s) to update
            const itemsToUpdate = await matchItems(event.item, this.target, this.uuid ?? null, this.matchMode ?? "identifier" /* MatchMode.Identifier */, this.matchAll ?? false);
            // Update the items
            await Promise.all(itemsToUpdate.map(async (item) => {
                // Construct change object
                const changes = this.changes.reduce((acc, change) => ({
                    ...acc,
                    [change.key]: getChangeValue(tryApplyRollData(foundry.utils.mergeObject(item.getRollData(), {
                        event: {
                            source: {
                                item: event.item.getRollData(),
                            },
                        },
                    }), change), item),
                }), {});
                // Update the item
                await item.update(changes, event.op);
            }));
        },
    });
}

function register$9() {
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "update-actor" /* HandlerType.UpdateActor */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"update-actor" /* HandlerType.UpdateActor */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"update-actor" /* HandlerType.UpdateActor */}.Description`,
        config: {
            schema: {
                target: new foundry.data.fields.StringField({
                    choices: {
                        ["parent" /* UpdateActorTarget.Parent */]: `COSMERE.Item.EventSystem.Event.Handler.Types.${"update-actor" /* HandlerType.UpdateActor */}.Target.Choices.${"parent" /* UpdateActorTarget.Parent */}`,
                        ["global" /* UpdateActorTarget.Global */]: `COSMERE.Item.EventSystem.Event.Handler.Types.${"update-actor" /* HandlerType.UpdateActor */}.Target.Choices.${"global" /* UpdateActorTarget.Global */}`,
                    },
                    initial: "parent" /* UpdateActorTarget.Parent */,
                    required: true,
                    blank: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"update-actor" /* HandlerType.UpdateActor */}.Target.Label`,
                }),
                uuid: new foundry.data.fields.DocumentUUIDField({
                    type: 'Actor',
                    initial: null,
                    nullable: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"update-actor" /* HandlerType.UpdateActor */}.UUID.Label`,
                }),
                changes: new foundry.data.fields.ArrayField(new foundry.data.fields.SchemaField(ChangeDataModel.defineSchema()), {
                    required: true,
                    initial: [],
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"update-actor" /* HandlerType.UpdateActor */}.Changes.Label`,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_UPDATE_ACTOR}`,
        },
        executor: async function (event) {
            if (!event.item.actor)
                return;
            if (this.changes.length === 0)
                return;
            if (this.target === "global" /* UpdateActorTarget.Global */ && !this.uuid)
                return;
            // Get the actor
            const actor = this.target === "global" /* UpdateActorTarget.Global */
                ? (await fromUuid(this.uuid))
                : event.item.actor;
            if (!actor)
                return;
            // Construct changes object
            const changes = this.changes.reduce((acc, change) => ({
                ...acc,
                [change.key]: getChangeValue(tryApplyRollData(foundry.utils.mergeObject(actor.getRollData(), {
                    event: {
                        source: {
                            item: event.item.getRollData(),
                        },
                    },
                }), change), actor),
            }), {});
            // Update the actor
            await actor.update(changes, event.op);
        },
    });
}

// Constants
function register$8() {
    // Get the macro schema
    const macroSchema = CONFIG.Macro
        .documentClass.defineSchema();
    // Re-assign type field label
    macroSchema.type.label = `COSMERE.Item.EventSystem.Event.Handler.Types.${"execute-macro" /* HandlerType.ExecuteMacro */}.MacroType.Label`;
    macroSchema.type.choices = () => CONFIG.Macro.typeLabels;
    cosmereRPG.api.registerItemEventHandlerType({
        source: SYSTEM_ID,
        type: "execute-macro" /* HandlerType.ExecuteMacro */,
        label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"execute-macro" /* HandlerType.ExecuteMacro */}.Title`,
        description: `COSMERE.Item.EventSystem.Event.Handler.Types.${"execute-macro" /* HandlerType.ExecuteMacro */}.Description`,
        config: {
            schema: {
                inline: new foundry.data.fields.BooleanField({
                    required: true,
                    initial: false,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"execute-macro" /* HandlerType.ExecuteMacro */}.Inline.Label`,
                }),
                uuid: new foundry.data.fields.DocumentUUIDField({
                    type: 'Macro',
                    initial: null,
                    nullable: true,
                    label: `COSMERE.Item.EventSystem.Event.Handler.Types.${"execute-macro" /* HandlerType.ExecuteMacro */}.UUID.Label`,
                }),
                macro: new foundry.data.fields.SchemaField({
                    type: macroSchema.type,
                    command: macroSchema.command,
                }, {
                    nullable: true,
                }),
            },
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.IES_HANDLER_EXECUTE_MACRO}`,
        },
        executor: async function (event) {
            // Get the macro to execute
            const macro = !this.inline
                ? this.uuid // Not inline, so we need to get the macro from the UUID
                    ? (await fromUuid(this.uuid))
                    : null
                : this.macro // Inline, so we need to create a new ephemeral macro document from the macro data
                    ? new CONFIG.Macro
                        .documentClass({
                        ...this.macro,
                        name: 'Event Inline Macro',
                    })
                    : null;
            // If no macro is found, return
            if (!macro)
                return;
            // Execute the macro
            await macro.execute({
                actor: event.item.actor,
                event,
            });
        },
    });
}

function registerHandlers() {
    register$j();
    register$i();
    register$h();
    register$g();
    register$f();
    register$e();
    register$d();
    register$c();
    register$b();
    register$a();
    register$9();
    register$8();
}

// Constants
class InvalidHookError extends Error {
    constructor(eventType, hook, message = '') {
        super(`[${SYSTEM_ID}] Invalid hook "${hook}" for event "${eventType}"${message ? `. ${message}` : ''}`);
        this.name = 'InvalidHookError';
    }
}

const VALID_DOCUMENT_TYPES$1 = [
    CONFIG.Item.documentClass.metadata.name,
    CONFIG.Actor.documentClass.metadata.name,
];
/**
 * The maximum depth of chained events.
 * If an event is fired that exceeds this depth,
 * an error will be thrown and the event will not be executed.
 */
const MAX_EVENT_CHAIN_DEPTH = 10;
/**
 * The maximum number of events that can be fired
 * in a short period of time.
 * If this limit is exceeded an error will be thrown
 * and the event will not be executed.
 */
const MAX_RECENT_EVENTS = 1000;
/**
 * The time in milliseconds that an event is considered
 * recent. If an event is fired within this time, it will
 * be counted as a recent event for the purposes of
 * preventing infinite loops.
 */
const RECENT_EVENT_TIMEOUT = 200; // ms
/**
 * Flag to toggle the event system.
 *
 * This lets systems, like migration, operate without
 * hitting the recent events limit and unintentionally
 * triggering the infinite loop detection.
 */
let PROCESS_EVENTS = true;
// Expose system toggles
var EventSystem;
(function (EventSystem) {
    // Enable the entire event system
    function enable() {
        PROCESS_EVENTS = true;
    }
    EventSystem.enable = enable;
    // Disable the entire event system
    function disable() {
        PROCESS_EVENTS = false;
    }
    EventSystem.disable = disable;
})(EventSystem || (EventSystem = {}));
// Global variables
let lastEventTime = 0;
const recentEventOfTypeCounts = {};
function register$7() {
    // Register event types
    registerEventTypes();
    // Register event handlers
    registerHandlers();
}
Hooks.once('ready', () => {
    // Group all item event types by their hook
    const evenTypesByHook = Object.entries(CONFIG.COSMERE.items.events.types).reduce((acc, [type, config]) => {
        if (!acc[config.hook]) {
            acc[config.hook] = [];
        }
        acc[config.hook].push(type);
        return acc;
    }, {});
    // Register hooks for each event type
    Object.entries(evenTypesByHook).forEach(([hook, eventTypes]) => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Hooks.on(hook, async (...args) => {
            const freshTraceId = foundry.utils.randomID();
            const freshDepth = 0;
            // Trigger the events for this hook
            await eventTypes.reduce(async (prev, type) => {
                await prev;
                // Get the config for the event type
                const config = CONFIG.COSMERE.items.events.types[type];
                // Check condition
                if (config.condition && !(await config.condition(...args)))
                    return;
                // Transform hook arguments to useable format
                const { document, options, userId: sourceUserId, } = getTransform(type, config)(...args);
                // Get event trace
                const trace = {
                    _eti: options?._eti ?? freshTraceId,
                    _d: options?._d ?? freshDepth,
                };
                // Increase depth
                trace._d++;
                if (document.documentName ===
                    CONFIG.Actor.documentClass.metadata.name) {
                    // Document is an actor
                    const actor = document;
                    // Handle the hook for all items
                    await actor.items.reduce(async (prev, item) => {
                        // Wait for the previous item to finish
                        await prev;
                        // Handle the hook
                        return handleEventHook(item, type, trace, config, options, sourceUserId);
                    }, Promise.resolve());
                }
                else if (document.documentName ===
                    CONFIG.Item.documentClass.metadata.name) {
                    // Document is an item
                    const item = document;
                    // Handle the hook
                    await handleEventHook(item, type, trace, config, options, sourceUserId);
                }
                else {
                    throw new InvalidHookError(type, config.hook, `Document type must be one of: ${VALID_DOCUMENT_TYPES$1.join(', ')}. Received: ${document.documentName}`);
                }
            }, Promise.resolve());
        });
    });
});
/* --- Helpers --- */
async function handleEventHook(item, eventType, eventTrace, config, options, sourceUserId) {
    if (!PROCESS_EVENTS)
        return;
    // Verify if the local user is the appropriate event execution host
    if (!shouldHostEventExecution(item, sourceUserId, config.host))
        return;
    // Ensure recent event counts are initialized
    recentEventOfTypeCounts[eventType] ??= 0;
    // Check for infinite loops
    preventInfiniteLoop(eventType, eventTrace);
    // Fire the event
    await fireEvent({ type: eventType, item, options, op: eventTrace });
    // Update the last event time
    lastEventTime = Date.now();
    recentEventOfTypeCounts[eventType]++;
}
function shouldHostEventExecution(item, sourceUserId, host) {
    if (host === "owner" /* Event.ExecutionHost.Owner */) {
        // Get ownership
        const ownership = (item.actor ?? item).ownership;
        // Get the first owning non-gm user that is active
        const owningUserId = Object.entries(ownership)
            .filter(([id]) => id !== 'default')
            .find(([userId, ownershipLevel]) => {
            const user = game.users.get(userId);
            return (!!user &&
                user.active &&
                !user.isGM &&
                ownershipLevel >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER);
        })?.[0];
        // If an owning user is found, check if the current user is the owner
        if (owningUserId)
            return game.userId === owningUserId;
        // If no owning user is found, find an active GM user
        const gmUser = game.users.find((user) => user.active && user.isGM);
        return gmUser?.isSelf ?? false;
    }
    else if (host === "gm" /* Event.ExecutionHost.GM */) {
        // Find an active GM user
        const gmUser = game.users.find((user) => user.active && user.isGM);
        return gmUser?.isSelf ?? false;
    }
    else if (host === "source" /* Event.ExecutionHost.Source */) {
        // Check if the source user is the current user
        return (!sourceUserId || // Assume the hook was triggered locally if no source user id is provided
            game.userId === sourceUserId);
    }
}
function preventInfiniteLoop(eventType, trace) {
    // Check if the event chain depth exceeds the maximum allowed
    if (trace._d > MAX_EVENT_CHAIN_DEPTH) {
        ui.notifications.error(game.i18n.localize(`COSMERE.Item.EventSystem.Notification.ExceededMaxDepth`));
        throw new Error(`[${SYSTEM_ID}] Event chain depth exceeded the maximum allowed of ${MAX_EVENT_CHAIN_DEPTH}. Possible infinite loop detected.`);
    }
    // Get the current time
    const now = Date.now();
    // Check if the time since the last event is less than the timeout
    if (now - lastEventTime >= RECENT_EVENT_TIMEOUT) {
        // Reset the recent event count
        recentEventOfTypeCounts[eventType] = 0;
        return;
    }
    // Check if the number of recent events is greater than the limit
    if (recentEventOfTypeCounts[eventType] >= MAX_RECENT_EVENTS) {
        ui.notifications.error(game.i18n.format(`COSMERE.Item.EventSystem.Notification.RecentEventsExceeded`, {
            eventType,
        }));
        throw new Error(`[${SYSTEM_ID}] Too many events fired in a short period of time. Possible infinite loop detected.`);
    }
}
async function fireEvent(event) {
    const { item } = event;
    // Check if the item has events
    if (!item.hasEvents())
        return;
    // Execute any relevant rules
    await item.system.events
        .filter((rule) => rule.event === event.type)
        .sort((a, b) => a.order - b.order)
        .reduce(async (prev, rule) => {
        if ((await prev) === false)
            return false;
        try {
            // Execute the rule
            return await rule.handler.execute(foundry.utils.deepClone(event));
        }
        catch (e) {
            console.error(`[${SYSTEM_ID}] Error executing event rule ${rule.id} for item ${item.name} ${item.uuid}`, e);
        }
    }, Promise.resolve(undefined));
}
function getTransform(type, config) {
    // NOTE: Must use `any` here as hooks can be called with arbitrary arguments
    /* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment */
    return (config.transform ??
        ((...args) => {
            // Ensure first argument is a document
            if (!args[0] || !(args[0] instanceof foundry.abstract.Document)) {
                throw new InvalidHookError(type, config.hook, 'First argument must be a document.');
            }
            // Get the document
            const document = args[0];
            // Grab options and source user id, if present
            const options = args.length > 1
                ? args.length === 2
                    ? args[1] // If only two arguments, the second is options
                    : args[args.length - 2] // If more than two, the second to last is options
                : undefined;
            const userId = args.length > 2
                ? args[args.length - 1] // If more than two, the last is the source user id
                : undefined;
            if (!!options && typeof options !== 'object') {
                throw new InvalidHookError(type, config.hook, 'Options must be an object.');
            }
            if (!!userId && typeof userId !== 'string') {
                throw new InvalidHookError(type, config.hook, 'Source user id must be a string.');
            }
            return {
                document,
                options,
                userId,
            };
        }));
    /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment */
}

// Types
const MIGRATIONS = [MIGRATE_0_2__0_3, MIGRATE_0_3__1_0];
/**
 * Check if the world requires migration between the two version
 */
function requiresMigration(from, to) {
    // Reduce versions to format 'major.minor'
    from = simplifyVersion(from);
    to = simplifyVersion(to);
    // Check all migrations beteen the versions
    return MIGRATIONS.some((migration) => {
        return (versionToNumber(migration.from) >= versionToNumber(from) &&
            versionToNumber(migration.to) <= versionToNumber(to));
    });
}
/**
 * Execute any relevant migrations between the two versions
 */
async function migrate(from, to, packID) {
    // Disable event system to prevent infinite loop errors when performing
    // substantial migrations
    EventSystem.disable();
    // Reduce versions to format 'major.minor'
    from = simplifyVersion(from);
    to = simplifyVersion(to);
    /**
     * Hook: preMigration
     */
    Hooks.callAll(HOOKS.PRE_MIGRATION, from, to);
    // Get all migrations between the versions
    const migrations = MIGRATIONS.filter((migration) => {
        return (versionToNumber(migration.from) >= versionToNumber(from) &&
            versionToNumber(migration.to) <= versionToNumber(to));
    });
    if (migrations.length === 0) {
        console.log(`[${SYSTEM_ID}] Migration is not required for this version.`);
        return;
    }
    // Execute migrations in order
    for (const migration of migrations) {
        /**
         * Hook: preMigrationVersion
         */
        Hooks.callAll(HOOKS.PRE_MIGRATE_VERSION, migration.from, migration.to);
        const packName = packID ? ` (${packID})` : '';
        try {
            console.log(`[${SYSTEM_ID}] Migration ${migration.from} -> ${migration.to}: Running${packName}`);
            if (packID) {
                await migration.execute(packID);
            }
            else {
                await migration.execute();
            }
            console.log(`[${SYSTEM_ID}] Migration ${migration.from} -> ${migration.to}: Succeeded${packName}`);
        }
        catch (err) {
            console.error(`[${SYSTEM_ID}] Error running data migration${packName}:`, err);
            console.log(`[${SYSTEM_ID}] Migration ${migration.from} -> ${migration.to}: Failed${packName}, exiting`);
            return;
        }
        /**
         * Hooks: migrateVersion
         */
        Hooks.callAll(HOOKS.MIGRATE_VERSION, migration.from, migration.to);
    }
    // Re-render sidebar to include re-validated documents
    console.log(`[${SYSTEM_ID}] Successfully migrated data! Refreshing sidebar...`);
    await globalThis.ui.sidebar.render();
    /**
     * Hook: migration
     */
    Hooks.callAll(HOOKS.MIGRATION, from, to);
    // Re-enable event system
    EventSystem.enable();
}
/* --- Manual Invocation --- */
async function invokeMigration(from, to, compendiumIDs = []) {
    if (!game.user.isGM)
        return;
    if (!requiresMigration(from, to))
        return;
    // Migrate world data
    if (compendiumIDs.length === 0) {
        await migrate(from, to);
        return;
    }
    // Migrate compendiums synchronously
    for (const id of compendiumIDs) {
        // Ensure compendiums exist
        const compendium = game.packs?.get(id);
        if (!compendium)
            return;
        // Ensure compendiums are unlocked
        const wasLocked = compendium.locked;
        await compendium.configure({ locked: false });
        // Migrate data across full range
        await migrate(from, to, compendium.collection);
        // Restore compendium to original locked/unlocked state
        await compendium.configure({ locked: wasLocked });
    }
}
/* --- Helpers --- */
function simplifyVersion(version) {
    return version.split('.').slice(0, 2).join('.');
}
function versionToNumber(version) {
    return version
        .split('.')
        .reverse()
        .map(Number)
        .reduce((acc, val, i) => acc + val * Math.pow(1000, i), 0);
}

// Dialogs
Hooks.on('ready', async () => {
    // Ensure this message is only displayed when creating a new world
    if (!game.user.isGM || !getSystemSetting(SETTINGS.INTERNAL_FIRST_CREATION))
        return;
    // Get system version
    const version = game.system.version;
    // Display the welcome message
    await ChatMessage.create({
        content: game.i18n.format('COSMERE.ChatMessage.Welcome', {
            version,
            discordLink: METALWORKS_DISCORD_INVITE,
            issuesLink: GITHUB_ISSUES_URL,
            contributingLink: GITHUB_CONTRIBUTING_URL,
        }),
        speaker: {
            alias: AUTHOR_NAME,
        },
        flags: {
            [SYSTEM_ID]: {
                headerImg: `systems/${SYSTEM_ID}/assets/art/the-metalworks.png`,
            },
        },
    });
    // Mark the setting so the message doesn't appear again
    await game.settings.set(SYSTEM_ID, 'firstTimeWorldCreation', false);
});
Hooks.on('ready', async () => {
    // Ensure user is a GM
    if (!game.user.isGM)
        return;
    // The current installed version of the system
    const currentVersion = game.system.version;
    // The last used version of the system
    const latestVersion = getSystemSetting(SETTINGS.INTERNAL_LATEST_VERSION);
    const [currentMajor, currentMinor, currentPatch] = currentVersion
        .split('.')
        .map(Number);
    const [latestMajor, latestMinor, latestPatch] = latestVersion
        .split('.')
        .map(Number);
    // Convert the version strings to numbers
    const currentVersionNum = currentMajor * 1000000 + currentMinor * 1000 + currentPatch;
    const latestVersionNum = latestMajor * 1000000 + latestMinor * 1000 + latestPatch;
    if (currentVersionNum > latestVersionNum) {
        // Show the release notes
        void ReleaseNotesDialog.show({
            patch: !(currentMajor > latestMajor || currentMinor > latestMinor),
        });
        // Migrate data from the previous version of the system
        if (requiresMigration(latestVersion, currentVersion)) {
            await migrate(latestVersion, currentVersion);
        }
        // Record the latest version of the system
        await setSystemSetting(SETTINGS.INTERNAL_LATEST_VERSION, currentVersion);
    }
});

function DataModelMixin(...mixins) {
    return mixins.reduce((base, mixin) => {
        return mixin(base);
    }, BaseDataModel);
}
class BaseDataModel extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        return {};
    }
}

function IdItemMixin(options = {}) {
    if (options.initialFromName && options.initial)
        throw new Error('Cannot specify both initialFromName and initial options');
    if (options.initialFromName && options.choices)
        throw new Error('Cannot specify both initialFromName and choices options');
    return (base) => {
        return class extends base {
            static defineSchema() {
                const choices = typeof options.choices === 'function'
                    ? options.choices()
                    : options.choices;
                const initial = typeof options.initial === 'function'
                    ? options.initial()
                    : options.initial;
                return foundry.utils.mergeObject(super.defineSchema(), {
                    id: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                        initial: initial ??
                            (options.initialFromName ? '<id>' : undefined),
                        choices,
                        label: options.label ??
                            'COSMERE.Item.Sheet.Identifier.Label',
                        hint: options.hint ??
                            'COSMERE.Item.Sheet.Identifier.Hint',
                    }),
                });
            }
            prepareDerivedData() {
                super.prepareDerivedData();
                if (this.id === '<id>' && options.initialFromName) {
                    this.id = this.parent.name
                        .toLowerCase()
                        .replace(/[^a-z0-9-_\s]/g, '')
                        .replace(/\s+/g, ' ')
                        .trim()
                        .split(' ')
                        .join('-');
                }
            }
        };
    };
}

function DescriptionItemMixin(params) {
    return (base) => {
        return class extends base {
            static defineSchema() {
                return foundry.utils.mergeObject(super.defineSchema(), {
                    description: new foundry.data.fields.SchemaField({
                        value: new foundry.data.fields.HTMLField({
                            label: 'Description',
                            initial: params?.value
                                ? `<p>${game.i18n.localize(params.value)}</p>`
                                : '',
                        }),
                        chat: new foundry.data.fields.HTMLField({
                            label: 'Chat description',
                            initial: params?.chat
                                ? `<p>${game.i18n.localize(params.chat)}</p>`
                                : '',
                        }),
                        short: new foundry.data.fields.StringField({
                            initial: params?.short
                                ? `<p>${game.i18n.localize(params.short)}</p>`
                                : '',
                        }),
                    }),
                });
            }
        };
    };
}

function constructHandlerClass(type, executor, config) {
    return class Handler extends foundry.abstract.DataModel {
        static get TYPE() {
            return type;
        }
        get typeLabel() {
            return this.type !== 'none'
                ? CONFIG.COSMERE.items.events.handlers[this.type].label
                : 'GENERIC.None';
        }
        get typeDescription() {
            if (this.type === 'none')
                return null;
            const descriptor = CONFIG.COSMERE.items.events.handlers[this.type].description;
            if (typeof descriptor === 'function') {
                return descriptor.call(this);
            }
            else {
                return descriptor ?? null;
            }
        }
        get configSchema() {
            return {
                fields: config.schema,
            };
        }
        get configRenderer() {
            return 'render' in config && config.render
                ? config.render
                : 'template' in config && config.template
                    ? (data) => renderTemplate(config.template, data)
                    : null;
        }
        static defineSchema() {
            return foundry.utils.mergeObject(foundry.utils.deepClone(config.schema), {
                type: new foundry.data.fields.StringField({
                    required: true,
                    initial: type,
                    blank: false,
                    choices: () => ({
                        none: 'None',
                        ...Object.entries(CONFIG.COSMERE.items.events.handlers).reduce((choices, [id, config]) => ({
                            ...choices,
                            [id]: config.label,
                        }), {}),
                    }),
                    label: 'Type',
                }),
            });
        }
        execute(event) {
            // Execute the handler
            return executor.call(this, event);
        }
    };
}

// Constants
const NONE_HANDLER_CLASS = constructHandlerClass('none', () => { }, {
    schema: {},
});
class HandlerField extends foundry.data.fields.ObjectField {
    /**
     * Get the model for the given handler type
     */
    static getModelForType(type) {
        return type !== 'none'
            ? (CONFIG.COSMERE.items.events.handlers[type]?.documentClass ??
                null)
            : NONE_HANDLER_CLASS;
    }
    _cleanType(value, options) {
        if (!value || !(typeof value === 'object'))
            return {};
        // Get type
        const type = 'type' in value ? value.type : 'none';
        // Clean value
        return (HandlerField.getModelForType(type)?.cleanData(value, options) ??
            value);
    }
    _validateType(value, options) {
        if (!value || !(typeof value === 'object'))
            throw new Error('must be a Handler object');
        if (!('type' in value))
            throw new Error('must have a type property');
        if (typeof value.type !== 'string')
            throw new Error('field "type" must be a string');
        // Get model
        const cls = HandlerField.getModelForType(value.type);
        if (!cls)
            throw new Error(`field "type" must be one of ${Object.keys(CONFIG.COSMERE.items.events.handlers).join(', ')}`);
        // Perform validation
        return cls.schema.validate(value, options);
    }
    _cast(value) {
        return typeof value === 'object' ? value : {};
    }
    getInitialValue(data) {
        // Get model
        const cls = HandlerField.getModelForType(data.type);
        // Get initial value
        return cls.schema.getInitialValue(data);
    }
    initialize(value, model, options) {
        // Get model
        const cls = HandlerField.getModelForType(value.type);
        // Initialize value
        return cls
            ? value instanceof cls
                ? value
                : new cls(foundry.utils.deepClone(value), {
                    parent: model,
                    ...options,
                })
            : foundry.utils.deepClone(value);
    }
}

// Fields
class Rule extends foundry.abstract.DataModel {
    static defineSchema() {
        return {
            id: new foundry.data.fields.DocumentIdField({
                initial: () => foundry.utils.randomID(),
                readonly: false,
            }),
            description: new foundry.data.fields.StringField({
                required: true,
                initial: '',
                label: 'COSMERE.Item.EventSystem.Event.Rule.Description.Label',
            }),
            order: new foundry.data.fields.NumberField({
                initial: 0,
                integer: true,
                min: 0,
            }),
            event: new foundry.data.fields.StringField({
                required: true,
                blank: false,
                initial: 'none',
                choices: () => ({
                    none: 'None',
                    ...Object.entries(CONFIG.COSMERE.items.events.types).reduce((choices, [id, config]) => ({
                        ...choices,
                        [id]: config.label,
                    }), {}),
                }),
                label: 'COSMERE.Item.EventSystem.Event.Rule.Event.Label',
            }),
            handler: new HandlerField({
                required: true,
            }),
        };
    }
    /* --- Accessors --- */
    get eventTypeLabel() {
        return this.event !== 'none'
            ? CONFIG.COSMERE.items.events.types[this.event].label
            : 'None';
    }
    get eventTypeDescription() {
        return this.event !== 'none'
            ? (CONFIG.COSMERE.items.events.types[this.event].description ?? '')
            : '';
    }
}

class RuleField extends foundry.data.fields.SchemaField {
    constructor(options, context) {
        super(Rule.defineSchema(), options, context);
    }
    _cast(value) {
        return typeof value === 'object' ? value : {};
    }
    initialize(value, model, options) {
        return new Rule(foundry.utils.deepClone(value), {
            parent: model,
            ...options,
        });
    }
}

class MappingField extends foundry.data.fields.ObjectField {
    model;
    constructor(model, options = {}) {
        super(options);
        this.model = model;
    }
    _cleanType(value, options) {
        Object.entries(value).forEach(([key, v]) => {
            value[key] = this.model.clean(v, options);
        });
        return value;
    }
    _validateType(value, options) {
        if (foundry.utils.getType(value) !== 'Object')
            throw new Error('must be an Object');
        const errors = this._validateValues(value, options);
        if (!foundry.utils.isEmpty(errors)) {
            // Create validatior failure
            const failure = new foundry.data.validation.DataModelValidationFailure();
            // Set fields
            failure.fields = errors;
            // Throw error
            throw new foundry.data.validation.DataModelValidationError(failure);
        }
    }
    _validateValues(value, options) {
        const errors = {};
        Object.entries(value).forEach(([key, v]) => {
            const error = this.model.validate(v, options);
            if (error)
                errors[key] = error;
        });
        return errors;
    }
    getInitialValue() {
        return {};
    }
    initialize(value) {
        if (!value)
            return value;
        return value;
    }
    _getField(path) {
        if (path.length === 0)
            return this;
        else if (path.length === 1)
            return this.model;
        path.shift();
        return this.model._getField(path);
    }
}

function EventsItemMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                return foundry.utils.mergeObject(super.defineSchema(), {
                    events: new CollectionField(new RuleField(), {
                        required: true,
                    }),
                });
            }
        };
    };
}

// Mixins
class GoalItemDataModel extends DataModelMixin(IdItemMixin({
    initialFromName: true,
}), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Goal.desc_placeholder',
}), EventsItemMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            level: new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                integer: true,
                min: 0,
                max: 3,
                initial: 0,
                label: 'COSMERE.Item.Goal.Level.Label',
            }),
        });
    }
}

// Data
Hooks.on('preUpdateItem', (item, update) => {
    if (item.isGoal()) {
        if (foundry.utils.hasProperty(update, 'system.level')) {
            const currentLevel = item.system.level;
            const newLevel = foundry.utils.getProperty(update, 'system.level');
            if (newLevel !== currentLevel) {
                /**
                 * Hook: preUpdateProgressGoal
                 */
                if (Hooks.call(HOOKS.PRE_UPDATE_PROGRESS_GOAL, item, newLevel) === false) {
                    return false;
                }
                if (newLevel > currentLevel) {
                    /**
                     * Hook: preProgressGoal
                     */
                    if (Hooks.call(HOOKS.PRE_PROGRESS_GOAL, item, newLevel) === false) {
                        return false;
                    }
                }
                if (newLevel ===
                    GoalItemDataModel.schema.fields
                        .level.options.max) {
                    /**
                     * Hook: preCompleteGoal
                     */
                    if (Hooks.call(HOOKS.PRE_COMPLETE_GOAL, item) === false) {
                        return false;
                    }
                }
                // Add the previous level to the update
                foundry.utils.mergeObject(update, {
                    [`flags.${SYSTEM_ID}.previousLevel`]: currentLevel,
                }, {
                    inplace: true,
                });
            }
        }
    }
});
Hooks.on('updateItem', (item, update) => {
    if (item.isGoal()) {
        const previousLevel = item.getFlag(SYSTEM_ID, 'previousLevel') ?? 0;
        const newLevel = item.system.level;
        if (newLevel !== previousLevel) {
            /**
             * Hook: updateProgressGoal
             */
            Hooks.callAll(HOOKS.UPDATE_PROGRESS_GOAL, item);
            if (newLevel > previousLevel) {
                /**
                 * Hook: progressGoal
                 */
                Hooks.callAll(HOOKS.PROGRESS_GOAL, item);
            }
            if (newLevel ===
                GoalItemDataModel.schema.fields
                    .level.options.max) {
                /**
                 * Hook: completeGoal
                 */
                Hooks.callAll(HOOKS.COMPLETE_GOAL, item);
            }
        }
    }
});
/* --- Relationships --- */
Hooks.on('preCreateItem', (item) => {
    if (!item.hasRelationships())
        return;
    if (item.hasRelationshipOfType(ItemRelationship.Type.Parent))
        return;
    if (!item.actor)
        return;
    // Get origin flag
    const origin = item.getFlag(SYSTEM_ID, 'meta.origin');
    if (!origin)
        return;
    // Attempt to find a suitable parent item on the actor
    const parentItem = item.actor.items.find((otherItem) => otherItem.hasRelationships() &&
        otherItem.hasId() &&
        otherItem.id === origin.id &&
        otherItem.type === origin.type);
    if (!parentItem)
        return;
    // Add a parent relationship to the item
    item.addRelationship(parentItem, ItemRelationship.Type.Parent, "keep" /* ItemRelationship.RemovalPolicy.Keep */, true);
});
Hooks.on('createItem', async (item, _, userId) => {
    if (game.user.id !== userId)
        return;
    if (!item.hasRelationships())
        return;
    await Promise.all(item.system.relationships.map((relationship) => connectRelationship(item, relationship)));
    if (item.hasRelationshipOfType(ItemRelationship.Type.Parent)) {
        // If the item has a parent relationship, we need to update the parent item
        const parentRelationship = item.system.relationships.find((relationship) => relationship.type === ItemRelationship.Type.Parent);
        // Get the parent item
        const parentItem = (await fromUuid(parentRelationship.uuid));
        if (parentItem &&
            parentItem.hasRelationships() &&
            parentItem.hasId()) {
            // Set the origin flag on the item
            await item.setFlag(SYSTEM_ID, 'meta.origin', {
                id: parentItem.system.id,
                type: parentItem.type,
            });
        }
    }
    if (item.actor && item.hasId()) {
        // Get all orphaned items
        const orphanedItems = item.actor.items.filter((otherItem) => otherItem.hasRelationships() &&
            !otherItem.hasRelationshipOfType(ItemRelationship.Type.Parent));
        // For each orphaned item, check if it has an origin flag pointing to this item
        await Promise.all(orphanedItems.map(async (orphanedItem) => {
            const origin = orphanedItem.getFlag(SYSTEM_ID, 'meta.origin');
            if (!origin)
                return;
            // If the origin matches this item, add a parent relationship
            if (origin.id === item.system.id &&
                origin.type === item.type) {
                await orphanedItem.addRelationship(item, ItemRelationship.Type.Parent);
            }
        }));
    }
});
Hooks.on('updateItem', async (item, update, _, userId) => {
    if (game.user.id !== userId)
        return;
    if (!item.hasRelationships())
        return;
    if (!foundry.utils.hasProperty(update, 'system.relationships'))
        return;
    const updatedRelationships = update
        .system.relationships;
    await Promise.all(Object.values(updatedRelationships).map((relationship) => connectRelationship(item, relationship)));
});
Hooks.on('deleteItem', async (item, _, userId) => {
    if (game.user.id !== userId)
        return;
    if (!item.hasRelationships())
        return;
    await Promise.all(item.system.relationships.map(async (relationship) => {
        if (relationship.type === ItemRelationship.Type.Child) {
            // Get the related item
            const relatedItem = (await fromUuid(relationship.uuid));
            if (!relatedItem?.hasRelationships())
                return;
            if (relationship.removalPolicy ===
                "remove" /* ItemRelationship.RemovalPolicy.Remove */) {
                // Delete the related item
                await relatedItem.delete();
            }
            else {
                // Remove the relationship from the related item
                await disconnectRelationship(relatedItem, relationship);
            }
        }
        else {
            // If the relationship is a parent, we need to disconnect it from the related item
            await disconnectRelationship(item, relationship);
        }
    }));
});
/* --- Helpers --- */
async function connectRelationship(item, relationShip) {
    // Get the related item
    const relatedItem = (await fromUuid(relationShip.uuid));
    if (!relatedItem?.hasRelationships())
        return;
    const contraType = relationShip.type === ItemRelationship.Type.Parent
        ? ItemRelationship.Type.Child
        : ItemRelationship.Type.Parent;
    // If the related item is already related to the item, skip
    if (relatedItem.isRelatedTo(item, contraType))
        return;
    // Add the relationship to the related item
    await ItemRelationshipUtils.setRelationship(relationShip.id, relatedItem, item, contraType, relationShip.removalPolicy);
}
async function disconnectRelationship(item, relationShip) {
    // Get the related item
    const relatedItem = (await fromUuid(relationShip.uuid));
    if (!relatedItem?.hasRelationships())
        return;
    // Remove the relationship from the related item
    await relatedItem.update({
        [`system.relationships.-=${relationShip.id}`]: {
            type: relationShip.type,
        },
    });
}

/* --- Resource Max --- */
Hooks.on('preUpdateActor', (actor, update, options, userId) => {
    if (game.user.id !== userId)
        return;
    Object.keys(actor.system.resources).forEach((key) => {
        const resource = actor.system.resources[key];
        foundry.utils.setProperty(options, `${SYSTEM_ID}.resource.${key}.max`, resource.max.value);
    });
});
Hooks.on('updateActor', (actor, update, options, userId) => {
    if (game.user.id !== userId)
        return;
    const changes = {};
    Object.keys(actor.system.resources).forEach((key) => {
        const resource = actor.system.resources[key];
        // Get the previous max value
        const prevMax = foundry.utils.getProperty(options, `${SYSTEM_ID}.resource.${key}.max`);
        if (prevMax === undefined)
            return;
        // If the max value has changed, update the actor
        if (resource.max.value > prevMax) {
            const diff = resource.max.value - prevMax;
            foundry.utils.mergeObject(changes, {
                [`system.resources.${key}.value`]: resource.value + diff,
            });
        }
    });
    if (Object.keys(changes).length > 0) {
        void actor.update(changes);
    }
});
/* --- Modality --- */
Hooks.on('preUpdateActor', (actor, update) => {
    if (foundry.utils.hasProperty(update, `flags.${SYSTEM_ID}.mode`)) {
        const modalityChanges = foundry.utils.getProperty(update, `flags.${SYSTEM_ID}.mode`);
        for (const [modality, newMode] of Object.entries(modalityChanges)) {
            // Get current mode
            const currentMode = actor.getMode(modality);
            // Get modality item for the current mode
            const currentModalityItem = actor.items.find((item) => item.hasId() &&
                item.hasModality() &&
                item.system.modality === modality &&
                item.system.id === currentMode);
            if (currentModalityItem) {
                /**
                 * Hook: preDeactivateModality
                 */
                if (Hooks.call(HOOKS.PRE_MODE_DEACTIVATE_ITEM, currentModalityItem) === false) {
                    return false;
                }
            }
            // Get modality item for the new mode
            const newModalityItem = actor.items.find((item) => item.hasId() &&
                item.hasModality() &&
                item.system.modality === modality &&
                item.system.id === newMode);
            if (newModalityItem) {
                /**
                 * Hook: preActivateModality
                 */
                if (Hooks.call(HOOKS.PRE_MODE_ACTIVATE_ITEM, newModalityItem) === false) {
                    return false;
                }
            }
            // Store the current mode in flags for later use
            foundry.utils.setProperty(update, `flags.${SYSTEM_ID}.meta.update.mode.${modality}`, currentMode);
        }
    }
});
Hooks.on('updateActor', (actor, update) => {
    if (foundry.utils.hasProperty(update, `flags.${SYSTEM_ID}.mode`)) {
        const modalityChanges = foundry.utils.getProperty(update, `flags.${SYSTEM_ID}.mode`);
        for (const [modality, newMode] of Object.entries(modalityChanges)) {
            // Get previous mode
            const prevMode = actor.getFlag(SYSTEM_ID, `meta.update.mode.${modality}`);
            // Get modality item for the current mode
            const currentModalityItem = actor.items.find((item) => item.hasId() &&
                item.hasModality() &&
                item.system.modality === modality &&
                item.system.id === prevMode);
            if (currentModalityItem) {
                /**
                 * Hook: modeDeactivateItem
                 */
                Hooks.callAll(HOOKS.MODE_DEACTIVATE_ITEM, currentModalityItem);
            }
            // Get modality item for the new mode
            const newModalityItem = actor.items.find((item) => item.hasId() &&
                item.hasModality() &&
                item.system.modality === modality &&
                item.system.id === newMode);
            if (newModalityItem) {
                /**
                 * Hook: modeActivateItem
                 */
                Hooks.callAll(HOOKS.MODE_ACTIVATE_ITEM, newModalityItem);
            }
        }
    }
});
Hooks.on('createItem', async (item, options, userId) => {
    if (game.user.id !== userId)
        return;
    if (!item.actor)
        return;
    if (item.isTalent()) {
        const hasParentRelationship = item.hasRelationshipOfType(ItemRelationship.Type.Parent);
        if (!hasParentRelationship) {
            // If the item has no parent, find the first item in the actor that provides this talent
            let parentItem;
            for (const otherItem of item.actor.items) {
                if (otherItem.isTalentsProvider() &&
                    (await otherItem.system.providesTalent(item))) {
                    parentItem = otherItem;
                    break;
                }
            }
            // Record the relationship with the parent item
            if (parentItem) {
                await item.addRelationship(parentItem, ItemRelationship.Type.Parent);
            }
        }
    }
    else if (item.isTalentsProvider()) {
        // Get all orphaned talents on the actor that do not have their origin set
        const orphanedTalents = item.actor.items
            .filter((otherItem) => otherItem.isTalent() &&
            !otherItem.hasRelationshipOfType(ItemRelationship.Type.Parent))
            .filter((otherItem) => !otherItem.getFlag(SYSTEM_ID, 'meta.origin'));
        // For each orphaned talent, check if this item can provide it. If so, add a parent relationship
        for (const talent of orphanedTalents) {
            if (await item.system.providesTalent(talent)) {
                await talent.addRelationship(item, ItemRelationship.Type.Parent);
            }
        }
    }
});

Hooks.on(HOOKS.TRIGGER_TEST_ENRICHER, async (actorId, source, data) => {
    const actor = await getActor(actorId ?? '');
    if (actor && data.skill) {
        await actor.rollSkill(data.skill, data.attribute
            ? { attribute: data.attribute }
            : undefined);
        return;
    }
});
Hooks.on(HOOKS.TRIGGER_DAMAGE_ENRICHER, async (actorId, source, data) => {
    const actor = await getActor(actorId ?? '');
    if (actor && data.formula) {
        const roll = new DamageRoll(String(data.formula), actor.getRollData(), { damageType: data.damageType });
        await roll.evaluate();
        // Create chat message
        const messageConfig = {
            user: game.user.id,
            speaker: ChatMessage.getSpeaker({ actor }),
            rolls: [roll],
            flags: {
                [SYSTEM_ID]: {
                    message: {
                        type: MESSAGE_TYPES.ACTION,
                    },
                },
            },
        };
        await ChatMessage.create(messageConfig);
    }
});

/* --- Starter rule styling --- */
Hooks.on('renderJournalSheet', (app, html) => {
    // Get journal entry
    const entry = app.document;
    if (entry.pack === COMPENDIUMS.STARTER_RULES ||
        ('compendiumSource' in entry._stats &&
            entry._stats.compendiumSource &&(
            entry._stats.compendiumSource.startsWith(`Compendium.${COMPENDIUMS.STARTER_RULES}`) || entry._stats.compendiumSource.startsWith(`Compendium.devyatyj-most`) )) ) {
        html[0].classList.add('sljsr');
        const header_node = html[0].getElementsByClassName('journal-header')[0];
        header_node.removeChild(header_node.children[0]);
        header_node.insertAdjacentHTML('beforeend', '<div class="sl-chapter-header"><div><p></p><p>' +
            entry.name.toUpperCase() +
            '</p><p></p></div><div><p></p></div></div>');
    }
});
/* --- @Link blocks --- */
Hooks.on('renderJournalPageSheet', (app, html) => {
    const page = app.document;
    page.parent;
    html.find('section[data-link].content-link-anchor').each(function () {
        const section = $(this);
        // Find matching closing section
        const closingSection = section
            .nextAll('section.content-link-anchor')
            .first();
        // Ensure a matching closing section exists
        if (!closingSection.length)
            return;
        // Remove empty p elements before and after the section
        section.prev('p:empty').remove();
        section.next('p:empty').remove();
        // Remove empty p elements before and after the closing section
        closingSection.prev('p:empty').remove();
        closingSection.next('p:empty').remove();
        // Get all the content between the sections
        const content = section.nextUntil(closingSection);
        // Remove the content from the main HTML
        content.remove();
        // If the first element of the content is a header, add the link
        const header = content.first().filter('h1, h2, h3, h4, h5, h6');
        if (header.length) {
            // Get all data attributes from the section
            const dataAttributes = section.data();
            const dataStr = Object.entries(dataAttributes)
                .map(([key, value]) => `data-${key}="${value}"`)
                .join(' ');
            // Grab the text of the header
            const headerText = header.text().trim();
            if (headerText && header.children().length === 0) {
                // Clear the header text
                header.text('');
                // Append the header text as span
                header.append(`<span>${headerText}</span>`);
            }
            // Append the link to the header
            header.append(` <a ${dataStr}><i class="fa-solid fa-up-right-from-square"></i></a>`);
        }
        // Move all the content into the section
        section.append(content);
        // Remove the closing section
        closingSection.remove();
        // Replace the content-link-anchor class with pseudo-embed
        section.removeClass('content-link-anchor').addClass('pseudo-embed');
    });
});

// Constants
Hooks.on('renderCompendium', async (compendium) => {
    if (!foundry.utils.hasProperty(compendium.collection.metadata.flags ?? {}, `${SYSTEM_ID}.defaultSortingMode`))
        return;
    const sortingModes = game.settings.get('core', 'collectionSortingModes');
    if (sortingModes[compendium.metadata.id])
        return;
    // Get the default sorting mode from the compendium metadata
    const defaultSortingMode = foundry.utils.getProperty(compendium.collection.metadata.flags, `${SYSTEM_ID}.defaultSortingMode`);
    // Set the sorting mode for the compendium
    await game.settings.set('core', 'collectionSortingModes', {
        ...sortingModes,
        [compendium.metadata.id]: defaultSortingMode,
    });
    // Initialize the compendium collection tree
    compendium.collection.initializeTree();
    // Re-render
    compendium.render();
});

const VALID_DOCUMENT_TYPES = [CONFIG.Item.documentClass.metadata.name];
Hooks.on('hotbarDrop', (bar, data, slot) => {
    if (VALID_DOCUMENT_TYPES.includes(data.type)) {
        void createCosmereMacro(data, slot);
        // We block the default drop behaviour if the type is supported
        return false;
    }
});
/* --- Helpers --- */
async function createCosmereMacro(data, slot) {
    const macroData = { type: 'script', scope: 'actor' };
    let itemData;
    switch (data.type) {
        case CONFIG.Item.documentClass.metadata.name:
            itemData = (await Item.fromDropData(data));
            if (!itemData)
                return;
            foundry.utils.mergeObject(macroData, {
                name: itemData.name,
                img: itemData.img,
                command: `(await fromUuid("${itemData.uuid}")).use();`,
            });
            break;
        default:
            return;
    }
    // TODO: Clean up this linter mess with v13 types.
    // Assign the macro to the hotbar
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const macro = game.macros.find((m) => m.name === macroData.name && m.command === macroData.command)
        ??
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
            (await Macro.create(macroData));
    await game.user?.assignHotbarMacro(macro, slot);
}

const WEAPONS = [
    {
        id: 'axe',
        label: 'Топор',
        reference: 'Compendium.cosmere-rpg.items.Item.C4o8jIXuVulD9qS9',
    },
    {
        id: 'hammer',
        label: 'Молот',
        reference: 'Compendium.cosmere-rpg.items.Item.OBPoBfwLrZg0Unz6',
    },
    {
        id: 'knife',
        label: 'Нож',
        reference: 'Compendium.cosmere-rpg.items.Item.k0aKCdFJU0m2lZbv',
    },
    {
        id: 'longsword',
        label: 'Длинный меч',
        reference: 'Compendium.cosmere-rpg.items.Item.yzR4gLjOV6njxdde',
    },
    {
        id: 'longspear',
        label: 'Длинное копьё',
        reference: 'Compendium.cosmere-rpg.items.Item.ex4dg2bXFpC5HTv6',
    },
    {
        id: 'mace',
        label: 'Булава',
        reference: 'Compendium.cosmere-rpg.items.Item.5sH5poLPx75U008u',
    },
    {
        id: 'shield',
        label: 'Щит',
        reference: 'Compendium.cosmere-rpg.items.Item.fV3Adif5imyAc5m5',
    },
    {
        id: 'shortbow',
        label: 'Короткий лук',
        reference: 'Compendium.cosmere-rpg.items.Item.VuNjyCtkobEQKdOx',
    },
    {
        id: 'shortspear',
        label: 'Короткое копьё',
        reference: 'Compendium.cosmere-rpg.items.Item.5CvSwkwuSRArPTM2',
    },
    {
        id: 'sidesword',
        label: 'Боковой меч',
        reference: 'Compendium.cosmere-rpg.items.Item.0mE1SpjOuNtgR0eq',
    },
    {
        id: 'staff',
        label: 'Посох',
        reference: 'Compendium.cosmere-rpg.items.Item.zyDACVYDa0N9N31r',
    },
];
function register$6() {
    WEAPONS.forEach((config) => cosmereRPG.api.registerWeapon({
        ...config,
        source: SYSTEM_ID,
        priority: -1,
    }));
}

const ARMOR = [
    {
        id: 'breastplate',
        label: 'Кираса',
        reference: 'Compendium.cosmere-rpg.items.Item.xLer8raOT6EkLfWN',
    },
    {
        id: 'chain',
        label: 'Кольчужная броня',
        reference: 'Compendium.cosmere-rpg.items.Item.6y5hONLMQa4O2wnU',
    },
    {
        id: 'full-plate',
        label: 'Латы',
        reference: 'Compendium.cosmere-rpg.items.Item.t97DN6FAh7BMNvcP',
    },
    {
        id: 'half-plate',
        label: 'Полулаты',
        reference: 'Compendium.cosmere-rpg.items.Item.GlrRu1goky9ifKCl',
    },
    {
        id: 'leather',
        label: 'Кожанная броня',
        reference: 'Compendium.cosmere-rpg.items.Item.dxty96So3kGZVhv5',
    },
    {
        id: 'uniform',
        label: 'Униформа',
        reference: 'Compendium.cosmere-rpg.items.Item.SRLLAWCE7rwS40Pv',
    },
];
function register$5() {
    ARMOR.forEach((config) => cosmereRPG.api.registerArmor({
        ...config,
        source: SYSTEM_ID,
        priority: -1,
    }));
}

function register$4() {
    // Register specific items
    register$6();
    register$5();
}

function register$3() {
    const secondary = [
        {
            id: 'diamond',
            label: 'Бриллиант',
            conversionRate: 1,
            base: true,
        },
        {
            id: 'garnet',
            label: 'Гранат',
            conversionRate: 5,
        },
        {
            id: 'heliodor',
            label: 'Гелиодор',
            conversionRate: 5,
        },
        {
            id: 'topaz',
            label: 'Топаз',
            conversionRate: 5,
        },
        {
            id: 'ruby',
            label: 'Рубин',
            conversionRate: 10,
        },
        {
            id: 'smokestone',
            label: 'Дымчатный кварц',
            conversionRate: 10,
        },
        {
            id: 'zircon',
            label: 'Циркон',
            conversionRate: 10,
        },
        {
            id: 'amethyst',
            label: 'Аметист',
            conversionRate: 25,
        },
        {
            id: 'sapphire',
            label: 'Cапфир',
            conversionRate: 25,
        },
        {
            id: 'emerald',
            label: 'Изумруд',
            conversionRate: 50,
        },
    ];
    cosmereRPG.api.registerCurrency({
        source: SYSTEM_ID,
        id: 'spheres',
        label: 'STORMLIGHT.Currency.Spheres',
        icon: 'systems/cosmere-rpg/assets/icons/stormlight/currency/spheres_infused.webp',
        denominations: {
            primary: [
                {
                    id: 'mark',
                    label: 'Марка',
                    unit: 'мк ●',
                    conversionRate: 1,
                    base: true,
                },
                {
                    id: 'chip',
                    label: 'Светосколок',
                    conversionRate: 0.2,
                },
                {
                    id: 'broam',
                    label: 'Броум',
                    conversionRate: 4,
                },
            ],
            secondary,
        },
        priority: -1,
    });
}

const ANCESTRIES = [
    {
        id: 'human',
        label: 'Человек',
        reference: 'Compendium.cosmere-rpg.ancestries.Item.q7t6vnxXBXDvsfhc',
    },
];
function register$2() {
    ANCESTRIES.forEach((config) => cosmereRPG.api.registerAncestry({
        ...config,
        source: SYSTEM_ID,
        priority: -1,
    }));
}

const CULTURES = [
    {
        id: 'alethi',
        label: 'Алети',
        reference: 'Compendium.cosmere-rpg.cultures.Item.oWJSlmauhHG57LrO',
    },
    {
        id: 'azish',
        label: 'Азирцы',
        reference: 'Compendium.cosmere-rpg.cultures.Item.PbkgODW2av4tBPdW',
    },
    {
        id: 'herdazian',
        label: 'Гердазийцы',
        reference: 'Compendium.cosmere-rpg.cultures.Item.nIOHtV8KoTdKH4FQ',
    },
    {
        id: 'thaylen',
        label: 'Тайленцы',
        reference: 'Compendium.cosmere-rpg.cultures.Item.yuZdO7YSfydUAdhu',
    },
    {
        id: 'unkalaki',
        label: 'Ункалаки',
        reference: 'Compendium.cosmere-rpg.cultures.Item.RDD4CJzcnb2mjXXC',
    },
    {
        id: 'veden',
        label: 'Веденцы',
        reference: 'Compendium.cosmere-rpg.cultures.Item.ZVXjqw4l30mNjAdq',
    },
    {
        id: 'reshi',
        label: 'Реши',
        reference: '',
    },
];
function register$1() {
    CULTURES.forEach((config) => cosmereRPG.api.registerCulture({
        ...config,
        source: SYSTEM_ID,
        priority: -1,
    }));
}

function register() {
    register$3();
    register$4();
    register$2();
    register$1();
}

Handlebars.registerHelper('component', (element, options) => {
    // Get id
    const id = options?.hash?.id;
    // Get classs
    const cssClass = options?.hash?.class;
    // Params to array
    const params = Object.entries(options?.hash ?? {})
        .filter(([key]) => key !== 'id' && key !== 'class')
        .map(([key, value]) => ({
        name: key,
        value: value,
        type: typeof value,
    }));
    // Params to string
    const paramsStr = params
        .map((param) => [
        `param-${param.name}="${param.value.toString()}"`,
        `param-${param.name}__type="${param.type}"`,
    ])
        .flat()
        .join(' ');
    // Return component with params
    return `<${element} ${id ? `id="${id}"` : ''} ${cssClass ? `class="${cssClass}"` : ''} ${paramsStr}></${element}>`;
});

Handlebars.registerHelper('add', (a, b) => a + b);
Handlebars.registerHelper('sub', (a, b) => a - b);
Handlebars.registerHelper('multi', (a, b) => a * b);
Handlebars.registerHelper('divide', (a, b) => a / b);
Handlebars.registerHelper('mod', (a, b) => a % b);
Handlebars.registerHelper('default', (v, defaultVal) => {
    return v ? v : defaultVal;
});
Handlebars.registerHelper('hasKey', (obj, path) => {
    // Split the path
    const keys = path.split('.');
    // Reduce the object
    return (keys.reduce((obj, key, i) => {
        if (typeof obj === 'boolean')
            return obj;
        const isLast = i === keys.length - 1;
        return obj && key in obj
            ? isLast
                ? true
                : obj[key]
                    ? obj[key]
                    : null
            : null;
    }, obj) !== null);
});
Handlebars.registerHelper('replace', (from, searchValue, replaceValue) => {
    return from.replaceAll(searchValue, replaceValue);
});
Handlebars.registerHelper('lower', (str) => str.toLowerCase());
Handlebars.registerHelper('upper', (str) => str.toUpperCase());
Handlebars.registerHelper('typeof', (value) => {
    if (value === null)
        return 'null';
    if (value === undefined)
        return 'undefined';
    if (Array.isArray(value))
        return 'array';
    return typeof value;
});
Handlebars.registerHelper('perc', (value, max, floor = true) => {
    const perc = (value / max) * 100;
    const str = floor ? Math.floor(perc).toFixed() : perc.toFixed(3);
    return `${str}%`;
});
Handlebars.registerHelper('times', (count, options) => [...Array(Number(count) || 0).keys()]
    .map((i) => options.fn(i, {
    data: options.data,
    blockParams: [i],
}))
    .join(''));
Handlebars.registerHelper('numberRange', (count, min) => Array.fromRange(count, min));
Handlebars.registerHelper('isNumMax', (value) => value === Number.MAX_VALUE);
Handlebars.registerHelper('cosmereDingbat', (type) => {
    switch (type) {
        case "fre" /* ActionCostType.FreeAction */:
            return '0';
        case "rea" /* ActionCostType.Reaction */:
            return 'r';
        case "spe" /* ActionCostType.Special */:
            return '*';
        default:
            return '';
    }
});
Handlebars.registerHelper('derived', (derived, includeBonus = true) => {
    if (!derived)
        return;
    return includeBonus ? derived.value : derived.base;
});
Handlebars.registerHelper('bonus', (obj) => {
    if (!obj)
        return;
    return obj.value + (obj.bonus ?? 0);
});
Handlebars.registerHelper('skillMod', (actor, skill, attribute) => {
    return actor.getSkillMod(skill, attribute);
});
Handlebars.registerHelper('formulaReplaceData', (formula, data) => {
    return Roll.replaceFormulaData(formula, data, { missing: '0' });
});
Handlebars.registerHelper('effect-duration', (effect) => {
    if (!effect.isTemporary)
        return '—';
    const seconds = effect.duration.seconds;
    const turns = effect.duration.turns;
    const rounds = effect.duration.rounds;
    if (seconds)
        return `${seconds}s`;
    else {
        return [
            rounds
                ? `${rounds} ${game.i18n.localize('GENERIC.Rounds')}`
                : null,
            turns ? `${turns} ${game.i18n.localize('GENERIC.Turns')}` : null,
        ]
            .filter((v) => !!v)
            .join(', ');
    }
});
Handlebars.registerHelper('inline-partial', (partialName, options) => {
    return new Handlebars.SafeString(Handlebars.partials[partialName](options?.hash).replace(/"/g, '&quot;'));
});
Handlebars.registerHelper('itemContext', (item, options) => {
    try {
        const context = {};
        const subtitle = [];
        const isWeapon = item.isWeapon();
        if (isWeapon) {
            context.isWeapon = true;
            const attack = item.system.attack;
            subtitle.push({
                text: game.i18n.localize(CONFIG.COSMERE.attack.types[attack.type].label),
            });
            if (attack.range?.value) {
                if (attack.type === "melee" /* AttackType.Melee */ &&
                    item.system.traits.reach?.active) {
                    subtitle[0].text += ` + ${attack.range.value}`;
                }
                else if (attack.type === "ranged" /* AttackType.Ranged */) {
                    subtitle[0].text += ` (${attack.range.value}${attack.range.unit}${attack.range.long
                        ? `/${attack.range.long}${attack.range.unit}`
                        : ''})`;
                }
            }
        }
        if (item.isArmor() && item.system.deflect) {
            subtitle.push({
                text: `${game.i18n.localize('COSMERE.Item.Armor.Deflect')} [${item.system.deflect}]`,
            });
        }
        if (item.isPhysical()) {
            context.isPhysical = true;
            context.hasQuantity = item.system.quantity !== null;
            context.hasWeight = item.system.weight.value !== null;
            context.quantity = item.system.quantity;
            context.weight = {
                value: item.system.weight.value,
                unit: item.system.weight.unit,
                total: parseFloat((item.system.quantity * item.system.weight.value).toFixed(2)),
            };
            context.price = {
                value: item.system.price.value,
                unit: item.system.price.unit,
            };
        }
        if (item.isEquippable() && !item.system.alwaysEquipped) {
            context.isEquippable = true;
            context.equipped = item.system.equipped;
            const type = item.system.equip.type;
            const hold = item.system.equip.hold;
            const hand = item.system.equip.hand;
            context.equip = {
                type,
                typeLabel: CONFIG.COSMERE.items.equip.types[type].label,
                hold,
                ...(hold
                    ? {
                        holdLabel: CONFIG.COSMERE.items.equip.hold[hold].label,
                    }
                    : {}),
                hand,
                ...(hand
                    ? {
                        handLabel: CONFIG.COSMERE.items.equip.hand[hand].label,
                    }
                    : {}),
            };
            if (options?.hash?.showEquippedHand !== false) {
                if (hold && hold !== "two_handed" /* HoldType.TwoHanded */) {
                    subtitle.push({
                        text: game.i18n.localize(CONFIG.COSMERE.items.equip.hold[hold].label),
                    });
                }
            }
        }
        if (item.hasTraits()) {
            subtitle.push(...item.system.traitsArray
                .filter((trait) => trait.active)
                .map((trait) => {
                // Get the config
                const config = isWeapon
                    ? CONFIG.COSMERE.traits.weaponTraits[trait.id]
                    : CONFIG.COSMERE.traits.armorTraits[trait.id];
                const modifiedByExpertise = trait.active !== trait.defaultActive ||
                    trait.value !== trait.defaultValue;
                return {
                    text: `${game.i18n.localize(config.label)} ${config.hasValue ? `[${trait.value}]` : ''}`.trim(),
                    classes: modifiedByExpertise
                        ? ['highlight']
                        : [],
                };
            })
                .sort((a, b) => a.classes.length - b.classes.length));
        }
        if (item.hasActivation()) {
            context.hasActivation = true;
            context.activation = {};
            if (item.system.activation.cost?.type) {
                context.activation.hasCost = true;
                context.activation.cost = {
                    type: item.system.activation.cost.type,
                    typeLabel: CONFIG.COSMERE.action.costs[item.system.activation.cost.type].label,
                    value: item.system.activation.cost.value,
                };
            }
            // Check if a skill test is configured
            if (item.system.activation.resolvedSkill) {
                const skill = item.system.activation.resolvedSkill;
                const attribute = item.system.activation.resolvedAttribute;
                context.hasSkillTest = true;
                context.skillTest = {
                    skill,
                    skillLabel: CONFIG.COSMERE.skills[skill].label,
                    usesDefaultAttribute: !attribute ||
                        attribute ===
                            CONFIG.COSMERE.skills[skill].attribute,
                    ...(attribute
                        ? {
                            attribute,
                            attributeLabel: CONFIG.COSMERE.attributes[attribute]
                                .label,
                            attributeLabelShort: CONFIG.COSMERE.attributes[attribute]
                                .labelShort,
                        }
                        : {}),
                };
            }
            // Check if the activation consumes some resource
            if (item.system.activation.consume) {
                context.consume = [];
                for (const consumable of item.system.activation.consume) {
                    const consumesResource = consumable.type === "resource" /* ItemConsumeType.Resource */;
                    const consumesItem = consumable.type === "item" /* ItemConsumeType.Item */;
                    // Get resource
                    const resource = consumable.resource;
                    context.hasConsume = true;
                    context.consume.push({
                        type: consumable.type,
                        value: consumable.value,
                        consumesResource,
                        consumesItem,
                        ...(resource
                            ? {
                                resource: consumable.resource,
                                resourceLabel: CONFIG.COSMERE.resources[resource]
                                    .label,
                            }
                            : {}),
                    });
                }
            }
            if (item.system.activation.uses) {
                const type = item.system.activation.uses.type;
                const value = item.system.activation.uses.value;
                const max = item.system.activation.uses.max;
                const recharge = item.system.activation.uses.recharge;
                const hasRecharge = recharge != null;
                // Get config
                const config = CONFIG.COSMERE.items.activation.uses.types[type];
                context.hasUses = true;
                context.uses = {
                    type,
                    value,
                    label: (max ?? value) > 1
                        ? config.labelPlural
                        : config.label,
                    max,
                    hasRecharge,
                    recharge,
                    rechargeLabel: hasRecharge
                        ? CONFIG.COSMERE.items.activation.uses.recharge[recharge].label
                        : '',
                };
            }
        }
        if (item.hasDamage() && item.system.damage.formula) {
            const skill = item.system.damage.skill;
            const attribute = item.system.damage.attribute;
            const hasSkill = !!skill;
            const hasAttribute = !!attribute;
            context.hasDamage = true;
            context.damage = {
                formula: item.system.damage.formula,
                formulaData: {
                    ...item.actor?.getRollData(),
                },
                hasSkill,
                hasAttribute,
                ...(hasSkill
                    ? {
                        skill,
                        skillLabel: CONFIG.COSMERE.skills[skill].label,
                        usesDefaultAttribute: !hasAttribute ||
                            attribute ===
                                CONFIG.COSMERE.skills[skill].attribute,
                    }
                    : {}),
                ...(hasAttribute
                    ? {
                        attribute,
                        attributeLabel: CONFIG.COSMERE.attributes[attribute].label,
                        attributeLabelShort: CONFIG.COSMERE.attributes[attribute]
                            .labelShort,
                    }
                    : {}),
                ...(item.system.damage.type
                    ? {
                        type: item.system.damage.type,
                        typeLabel: CONFIG.COSMERE.damageTypes[item.system.damage.type].label,
                    }
                    : {}),
            };
        }
        if (item.isAction()) {
            subtitle.push({
                text: game.i18n.localize(CONFIG.COSMERE.action.types[item.system.type].label),
            });
        }
        return {
            ...context,
            subtitle: subtitle
                .map(({ text, classes }) => `<span class=${(classes ?? []).join(' ')}>${text}</span>`)
                .join('<span>, </span>'),
        };
    }
    catch (err) {
        console.error(err);
        throw err;
    }
});
Handlebars.registerHelper('damageTypeConfig', (type) => {
    return CONFIG.COSMERE.damageTypes[type];
});
Handlebars.registerHelper('getCombatActedState', (turn) => {
    // use default activated for boss slow turns, and all other combatants' turns
    if (!turn.isBoss || turn.turnSpeed === "slow" /* TurnSpeed.Slow */) {
        return turn.activated;
    }
    // track a boss's additional fast turn separately
    return turn.bossFastActivated;
});
/**
 * Get the resource cost label of an item in an actor's action list
 */
Handlebars.registerHelper('resourceCostLabel', (consume) => {
    const { value } = consume;
    const resource = game.i18n.localize(consume.resource
        ? CONFIG.COSMERE.resources[consume.resource].label
        : 'GENERIC.Unknown');
    let label = '';
    // Get adjusted minimum value, to account for optional formatting
    const adjustedMin = Math.max(value.min, 1);
    // Static range
    if (adjustedMin === value.max) {
        label = game.i18n.format('COSMERE.Actor.Sheet.Actions.Consume.Static', {
            amount: adjustedMin,
            resource,
        });
    }
    // Uncapped range
    else if (value.max === -1) {
        label = game.i18n.format('COSMERE.Actor.Sheet.Actions.Consume.RangeUncapped', {
            amount: adjustedMin,
            resource,
        });
    }
    // Capped range
    else {
        label = game.i18n.format('COSMERE.Actor.Sheet.Actions.Consume.RangeCapped', {
            min: adjustedMin,
            max: value.max,
            resource,
        });
    }
    // Treat actual minimum value of 0 as an "optional" cost
    if (value.min === 0) {
        label = game.i18n.format('COSMERE.Actor.Sheet.Actions.Consume.Optional', {
            label,
        });
    }
    return label;
});
/**
 * Format the resource cost input field of an item's activation config
 */
Handlebars.registerHelper('resourceCostInput', (value) => {
    if (value.min === value.max) {
        return value.min.toString();
    }
    else if (value.max === -1) {
        return `${value.min}+`;
    }
    else {
        return `${value.min}-${value.max}`;
    }
});
Handlebars.registerHelper('entries', (obj) => {
    return Object.entries(obj).map(([key, value]) => ({ key, value }));
});
Handlebars.registerHelper('filterSelectOptions', ((selectOptions, ...args) => {
    if (typeof selectOptions === 'function')
        selectOptions = selectOptions();
    const filters = args.slice(0, -1);
    args[args.length - 1];
    const filterSet = new Set(filters);
    return Object.entries(selectOptions)
        .filter(([key]) => !filterSet.has(key))
        .reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
    }, {});
}));
async function preloadHandlebarsTemplates() {
    const templates = Object.values(TEMPLATES).reduce((partials, path) => {
        partials[path.split('/').pop().replace('.hbs', '')] =
            `systems/${SYSTEM_ID}/templates/${path}`;
        return partials;
    }, {});
    return await loadTemplates(templates);
}

const EnricherStyleOptions = {
    capitalize: (value) => value.capitalize(),
    lowercase: (value) => value.toLocaleLowerCase(),
    uppercase: (value) => value.toLocaleUpperCase(),
};
/*
 * Note: Left in some commented out options that I copied across
 * from the 5e implementation that we might want to use later */
function registerCustomEnrichers() {
    const stringNames = ['test', 'damage', 'healing', 'item'];
    CONFIG.TextEditor.enrichers.push({
        pattern: new RegExp(`\\[\\[(?<type>${stringNames.join('|')}) (?<config>[^\\]]+)]](?:{(?<label>[^}]+)})?`, 'gi'),
        enricher: enrichString,
    }, {
        pattern: /\[\[(?<type>lookup) (?<config>[^\]]+)]](?:{(?<label>[^}]+)})?/gi,
        enricher: enrichString,
    }, 
    // {
    //   pattern: /&(?<type>Reference)\[(?<config>[^\]]+)](?:{(?<label>[^}]+)})?/gi,
    //   enricher: enrichString
    // }
    {
        pattern: /@Link\[(?<uuid>.+)\]/gi,
        enricher: (match, options) => {
            // Get the UUID from the match
            const uuid = match.groups?.uuid;
            if (!uuid)
                return null;
            // Create section element
            const section = document.createElement('section');
            // Add classes
            section.classList.add('content-link-anchor');
            // Parse the uuid
            const { id, collection, type } = foundry.utils.parseUuid(uuid);
            // Set attributes
            section.setAttribute('draggable', 'true');
            section.setAttribute('data-link', '');
            section.dataset.uuid = uuid;
            section.dataset.id = id;
            section.dataset.type = type;
            if (collection instanceof CompendiumCollection)
                section.dataset.pack = collection.collection;
            // Return the section element
            return section;
        },
    }, {
        pattern: /@Link/gi,
        enricher: (match, options) => {
            // Create section element
            const section = document.createElement('section');
            section.classList.add('content-link-anchor');
            return section;
        },
    });
}
/* --- Helpers --- */
/**
 * Parse the enriched string and provide the appropriate content.
 * @param {RegExpMatchArray}                match       The regular expression match result.
 * @param {TextEditor.EnrichmentOptions}    options    Options provided to customize text enrichment.
 * @returns {Promise<HTMLElement|null>}     An HTML element to insert in place of the matched text or null to
 *                                          indicate that no replacement should be made.
 */
function enrichString(match, options) {
    const { type, label, config } = match.groups;
    const processedConfig = parseConfig(config);
    processedConfig._input = match[0];
    switch (type.toLowerCase()) {
        case 'healing': {
            processedConfig.healing = true;
            return enrichDamage(processedConfig, label, options);
        }
        case 'damage':
            return enrichDamage(processedConfig, label, options);
        case 'test':
            return enrichTest(processedConfig, label, options);
        case 'lookup':
            return enrichLookup(processedConfig, label, options);
        // case "item": return enrichItem(config, label, options);
        // case "reference": return enrichReference(config, label, options);
    }
    return null;
}
/**
 * Parse a roll string into a configuration object.
 * @param {string} match  Matched configuration string.
 * @returns {object}
 */
function parseConfig(match) {
    const config = { _config: match, values: [] };
    for (const part of match.match(/(?:[^\s"]+|"[^"]*")+/g) ?? []) {
        if (!part)
            continue;
        const [key, value] = part.split('=');
        const valueLower = value?.toLowerCase();
        if (value) {
            config[key] = ['true', 'false'].includes(valueLower)
                ? // convert number/boolean values to their primitives
                    valueLower === 'true'
                : Number.isNumeric(value)
                    ? Number(value)
                    : // otherwise it's a string, we just trim any "s
                        value.replace(/(^"|"$)/g, '');
            continue;
        }
        config.values.push(key.replace(/(^"|"$)/g, ''));
    }
    return config;
}
function createErrorSpan(text) {
    const span = document.createElement('span');
    span.innerText = `[${game.i18n?.localize('GENERIC.Enrichers.Error')} - ${game.i18n?.localize(text)}]`;
    return span;
}
function buildTestLabel(config, skill, attr) {
    let linkLabel = '', postLink = '';
    if (skill) {
        linkLabel = `${game.i18n?.localize(skill.label)} `;
        const attributeName = attr
            ? game.i18n?.localize(attr?.label)
            : undefined;
        if (attributeName) {
            linkLabel = `${linkLabel}(${attributeName}) `;
        }
        linkLabel = `${linkLabel}${game.i18n?.localize('GENERIC.Test')}`;
    }
    if (config.dc && !config.defense)
        postLink = `${game.i18n?.localize('GENERIC.Enrichers.Test.Against')} ${game.i18n?.localize('GENERIC.DC')} ${config.dc}`;
    if (config.defense)
        postLink = `${game.i18n?.localize('GENERIC.Enrichers.Test.VsDefense')} ${config.defenseName} ${game.i18n?.localize('COSMERE.Actor.Statistics.Defense')}${config.dc ? ` (${game.i18n?.localize('GENERIC.DC')}: ${config.dc})` : ''}`;
    return { linkLabel, postLink };
}
function createRollLink(linkLabel, postLink, type, options) {
    const span = document.createElement('span');
    span.classList.add('enricher-link');
    span.innerHTML = `
        <a onclick="Hooks.call('${SYSTEM_ID}.trigger${type.titleCase()}Enricher', &quot;${options?.actorId}&quot;, &quot;${options?.source}&quot;, ${JSON.stringify(options?.data).replaceAll('"', '&quot;')})">
            <i class="fa-solid fa-dice-d20"></i> ${linkLabel}
        </a> ${postLink}
    `;
    return span;
}
/* --- Enrichers --- */
/**
 * Enrich a property lookup.
 * @param {object} config                         Configuration data.
 * @param {string} [fallback]                     Optional fallback if the value couldn't be found.
 * @param {TextEditor.EnrichmentOptions} options  Options provided to customize text enrichment.
 * @returns {HTMLElement|null}                    An HTML element if the lookup could be built, otherwise null.
 *
 * @example Include an actor's name in its description:
 * ```[[lookup @actor.name]]``
 * becomes
 * ```html
 * <span class="lookup-value">Actor Name</span>
 * ```
 * For full examples see https://github.com/the-metalworks/cosmere-rpg/wiki/Enrichers#data-lookups
 */
function enrichLookup(config, fallback, options) {
    // Pull out the values passed in
    let keyPath = config.path;
    let style = config.style;
    for (const value of config.values) {
        // get the data field name
        if (value.startsWith('@'))
            keyPath ??= value;
        // if this wasn't the keyPath then flag any of the accepted style options
        style ??= Object.keys(EnricherStyleOptions).includes(value)
            ? value
            : undefined; // discard anything else
    }
    if (!keyPath) {
        return createErrorSpan('GENERIC.Enrichers.Lookup.NoPath');
    }
    const data = options?.relativeTo &&
        (options.relativeTo instanceof CosmereItem ||
            options.relativeTo instanceof CosmereActor)
        ? options.relativeTo.getEnricherData()
        : null;
    let value = foundry.utils.getProperty(data ?? {}, keyPath.substring(1)) ?? fallback;
    if (value &&
        style &&
        style in
            Object.keys(EnricherStyleOptions)
    // belt-and-braces to make sure we're only dealing with specifically accepted keywords
    ) {
        value =
            EnricherStyleOptions[style](value);
    }
    // insert the HTML element with the value
    const span = document.createElement('span');
    span.classList.add('lookup-value');
    if (!value)
        span.classList.add('not-found');
    span.innerText = value ?? keyPath;
    return span;
}
/**
 * Enrich a Test (dice roll) link to perform a specific attribute or skill test. If an attribute is provided
 * along with a skill, then the skill test will always use the provided attribute. Otherwise it will use
 * the character's default attribute for that skill.
 * @param {object} config                           Configuration data.
 * @param {string} [label]                          Optional label to replace default text.
 * @param {TextEditor.EnrichmentOptions} options    Options provided to customize text enrichment.
 * @returns {HTMLElement|null}                      An HTML link if the check could be built, otherwise null.
 *
 * @example Create an Intimidation test:
 * ```[[test skill=inm]]```
 * becomes
 * ```html
 * <span class="enricher-link">
 *      <a onclick="Hooks.on('cosmere-rpg.triggerTestEnricher', "Actor.####", "Source.uuid",{"skill":"inm", "attribute"=""})">
 *          <i class="fa-solid fa-dice-d20"></i> Intimidation test
 *      </a>
 * </span>
 * ```
 *
 * For full examples see https://github.com/the-metalworks/cosmere-rpg/wiki/Enrichers#tests
 */
function enrichTest(config, label, options) {
    const source = options?.relativeTo;
    let skillConfig = undefined;
    let attributeConfig = undefined;
    if (config.skill && typeof config.skill === 'string') {
        skillConfig = CONFIG.COSMERE.skills[config.skill];
    }
    if (!skillConfig) {
        return createErrorSpan('GENERIC.Enrichers.Test.NoSkill');
    }
    if (config.attribute && typeof config.attribute === 'string') {
        attributeConfig =
            CONFIG.COSMERE.attributes[config.attribute];
    }
    const data = source.getEnricherData();
    if (config.dc && typeof config.dc === 'string') {
        try {
            const evaluator = new Roll(config.dc, data);
            config.dc = evaluator.isDeterministic
                ? evaluator.evaluateSync().total
                : 0;
        }
        catch (error) {
            console.error(error);
            config.dc = 0;
        }
    }
    // Account for regional differences
    if (config.defence) {
        config.defense = config.defence;
        delete config.defence;
    }
    if (config.defense) {
        config.defenseName =
            game.i18n?.localize(CONFIG.COSMERE.attributeGroups[config.defense]
                .label) ??
                game.i18n?.localize('COSMERE.Actor.Statistics.Defense') ??
                'Bad Config';
        config.dc =
            data.target?.def[config.defense] ?? 0;
    }
    const labelText = label
        ? { linkLabel: label, postLink: '' }
        : buildTestLabel(config, skillConfig, attributeConfig);
    const linkOptions = {
        actorId: source instanceof CosmereActor
            ? source.uuid
            : (source.actor?.uuid ?? ''),
        source: source?.uuid ?? '',
        data: {
            skill: skillConfig?.key ?? '',
            attribute: attributeConfig?.key ?? '',
            dc: config.dc,
            target: data.target,
        },
    };
    return createRollLink(labelText.linkLabel, labelText.postLink, 'test', linkOptions);
}
/**
 * Enrich the text with a button to make a roll and produce a damage/healing chat card.
 *
 * @param {object} config                           Configuration data.
 * @param {string} [label]                          Optional label to replace default text.
 * @param {TextEditor.EnrichmentOptions} options    Options provided to customize text enrichment.
 * @returns {HTMLElement|null}                      An HTML link if the check could be built, otherwise null.
 *
 * @example Simple damage roll:
 * ```[[damage 2d8 Vital]]```
 * becomes
 * ```html
 * <span class="enricher-link">
 *      <a onclick="Hooks.on('cosmere-rpg.triggerDamageEnricher', "Actor.####", "Source.uuid",{"formula":"2d8", "damageType":"vital"})">
 *          <i class="fa-solid fa-dice-d20"></i> 2d8 Vital
 *      </a> damage
 * </span>
 * ```
 *
 * For full examples see https://github.com/the-metalworks/cosmere-rpg/wiki/Enrichers#damage--healing
 */
async function enrichDamage(config, label, options) {
    const formulaParts = [];
    // extract input params
    const { values } = config;
    let { formula, type, healing, setValue } = config;
    if (formula)
        formulaParts.push(formula);
    if (healing) {
        if (type)
            return createErrorSpan('GENERIC.Enrichers.Damage.DoubleTyped');
        type = 'Healing';
    }
    if (type === 'Healing')
        healing = true;
    for (const value of values) {
        if (value.toLowerCase() === 'average') {
            if (!setValue)
                setValue = true;
        }
        else if (value.toLowerCase() === 'healing' ||
            value.toLowerCase() === 'heal') {
            if (!healing) {
                healing = true;
                type = 'Healing';
            }
        }
        else if (value in DamageType) {
            if (!type)
                type = value;
            if (value.toLowerCase() === 'healing')
                healing = true;
        }
        else
            formulaParts.push(value);
    }
    // Check we got things passed in correctly
    if (formulaParts.length === 0)
        return createErrorSpan('GENERIC.Enrichers.Damage.NoFormula');
    if (!type)
        return createErrorSpan('GENERIC.Enrichers.Damage.NoType');
    if (typeof type !== 'string' || !(type in DamageType))
        return createErrorSpan('GENERIC.Enrichers.Damage.BadType');
    const source = options?.relativeTo;
    // grab the actor (we need the roll data unfortunately)
    const data = source.getEnricherData();
    // convert any actor properties passed in. Note: currently it doesn't collate like terms...
    // This will need tweaking when allowing multiple damage types if we got that route
    const terms = Roll.simplifyTerms(Roll.defaultImplementation.parse(formulaParts.join(' + '), data.actor ?? {}));
    formula = terms.map((t) => t.formula).join(' ');
    // calculate the average
    const minRoll = Roll.create(formula).evaluate({ minimize: true });
    const maxRoll = Roll.create(formula).evaluate({ maximize: true });
    const rawAverage = Math.floor(((await minRoll).total + (await maxRoll).total) / 2);
    if (setValue && typeof setValue !== 'number')
        setValue = rawAverage;
    // Set up the display content
    // encode the data for the click action
    const linkOptions = {
        actorId: source instanceof CosmereActor
            ? source.uuid
            : (source.actor?.uuid ?? ''),
        source: source?.uuid ?? '',
        data: {
            formula: setValue,
            healing,
            damageType: healing ? 'heal' : type.toLowerCase(),
        },
    };
    // get values for localize
    if (type.toLowerCase() in CONFIG.COSMERE.damageTypes){
      type = game.i18n.localize(CONFIG.COSMERE.damageTypes[type.toLowerCase()].label)
    }
    if (type.toLowerCase() == "healing"){
      type = game.i18n.localize("GENERIC.Healing")     
    }
      
    const damage_localize = " " + game.i18n.localize("DICE.Damage.Label") 

    // If there is a set value given, we'll need a pair of links
    const container = document.createElement('span');
    if (setValue) {
        const valueLink = createRollLink(`${setValue}`, '', 'damage', linkOptions);
        container.insertAdjacentElement('afterbegin', valueLink);
    }
    linkOptions.data.formula = formula;
    const labelText = label
        ? label
        : `${setValue ? `(` : ''}${formula}${setValue ? ')' : ''} ${type}`;
    
    const poolLink = createRollLink(labelText, !healing && !label ? damage_localize : '', 'damage', linkOptions);
    container.insertAdjacentElement('beforeend', poolLink);
    return container;
}

// Constants
const INVALID_CHARS_REGEX = /[^a-z0-9-_\s]/g;
class IdInputComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.COMPONENT_ID_INPUT}`;
    /* --- Lifecyle --- */
    _onAttachListeners() {
        // Get input element
        const input = this.element.querySelector('input');
        // Add event listeners
        input.addEventListener('change', this.onChange.bind(this));
    }
    onChange(event) {
        event.preventDefault();
        // Get input
        const input = event.target;
        // Clean value
        const value = input.value
            .trim()
            .toLowerCase()
            .replace(INVALID_CHARS_REGEX, '')
            .replace(/\s+/g, ' ')
            .trim()
            .split(' ')
            .join('-');
        // Set value
        input.value = value;
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            ...params,
        });
    }
}
// Register the component
IdInputComponent.register('app-id-input');

// Component imports
class MultiStateToggleComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.COMPONENT_MULTI_STATE_TOGGLE}`;
    get states() {
        if (Array.isArray(this.params.states)) {
            return this.params.states.reduce((acc, state) => ({
                ...acc,
                [state]: {
                    label: state,
                },
            }), {});
        }
        else {
            return Object.entries(this.params.states).reduce((acc, [key, value]) => ({
                ...acc,
                [key]: typeof value === 'string' ? { label: value } : value,
            }), {});
        }
    }
    get selected() {
        return this.params.selected ?? Object.keys(this.states)[0];
    }
    get numStates() {
        return Object.keys(this.states).length;
    }
    get selectedIndex() {
        return Object.keys(this.states).indexOf(this.selected);
    }
    /* --- Lifecyle --- */
    _onRender(params) {
        if (params.name)
            $(this.element).attr('name', params.name);
    }
    _onAttachListeners() {
        // Get input elements
        const input = $(this.element).find('input');
        // Add event listeners
        input.on('change', this.onChange.bind(this));
    }
    onChange(event) {
        event.preventDefault();
        event.stopPropagation();
        // Get input
        const input = event.target;
        // Get the state
        const state = input.dataset.id;
        // Set value
        $(this.element).attr('value', state);
        // Trigger change event
        $(this.element).trigger('change', new InputEvent('change'));
        // Update params
        this.params.selected = state;
        // Update offset
        const stateWidth = 100 / this.numStates;
        const selectedOffset = stateWidth * this.selectedIndex;
        $(this.element)
            .find('.selected')
            .css('background-color', this.states[state].color ?? '')
            .css('left', `${selectedOffset.toFixed(3)}%`);
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        const stateWidth = 100 / this.numStates;
        const selectedOffset = stateWidth * this.selectedIndex;
        return Promise.resolve({
            ...context,
            ...params,
            id: this.id,
            value: this.selected,
            states: Object.entries(this.states).map(([key, config]) => ({
                key,
                label: params.localize !== false
                    ? game.i18n.localize(config.label)
                    : config.label,
                color: config.color,
                selected: key === this.selected,
            })),
            stateWidth: `${stateWidth.toFixed(3)}%`,
            selectedOffset: `${selectedOffset.toFixed(3)}%`,
            selectedColor: this.states[this.selected].color,
        });
    }
}
// Register the component
MultiStateToggleComponent.register('app-multi-state-toggle');

function DragDropApplicationMixin(base) {
    return class mixin extends base {
        _dragDrop;
        // NOTE: Must use any to comply with mixin constructor signature
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args) {
            super(...args);
            this._dragDrop = this.createDragDropHandlers();
        }
        createDragDropHandlers() {
            return (this.options.dragDrop ?? []).map((d) => new DragDrop({
                ...d,
                permissions: {
                    dragstart: this._canDragStart.bind(this),
                    drop: this._canDragDrop.bind(this),
                },
                callbacks: {
                    dragstart: this._onDragStart.bind(this),
                    dragover: this._onDragOver.bind(this),
                    drop: this._onDrop.bind(this),
                },
            }));
        }
        /* --- Accessors --- */
        get dragDrop() {
            return this._dragDrop;
        }
        /* --- Lifecycle --- */
        // See note above
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        _onRender(context, options) {
            super._onRender(context, options);
            // Bind handlers
            this._dragDrop.forEach((d) => d.bind(this.element));
        }
        /* --- Functions --- */
        _canDragStart(selector) {
            return false;
        }
        _canDragDrop(selector) {
            return false;
        }
        _onDragStart(event) { }
        _onDragOver(event) { }
        _onDrop(event) { }
    };
}
function DragDropComponentMixin(base) {
    return class mixin extends base {
        static DRAG_DROP = [];
        _dragDrop;
        // NOTE: Must use any to comply with mixin constructor signature
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args) {
            super(...args);
            this._dragDrop = this.createDragDropHandlers();
        }
        createDragDropHandlers() {
            const dragDrop = this.constructor.DRAG_DROP;
            return dragDrop.map((d) => new DragDrop({
                ...d,
                permissions: {
                    dragstart: this._canDragStart.bind(this),
                    drop: this._canDragDrop.bind(this),
                },
                callbacks: {
                    dragstart: this._onDragStart.bind(this),
                    dragover: this._onDragOver.bind(this),
                    drop: this._onDrop.bind(this),
                },
            }));
        }
        /* --- Lifecyle --- */
        _onAttachListeners(params) {
            super._onAttachListeners(params);
            // Bind handlers
            this._dragDrop.forEach((d) => d.bind(this.element));
        }
        /* --- Functions --- */
        _canDragStart(selector) {
            return false;
        }
        _canDragDrop(selector) {
            return false;
        }
        _onDragStart(event) { }
        _onDragOver(event) { }
        _onDrop(event) { }
    };
}

class DocumentReferenceInputComponent extends DragDropComponentMixin((HandlebarsApplicationComponent)) {
    static FORM_ASSOCIATED = true;
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.COMPONENT_DOCUMENT_REFERENCE}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        clear: this.onClear,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    static DRAG_DROP = [
        {
            dropSelector: '*',
        },
    ];
    _value = '';
    _name;
    /* --- Accessors --- */
    get element() {
        return super.element;
    }
    get readonly() {
        return this.params?.readonly === true;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        // Set value
        this.element.value = value;
        // Dispatch change event
        this.element.dispatchEvent(new Event('change', { bubbles: true }));
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
        // Set name
        this.element.name = value;
        $(this.element).attr('name', value ?? '');
    }
    /* --- Actions --- */
    static async onClear() {
        this._value = '';
        await this.render();
    }
    /* --- Drag drop --- */
    _canDragDrop() {
        return !this.readonly;
    }
    _onDragOver(event) {
        if (this.readonly)
            return;
        $(this.element).find('.drop-area').addClass('dropping');
    }
    async _onDrop(event) {
        if (this.readonly)
            return;
        // Remove dragover class
        $(this.element).find('.drop-area').removeClass('dropping');
        // Get data
        const data = TextEditor.getDragEventData(event);
        // Validate type
        if (this.params.type && data.type !== this.params.type) {
            return ui.notifications.warn(game.i18n.format('COMPONENT.DocumentReferenceInput.Warning.WrongType', {
                type: this.params.type,
            }));
        }
        if (this.params?.type && this.params?.subtype) {
            // Get document
            const doc = (await fromUuid(data.uuid));
            // Validate subtype
            if (doc.type !== this.params.subtype) {
                const subtypeLabel = CONFIG[this.params.type].typeLabels[this.params.subtype];
                return ui.notifications.warn(game.i18n.format('COMPONENT.DocumentReferenceInput.Warning.WrongSubtype', {
                    type: this.params.type,
                    subtype: game.i18n.localize(subtypeLabel),
                }));
            }
        }
        // Set value
        this.value = data.uuid;
        // Render
        void this.render();
    }
    /* --- Lifecycle --- */
    _onInitialize() {
        if (this.params.value) {
            this._value = this.params.value ?? '';
        }
    }
    _onAttachListeners(params) {
        super._onAttachListeners(params);
        $(this.element).on('dragleave', () => {
            $(this.element).find('.drop-area').removeClass('dropping');
        });
    }
    _onRender(params) {
        super._onRender(params);
        // Set value
        this.element.value = this.value ?? '';
        // Set name
        if (this.params.name) {
            this.name = this.params.name;
        }
        // Set readonly
        if (this.params.readonly) {
            $(this.element).attr('readonly', 'readonly');
        }
    }
    /* --- Context --- */
    async _prepareContext(params) {
        // Look up the document
        const doc = this.value
            ? (await fromUuid(this.value))
            : undefined;
        // Generate content link
        const contentLink = doc
            ? new Handlebars.SafeString(doc.toAnchor().outerHTML)
            : undefined;
        const subtypeLabel = params.type && params.subtype
            ? CONFIG[params.type].typeLabels[params.subtype]
            : undefined;
        // Format default placeholder
        const defaultPlaceholder = game.i18n.format('COMPONENT.DocumentReferenceInput.Placeholder', {
            type: game.i18n.localize(subtypeLabel ?? params.type ?? 'GENERIC.Document'),
        });
        return {
            value: this.value,
            placeholder: params.placeholder,
            readonly: params.readonly,
            contentLink,
            defaultPlaceholder,
        };
    }
}
// Register the component
DocumentReferenceInputComponent.register('app-document-reference-input');

class MultiValueSelectComponent extends HandlebarsApplicationComponent {
    static FORM_ASSOCIATED = true;
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.COMPONENT_MULTI_VALUE_SELECT}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        remove: this.onRemove,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    _value = [];
    _name;
    /* --- Accessors --- */
    get element() {
        return super.element;
    }
    get readonly() {
        return this.params?.readonly === true;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        // Set value
        this.element.value = value;
        // Dispatch change event
        this.element.dispatchEvent(new Event('change', { bubbles: true }));
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
        // Set name
        this.element.name = value;
        $(this.element).attr('name', value ?? '');
    }
    get placeholder() {
        return this.params?.placeholder;
    }
    /* --- Actions --- */
    static onRemove(event) {
        // Get key
        const key = $(event.target).closest('[data-id]').data('id');
        // Remove value
        this.value = this.value.filter((value) => value !== key);
        // Rerender
        void this.render();
    }
    /* --- Lifecycle --- */
    _onInitialize() {
        if (this.params.value) {
            this._value = this.params.value ?? [];
        }
    }
    _onAttachListeners(params) {
        super._onAttachListeners(params);
        // Handle select change
        $(this.element)
            .find('select')
            .on('change', (event) => {
            const value = $(event.currentTarget).val();
            // Add value
            this.value = [...this.value, value];
            // Rerender
            void this.render();
        });
    }
    _onRender(params) {
        super._onRender(params);
        // Set value
        this.element.value = this.value ?? '';
        // Set name
        if (this.params.name) {
            this.name = this.params.name;
        }
        // Set readonly
        if (this.params.readonly) {
            $(this.element).attr('readonly', 'readonly');
        }
    }
    /* --- Context --- */
    _prepareContext(params) {
        // Default options
        params.options ??= [];
        // Prepare options
        let options = foundry.utils.getType(params.options) === 'function'
            ? params.options()
            : params.options;
        options =
            foundry.utils.getType(options) === 'Object'
                ? foundry.utils.deepClone(options)
                : options.reduce((acc, key) => ({ ...acc, [key]: key }), {});
        // Prepare selected
        const selected = this._value.map((key) => ({
            key,
            label: options[key],
        }));
        // Remove selected from options
        this._value.forEach((key) => delete options[key]);
        return Promise.resolve({
            selected,
            options,
            readonly: this.readonly,
            placeholder: this.placeholder,
        });
    }
}
// Register the component
MultiValueSelectComponent.register('app-multi-value-select');

class DocumentDropListComponent extends DragDropComponentMixin((HandlebarsApplicationComponent)) {
    static FORM_ASSOCIATED = true;
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.COMPONENT_DOCUMENT_DROP_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'remove-document': this.onRemoveDocument,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    static DRAG_DROP = [
        {
            dropSelector: '*',
        },
    ];
    _value = [];
    _name;
    /* --- Accessors --- */
    get element() {
        return super.element;
    }
    get readonly() {
        return this.params?.readonly === true;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        // Set value
        this.element.value = value;
        // Dispatch change event
        this.element.dispatchEvent(new Event('change', { bubbles: true }));
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
        // Set name
        this.element.name = value;
        $(this.element).attr('name', value ?? '');
    }
    get placeholder() {
        return this.params?.placeholder;
    }
    /* --- Actions --- */
    static onRemoveDocument(event) {
        // Get key
        const key = $(event.target).closest('[data-id]').data('id');
        // Remove document
        this.value = this.value.filter((v) => v !== key);
        // Rerender
        void this.render();
    }
    /* --- Drag drop --- */
    _canDragDrop() {
        return !this.readonly;
    }
    _onDragOver(event) {
        if (this.readonly)
            return;
        $(this.element).find('.drop-area').addClass('dropping');
    }
    async _onDrop(event) {
        if (this.readonly)
            return;
        // Remove dragover class
        $(this.element).find('.drop-area').removeClass('dropping');
        // Get data
        const data = TextEditor.getDragEventData(event);
        // Ensure the document is not already in the list
        if (this.value.includes(data.uuid)) {
            return ui.notifications.warn(game.i18n.format('COMPONENT.DocumentDropListComponent.Warning.DocumentAlreadyInList', {
                type: this.params.type ??
                    game.i18n.localize('GENERIC.Document'),
            }));
        }
        // Validate type
        if (this.params.type && data.type !== this.params.type) {
            return ui.notifications.warn(game.i18n.format('COMPONENT.DocumentDropListComponent.Warning.WrongType', {
                type: this.params.type,
            }));
        }
        // Validate subtype
        if (this.params.subtype) {
            // Get document
            const doc = (await fromUuid(data.uuid));
            if (doc.data.type !== this.params.subtype) {
                return ui.notifications.warn(game.i18n.format('COMPONENT.DocumentDropListComponent.Warning.WrongSubtype', {
                    subtype: this.params.subtype,
                }));
            }
        }
        // Add document to the list
        this.value = [...this.value, data.uuid];
        // Render
        void this.render();
    }
    /* --- Lifecycle --- */
    _onInitialize(params) {
        super._onInitialize(params);
        if (this.params.value) {
            this._value = this.params.value;
        }
    }
    _onAttachListeners(params) {
        super._onAttachListeners(params);
        $(this.element).on('dragleave', () => {
            $(this.element).find('.drop-area').removeClass('dropping');
        });
    }
    _onRender(params) {
        super._onRender(params);
        // Set value
        this.element.value = this.value ?? [];
        // Set name
        if (this.params.name) {
            this.name = this.params.name;
        }
        // Set readonly
        if (this.params.readonly) {
            $(this.element).attr('readonly', 'readonly');
        }
    }
    /* --- Context --- */
    async _prepareContext(params) {
        // Look up the documents
        const docs = (await Promise.all(this.value.map(async (uuid) => (await fromUuid(uuid))))).filter((v) => !!v);
        return {
            ...params,
            value: this.value,
            documents: docs.map((doc) => ({
                uuid: doc.uuid,
                link: doc.toAnchor().outerHTML,
            })),
        };
    }
}
// Register the component
DocumentDropListComponent.register('app-document-drop-list');

function getItemIdFromEvent(event) {
    if (!event.target && !event.currentTarget)
        return;
    const element = $(event.target ?? event.currentTarget).closest('.item[data-item-id]');
    if (element.length === 0)
        return;
    return element.data('item-id');
}
function getItemFromEvent(event, actor) {
    // Get id
    const itemId = getItemIdFromEvent(event);
    // Find the item
    return actor.items.find((i) => i.id === itemId);
}
function getItemFromElement(element, actor) {
    // Get the id
    const itemId = $(element)
        .closest('.item[data-item-id]')
        .data('item-id');
    // Find the item
    return actor.items.find((i) => i.id === itemId);
}
var AppUtils = {
    getItemIdFromEvent,
    getItemFromEvent,
    getItemFromElement,
};

// Constants
const PRIMARY_TAB_GROUP = 'primary';
/**
 * Mixin that adds standardized tabs to an ApplicationV2
 */
function TabsApplicationMixin(base) {
    return class mixin extends base {
        /**
         * Tabs available for this Application
         */
        static TABS = {};
        tabGroups = {};
        _tabs;
        get tab() {
            return this.tabGroups[PRIMARY_TAB_GROUP] ?? '';
        }
        get tabs() {
            if (!this._tabs)
                this._tabs = this.constructor.TABS;
            return this._tabs;
        }
        changeTab(tab, group, options) {
            super.changeTab(tab, group, options);
            // Invoke tab change
            this.onTabChange(tab, group);
        }
        /* --- Lifecycle --- */
        onTabChange(tab, group) { }
        /* --- Context --- */
        _onFirstRender(context, options) {
            super._onFirstRender(context, options);
            // Set the initial tab for the primary tab group
            if (options.tab &&
                this.tabGroups[PRIMARY_TAB_GROUP] !== options.tab &&
                this.tabs[options.tab]) {
                this.changeTab(options.tab, PRIMARY_TAB_GROUP);
            }
        }
        async _prepareContext(options) {
            // Get tabs list
            const tabsList = this.tabs;
            // Construct tabs data
            const tabsData = Object.entries(tabsList)
                .map(([tabId, tab], i) => ({
                ...tab,
                id: tabId,
                group: tab.group ?? PRIMARY_TAB_GROUP,
                sortIndex: tab.sortIndex ?? (1 + i) * 10,
            }))
                .sort((a, b) => a.sortIndex - b.sortIndex);
            // Get all tab groups used by tabs of this application
            const usedGroups = tabsData
                .map((tab) => tab.group)
                .filter((v, i, self) => self.indexOf(v) === i);
            // Ensure that the used tab groups are set up
            usedGroups.forEach((groupId) => {
                if (!this.tabGroups[groupId]) {
                    this.tabGroups[groupId] = tabsData.find((tab) => tab.group === groupId).id;
                }
            });
            // Construct tabs
            const tabs = tabsData
                .map((tab) => {
                const active = this.tabGroups[tab.group] === tab.id;
                const cssClass = active ? 'active' : '';
                return {
                    ...tab,
                    active,
                    cssClass,
                };
            })
                .filter((tab) => tab.enabled !== false);
            // Construct tabs map
            const tabsMap = tabs.reduce((map, tab) => {
                return {
                    ...map,
                    [tab.id]: tab,
                };
            }, {});
            return {
                ...(await super._prepareContext(options)),
                tabs,
                tabsMap,
                tabGroups: this.tabGroups,
                activeTab: this.tabGroups.primary,
            };
        }
    };
}

/**
 * Mixin that adds an edit mode to an ApplicationV2
 */
function EditModeApplicationMixin(base) {
    return class mixin extends base {
        /* --- Accessors --- */
        get mode() {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
            return this.document.getFlag(SYSTEM_ID, 'sheet.mode') ?? 'view';
        }
        get isEditMode() {
            return this.mode === 'edit' && this.isEditable;
        }
        /* --- Public Functions --- */
        async setMode(mode) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
            await this.document.setFlag(SYSTEM_ID, 'sheet.mode', mode);
            // Get toggle
            const toggle = $(this.element).find('#mode-toggle');
            // Update checked status
            toggle.find('input').prop('checked', this.mode === 'edit');
            // Set mode class
            $(this.element)
                .removeClass(`mode-${mode === 'view' ? 'edit' : 'view'}`)
                .addClass(`mode-${mode}`);
            // Call mode change event
            this._onModeChange();
        }
        /* --- Lifecycle --- */
        async _renderFrame(options) {
            const frame = await super._renderFrame(options);
            // Insert mode toggle
            if (this.isEditable) {
                $(this.window.title).before(`
                    <label id="mode-toggle" 
                        class="toggle-switch"
                    >
                        <input type="checkbox" ${this.mode === 'edit' ? 'checked' : ''}>
                        <div class="slider rounded">
                            <i class="fa-solid fa-pen"></i>
                        </div>
                    </label>
                `);
                $(this.window.header)
                    .find('#mode-toggle')
                    .on('click', this.onToggleMode.bind(this));
            }
            // Set mode class
            $(frame).addClass(`mode-${this.mode}`);
            return frame;
        }
        /* --- Handlers --- */
        async onToggleMode(event) {
            if (!(event.target instanceof HTMLInputElement))
                return;
            event.preventDefault();
            event.stopPropagation();
            // Toggle mode
            await this.setMode(this.mode === 'view' ? 'edit' : 'view');
        }
        /* --- Lifecylce events --- */
        /**
         * Gets called after the mode has been changed
         */
        _onModeChange() { }
    };
}

const { ActorSheetV2 } = foundry.applications.sheets;
class BaseActorSheet extends TabsApplicationMixin(DragDropApplicationMixin(ComponentHandlebarsApplicationMixin(ActorSheetV2))) {
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.mergeObject({}, super.DEFAULT_OPTIONS), {
        actions: {
            'toggle-mode': this.onToggleMode,
            'edit-html-field': this.editHtmlField,
            save: this.onSave,
        },
        form: {
            handler: this.onFormEvent,
            submitOnChange: true,
        },
        dragDrop: [
            {
                dragSelector: '[data-drag]',
                dropSelector: '*',
            },
        ],
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    static PARTS = foundry.utils.mergeObject(super.PARTS, {
        navigation: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_NAVIGATION}`,
        },
    });
    static TABS = foundry.utils.mergeObject(super.TABS, {
        ["actions" /* BaseSheetTab.Actions */]: {
            label: 'COSMERE.Actor.Sheet.Tabs.Actions',
            icon: '<i class="cosmere-icon">3</i>',
        },
        ["equipment" /* BaseSheetTab.Equipment */]: {
            label: 'COSMERE.Actor.Sheet.Tabs.Equipment',
            icon: '<i class="fa-solid fa-suitcase"></i>',
        },
        ["notes" /* BaseSheetTab.Notes */]: {
            label: 'COSMERE.Actor.Sheet.Tabs.Notes',
            icon: '<i class="fa-solid fa-scroll"></i>',
        },
        ["effects" /* BaseSheetTab.Effects */]: {
            label: 'COSMERE.Actor.Sheet.Tabs.Effects',
            icon: '<i class="fa-solid fa-bolt"></i>',
        },
    });
    updatingHtmlField = false;
    proseFieldName = '';
    proseFieldHtml = '';
    expanded = false;
    get isUpdatingHtmlField() {
        return this.updatingHtmlField;
    }
    get actor() {
        return super.document;
    }
    actionsSearchText = '';
    actionsSearchSort = "alphabetic" /* SortMode.Alphabetic */;
    equipmentSearchText = '';
    equipmentSearchSort = "alphabetic" /* SortMode.Alphabetic */;
    effectsSearchText = '';
    effectsSearchSort = "alphabetic" /* SortMode.Alphabetic */;
    /* --- Accessors --- */
    get mode() {
        return this.actor.getFlag(SYSTEM_ID, 'sheet.mode') ?? 'edit';
    }
    get areExpertisesCollapsed() {
        return (this.actor.getFlag(SYSTEM_ID, 'sheet.expertisesCollapsed') ?? false);
    }
    get areImmunitiesCollapsed() {
        return (this.actor.getFlag(SYSTEM_ID, 'sheet.immunitiesCollapsed') ?? false);
    }
    /* --- Drag drop --- */
    _canDragStart() {
        return this.isEditable;
    }
    _canDragDrop() {
        return this.isEditable;
    }
    _onDragStart(event) {
        // Get dragged item
        const item = AppUtils.getItemFromEvent(event, this.actor);
        if (!item)
            return;
        const dragData = {
            type: 'Item',
            uuid: item.uuid,
        };
        // Set data transfer
        event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
        event.dataTransfer.setData('document/item', ''); // Mark the type
    }
    async _onDrop(event) {
        const data = TextEditor.getDragEventData(event);
        // Ensure document type can be embedded on actor
        if (!(data.type in CosmereActor.metadata.embedded))
            return;
        // Get the document
        const document = fromUuidSync(data.uuid);
        if (!document)
            return;
        if (!(document instanceof foundry.abstract.Document)) {
            const index = document;
            // Get the pack
            const pack = game.packs.get(index.pack);
            if (!pack)
                return;
            // Get the document
            const packDocument = (await pack.getDocument(index._id));
            // Embed document
            void this.actor.createEmbeddedDocuments(data.type, [packDocument]);
        }
        else if (document.parent !== this.actor) {
            // Document not yet on this actor, create it
            void this.actor.createEmbeddedDocuments(data.type, [document]);
        }
    }
    /* --- Actions --- */
    static async onToggleMode(event) {
        if (!(event.target instanceof HTMLInputElement))
            return;
        // Stop event propagation
        event.preventDefault();
        event.stopPropagation();
        // Update the actor and re-render
        await this.actor.update({
            'flags.cosmere-rpg.sheet.mode': this.mode === 'view' ? 'edit' : 'view',
        }, { render: true });
        // Get toggle
        const toggle = $(this.element).find('#mode-toggle');
        // Update checked status
        toggle.find('input').prop('checked', this.mode === 'edit');
        // Update tooltip
        toggle.attr('data-tooltip', game.i18n.localize(`COSMERE.Actor.Sheet.${this.mode === 'edit' ? 'View' : 'Edit'}`));
    }
    static async editHtmlField(event) {
        event.stopPropagation();
        // Get html field element
        const fieldElement = $(event.target).closest('[field-type]');
        // Get field type
        const proseFieldType = fieldElement.attr('field-type');
        // Gets the field to display based on the type found
        if (proseFieldType === 'biography') {
            this.proseFieldHtml = this.actor.system.biography ?? '';
        }
        else if (proseFieldType === 'appearance') {
            this.proseFieldHtml = this.actor.system.appearance ?? '';
        }
        else if (proseFieldType === 'notes') {
            this.proseFieldHtml = this.actor.system.notes ?? '';
        }
        // Gets name for use in prose mirror
        this.proseFieldName = 'system.' + proseFieldType;
        // Switches to prose mirror
        this.updatingHtmlField = true;
        await this.render(true);
    }
    /**
     * Provide a static callback for the prose mirror save button
     */
    static async onSave() {
        await this.saveHtmlField();
    }
    /* --- Form --- */
    static async onFormEvent(event, form, formData) {
        // Handle notes fields separately
        if (event.target.className.includes('prosemirror')) {
            await this.saveHtmlField();
            void this.actor.update(formData.object);
            return;
        }
        if (!(event.target instanceof HTMLInputElement) &&
            !(event.target instanceof HTMLTextAreaElement) &&
            !(event.target instanceof HTMLSelectElement))
            return;
        if (!event.target.name)
            return;
        Object.keys(this.actor.system.resources).forEach((resourceId) => {
            let resourceValue = formData.object[`system.resources.${resourceId}.value`];
            // Clean the value
            resourceValue = resourceValue
                .replace(/[^-+\d]/g, '')
                .replace(/((?<=\d+)\b.*)|((\+|-)*(?=(\+|-)\d))/g, '');
            // Get the number value
            let numValue = Number(resourceValue.replace(/\+|-/, ''));
            numValue = isNaN(numValue) ? 0 : numValue;
            if (resourceValue.includes('-'))
                numValue =
                    this.actor.system.resources[resourceId].value -
                        numValue;
            else if (resourceValue.includes('+'))
                numValue =
                    this.actor.system.resources[resourceId].value +
                        numValue;
            formData.object[`system.resources.${resourceId}.value`] = numValue;
        });
        // Get change
        const change = {
            [event.target.name]: formData.object[event.target.name],
        };
        // Update document
        void this.actor.update(change, { diff: false });
    }
    async _renderFrame(options) {
        const frame = await super._renderFrame(options);
        const corners = await renderSystemTemplate(TEMPLATES.GENERAL_SHEET_CORNERS, {});
        $(frame).prepend(corners);
        const banners = await renderSystemTemplate(TEMPLATES.GENERAL_SHEET_BACKGROUND, {});
        $(frame).prepend(banners);
        // Insert mode toggle
        if (this.isEditable) {
            $(this.window.title).before(`
                <label id="mode-toggle" 
                    class="toggle-switch"
                    data-action="toggle-mode"
                    data-tooltip="COSMERE.Actor.Sheet.Edit"
                >
                    <input type="checkbox" ${this.mode === 'edit' ? 'checked' : ''}>
                    <div class="slider rounded">
                        <i class="fa-solid fa-pen"></i>
                    </div>
                </label>
            `);
        }
        return frame;
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        if (options.parts.includes('content')) {
            this.element
                .querySelector('#actions-search')
                .addEventListener('search', this.onActionsSearchChange.bind(this));
            this.element
                .querySelector('#equipment-search')
                ?.addEventListener('search', this.onEquipmentSearchChange.bind(this));
            this.element
                .querySelector('#effects-search')
                ?.addEventListener('search', this.onEffectsSearchChange.bind(this));
            this.element
                .querySelector('app-actor-equipment-list')
                ?.addEventListener('currency', this.onCurrencyChange.bind(this));
        }
        $(this.element)
            .find('#mode-toggle')
            .on('dblclick', (event) => this.onDoubleClickModeToggle(event));
        $(this.element)
            .find('.collapsible .header')
            .on('click', (event) => this.onClickCollapsible(event));
    }
    /* --- Event handlers --- */
    onClickCollapsible(event) {
        const target = event.currentTarget;
        target?.parentElement?.classList.toggle('expanded');
    }
    onDoubleClickModeToggle(event) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
    }
    onActionsSearchChange(event) {
        this.actionsSearchText = event.detail.text;
        this.actionsSearchSort = event.detail.sort;
        void this.render({
            parts: [],
            components: ['app-actor-actions-list'],
        });
    }
    onEquipmentSearchChange(event) {
        this.equipmentSearchText = event.detail.text;
        this.equipmentSearchSort = event.detail.sort;
        void this.render({
            parts: [],
            components: ['app-actor-equipment-list'],
        });
    }
    onEffectsSearchChange(event) {
        this.effectsSearchText = event.detail.text;
        this.effectsSearchSort = event.detail.sort;
        void this.render({
            parts: [],
            components: ['app-actor-effects-list'],
        });
    }
    onCurrencyChange(event) {
        void this.render({
            parts: [],
            components: ['app-actor-currency-list'],
        });
    }
    /* --- Context --- */
    async _prepareContext(options) {
        // Get enriched versions of HTML fields
        let enrichedBiographyValue = undefined;
        let enrichedAppearanceValue = undefined;
        let enrichedNotesValue = undefined;
        if (this.actor.system.biography) {
            enrichedBiographyValue = await TextEditor.enrichHTML(this.actor.system.biography, { relativeTo: this.document });
        }
        if (this.actor.system.appearance) {
            enrichedAppearanceValue = await TextEditor.enrichHTML(this.actor.system.appearance, { relativeTo: this.document });
        }
        if (this.actor.system.notes) {
            enrichedNotesValue = await TextEditor.enrichHTML(this.actor.system.notes, { relativeTo: this.document });
        }
        // separating this as most times one or both can be shortcutted
        const hasDamageImmunities = Object.keys(this.actor.system.immunities.damage).some((type) => this.actor.system.immunities.damage[type]);
        const hasConditionImmunities = Object.keys(this.actor.system.immunities.condition).some((cond) => this.actor.system.immunities.condition[cond]);
        const hasImmunities = hasDamageImmunities || hasConditionImmunities;
        return {
            ...(await super._prepareContext(options)),
            actor: this.actor,
            editable: this.isEditable,
            mode: this.mode,
            expertisesCollapsed: this.areExpertisesCollapsed,
            hasExpertises: this.actor.system.expertises &&
                this.actor.system.expertises.size > 0,
            immunitiesCollapsed: this.areImmunitiesCollapsed,
            hasImmunities,
            isEditMode: this.mode === 'edit' && this.isEditable,
            // Prose mirror state
            isUpdatingHtmlField: this.isUpdatingHtmlField,
            biographyHtml: enrichedBiographyValue,
            appearanceHtml: enrichedAppearanceValue,
            notesHtml: enrichedNotesValue,
            proseFieldName: this.proseFieldName,
            proseFieldHtml: this.proseFieldHtml,
            resources: Object.keys(this.actor.system.resources),
            attributeGroups: Object.keys(CONFIG.COSMERE.attributeGroups),
            // Search
            actionsSearch: {
                text: this.actionsSearchText,
                sort: this.actionsSearchSort,
            },
            equipmentSearch: {
                text: this.equipmentSearchText,
                sort: this.equipmentSearchSort,
            },
            effectsSearch: {
                text: this.effectsSearchText,
                sort: this.effectsSearchSort,
            },
        };
    }
    /* --- Helpers --- */
    /**
     * Helper to update the prose mirror edit state
     */
    async saveHtmlField() {
        console.log('Saving HTML Field');
        // Switches back from prose mirror
        this.updatingHtmlField = false;
        await this.render(true);
    }
}

// Dialog
class ExpertisesListComponent extends HandlebarsApplicationComponent {
    static FORM_ASSOCIATED = true;
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.COMPONENT_EXPERTISES_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'edit-expertises': this.onEditExpertises,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    _value = new Collection();
    _name;
    _collapsed = false;
    /* --- Accessors --- */
    get element() {
        return super.element;
    }
    get readonly() {
        return this.params?.readonly === true;
    }
    get collapsible() {
        return this.params?.collapsible ?? true;
    }
    get collapsed() {
        return this._collapsed;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        // Set value
        this.element.value = value;
        // Dispatch change event
        this.element.dispatchEvent(new Event('change', { bubbles: true }));
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
        // Set name
        this.element.name = value;
        $(this.element).attr('name', value ?? '');
    }
    get expertises() {
        return this.application instanceof BaseActorSheet
            ? this.application.actor.system.expertises
            : this._value;
    }
    /* --- Actions --- */
    static onEditExpertises(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.application instanceof BaseActorSheet) {
            void EditExpertisesDialog.show(this.application.actor);
        }
        else {
            void EditExpertisesDialog.show({
                data: this.expertises,
                liveUpdate: true,
                updater: (expertises) => {
                    this.value = expertises;
                },
            });
        }
    }
    /* --- Lifecycle --- */
    _onInitialize() {
        if (this.params.value) {
            this._value = this.params.value;
        }
        else if (!(this.application instanceof BaseActorSheet)) {
            console.warn(`ExpertisesListComponent: No value provided, and the application is not a BaseActorSheet. This component will not work as expected.`);
        }
        this._collapsed =
            this.application instanceof BaseActorSheet
                ? this.application.areExpertisesCollapsed
                : false;
    }
    _onRender(params) {
        super._onRender(params);
        // Set value
        this.element.value = this.value ?? '';
        // Set name
        if (this.params.name) {
            this.name = this.params.name;
        }
        // Set readonly
        if (this.params.readonly) {
            $(this.element).attr('readonly', 'readonly');
        }
        if (this.collapsible) {
            $(this.element)
                .find('.collapsible .icon-header')
                .on('click', (event) => this.onClickCollapsible(event));
        }
    }
    /* --- Event handlers --- */
    onClickCollapsible(event) {
        const target = event.currentTarget;
        target?.parentElement?.classList.toggle('expanded');
        this._collapsed = !this._collapsed;
        if (this.application instanceof BaseActorSheet) {
            if (!this.application.isEditable)
                return;
            void this.application.actor.update({
                'flags.cosmere-rpg.sheet.expertisesCollapsed': this._collapsed,
            }, { render: false });
        }
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            isEditMode: this.application instanceof BaseActorSheet
                ? context.isEditMode
                : !this.readonly,
            shouldDisplay: this.application instanceof BaseActorSheet
                ? context.isEditMode ||
                    this.expertises.size > 0
                : true,
            collapsible: this.collapsible,
            collapsed: this.collapsed,
            expertises: this.expertises
                .map((expertise) => {
                const config = CONFIG.COSMERE.expertiseTypes[expertise.type];
                return {
                    ...expertise,
                    typeLabel: config.label,
                    typeIcon: config.icon,
                };
            })
                .sort((e1, e2) => e1.type.compare(e2.type)) ?? [],
        });
    }
}
// Register
ExpertisesListComponent.register('app-expertises-list');

const CHANGE_DATA_SCHEMA = ChangeDataModel.defineSchema();
class DocumentChangesListComponent extends HandlebarsApplicationComponent {
    static FORM_ASSOCIATED = true;
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.COMPONENT_DOCUMENT_CHANGES_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'add-change': this.onAddChange,
        'remove-change': this.onRemoveChange,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    _value = [];
    _name;
    /* --- Accessors --- */
    get element() {
        return super.element;
    }
    get readonly() {
        return this.params?.readonly === true;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        // Set value
        this.element.value = value;
        // Dispatch change event
        this.element.dispatchEvent(new Event('change', { bubbles: true }));
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
        // Set name
        this.element.name = value;
        $(this.element).attr('name', value ?? '');
    }
    /* --- Actions --- */
    static onAddChange() {
        if (this.readonly)
            return;
        this.value = [
            ...this.value,
            { key: '', value: '', mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE },
        ];
    }
    static onRemoveChange(event) {
        if (this.readonly)
            return;
        const index = Number($(event.target).closest('.change[data-index]').data('index'));
        this.value = this.value.filter((_, i) => i !== index);
    }
    /* --- Lifecycle --- */
    _onInitialize() {
        if (this.params.value) {
            this._value = this.params.value ?? [];
        }
    }
    _onRender(params) {
        super._onRender(params);
        // Set value
        this.element.value = this.value ?? '';
        // Set name
        if (this.params.name) {
            this.name = this.params.name;
        }
        // Set readonly
        if (this.params.readonly) {
            $(this.element).attr('readonly', 'readonly');
        }
    }
    _onAttachListeners(params) {
        super._onAttachListeners(params);
        // Handle changes
        this.element.querySelectorAll('input, select').forEach((el) => el.addEventListener('change', this.onChange.bind(this)));
    }
    onChange(event) {
        event.preventDefault();
        // Get input
        const input = event.target;
        // Get index
        const index = Number($(input).closest('.change[data-index]').data('index'));
        // Get the name
        const name = input.name;
        // Update the value
        this.value[index][name] = input.value;
        // Set value to trigger change event
        this.value = this._value;
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            schema: CHANGE_DATA_SCHEMA,
            readonly: this.readonly,
            changes: this.value,
        });
    }
}
// Register the component
DocumentChangesListComponent.register('app-document-changes-list');

// Component imports
class ItemDropListComponent extends DragDropComponentMixin((HandlebarsApplicationComponent)) {
    static FORM_ASSOCIATED = true;
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.COMPONENT_ITEM_DROP_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'remove-item': this.onRemoveItem,
    };
    static DRAG_DROP = [
        {
            dropSelector: '*',
        },
    ];
    _value = [];
    _name;
    /* --- Accessors --- */
    get element() {
        return super.element;
    }
    get readonly() {
        return this.params?.readonly === true;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        // Set value
        this.element.value = value;
        // Dispatch change event
        this.element.dispatchEvent(new Event('change', { bubbles: true }));
    }
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
        // Set name
        this.element.name = name;
        $(this.element).attr('name', name ?? '');
    }
    get placeholder() {
        return this.params?.placeholder;
    }
    /* --- Actions --- */
    static onRemoveItem(event) {
        // Get key
        const key = $(event.target).closest('[data-id]').data('id');
        // Remove document
        this.value = this.value.filter((v) => v.uuid !== key);
        // Re-render
        void this.render();
    }
    /* --- Drag drop --- */
    _canDragDrop() {
        return !this.readonly;
    }
    _onDragOver(event) {
        if (this.readonly)
            return;
        $(this.element).find('.drop-area').addClass('dropping');
    }
    async _onDrop(event) {
        if (this.readonly)
            return;
        // Remove dragover class
        $(this.element).find('.drop-area').removeClass('dropping');
        // Get data
        const data = TextEditor.getDragEventData(event);
        // Ensure the document is not already in the list
        if (this.value.some((v) => v.uuid === data.uuid)) {
            return ui.notifications.warn(game.i18n.format('COMPONENT.DocumentDropListComponent.Warning.DocumentAlreadyInList', {
                type: 'Item',
            }));
        }
        // Validate document type
        if (data.type !== 'Item') {
            return ui.notifications.warn(game.i18n.format('COMPONENT.DocumentDropListComponent.Warning.WrongType', {
                type: 'Item',
            }));
        }
        // Get the item
        const item = (await fromUuid(data.uuid));
        // Validate item type
        if (this.params.type) {
            if (item.type !== this.params.type) {
                return ui.notifications.warn(game.i18n.format('COMPONENT.DocumentDropListComponent.Warning.WrongSubtype', {
                    subtype: this.params.type,
                }));
            }
        }
        // Add document to the list
        this.value = [
            ...this.value,
            {
                uuid: data.uuid,
                ...(item.isPhysical()
                    ? { quantity: item.system.quantity?.toFixed() }
                    : {}),
            },
        ];
        // Render
        void this.render();
    }
    /* --- Lifecycle --- */
    _onInitialize(params) {
        super._onInitialize(params);
        if (this.params.value) {
            this._value = this.params.value;
        }
    }
    _onAttachListeners(params) {
        super._onAttachListeners(params);
        $(this.element).on('dragleave', () => {
            $(this.element).find('.drop-area').removeClass('dropping');
        });
        $(this.element)
            .find('.document input[name="quantity"]')
            .on('change', (event) => {
            const target = event.target;
            const uuid = $(target)
                .closest('.document')
                .data('id');
            // Update the quantity for the item
            const ref = this.value.find((v) => v.uuid === uuid);
            if (ref) {
                ref.quantity = target.value;
            }
            // Update the value
            this.value = [...this.value];
            // Re-render
            void this.render();
        });
    }
    _onRender(params) {
        super._onRender(params);
        // Set value
        this.element.value = this.value ?? [];
        // Set name
        if (this.params.name) {
            this.name = this.params.name;
        }
        // Set readonly
        if (this.params.readonly) {
            $(this.element).attr('readonly', 'readonly');
        }
    }
    /* --- Context --- */
    async _prepareContext(params) {
        // Look up the items
        const items = await Promise.all(this.value.map(async ({ uuid }) => (await fromUuid(uuid))));
        return {
            ...params,
            value: this.value,
            items: this.value.map((ref, i) => ({
                ...ref,
                isPhysical: items[i]?.isPhysical() ?? false,
                link: items[i]?.toAnchor().outerHTML ?? '',
            })),
        };
    }
}
// Register the component
ItemDropListComponent.register('app-item-drop-list');

// Constants
const TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.GENERAL_CONTEXT_MENU}`;
class AppContextMenu {
    parent;
    anchor;
    /**
     * The root element of the context menu.
     */
    _element;
    /**
     * The element that was clicked to open the context menu.
     */
    contextElement;
    expanded = false;
    rendered = false;
    _active = true;
    items;
    itemsFn;
    constructor(parent, anchor, items) {
        this.parent = parent;
        this.anchor = anchor;
        if (typeof items === 'function') {
            this.itemsFn = items;
        }
        else {
            this.items = items;
        }
    }
    get element() {
        return this._element;
    }
    get active() {
        return this._active;
    }
    /**
     * Utility function to create a context menu
     * and automatically bind it to the elements
     * matching the selectors.
     *
     * This function takes care of re-binding on render.
     * If no selectors are provided, simply call `show` on the context menu.
     */
    static create(config) {
        // Destructure config
        const { parent, items, selectors, anchor = 'left', mouseButton, } = config;
        // Create context menu
        const menu = new AppContextMenu(parent, anchor, items);
        // Add event listener
        if (selectors) {
            parent.addEventListener('render', () => {
                menu.bind(selectors, mouseButton);
            });
        }
        return menu;
    }
    bind(param1, mouseButton = MouseButton.Primary) {
        if (param1.length === 0)
            return;
        const elements = [];
        if (typeof param1[0] === 'string') {
            elements.push(...param1
                .map((selector) => $(this.parent.element).find(selector).toArray())
                .flat());
        }
        else {
            elements.push(...param1);
        }
        // Get the event to bind to
        const event = mouseButton === MouseButton.Primary ? 'click' : 'contextmenu';
        // Attach listeners
        elements.forEach((element) => {
            element.addEventListener(event, (event) => {
                const shouldShow = !this.expanded || this.contextElement !== element;
                if (this.expanded)
                    this.hide();
                if (shouldShow && this._active) {
                    const rootBounds = this.parent.element.getBoundingClientRect();
                    const positioning = this.anchor === 'cursor'
                        ? {
                            top: event.clientY - rootBounds.top,
                            left: event.clientX - rootBounds.left,
                        }
                        : undefined;
                    setTimeout(() => {
                        void this.show(element, undefined, positioning);
                    });
                }
            });
        });
    }
    async show(...args) {
        const firstArgIsElement = args[0] instanceof HTMLElement;
        const element = firstArgIsElement
            ? args[0]
            : this.contextElement;
        let positioning = !firstArgIsElement
            ? args[1]
            : args.length === 3
                ? args[2]
                : undefined;
        // Set items
        this.items = !firstArgIsElement
            ? args[0]
            : (this.itemsFn?.(element) ?? this.items);
        // If the context element is different and items are dynamic, always re-render
        if (firstArgIsElement &&
            element !== this.contextElement &&
            this.itemsFn)
            this.rendered = false;
        // If the first argument is not an element, re-render
        if (!firstArgIsElement)
            this.rendered = false;
        // Set the context element
        this.contextElement = element;
        // If not rendered yet, render now
        if (!this.rendered)
            await this.render();
        if (firstArgIsElement) {
            // Get element bounds
            const elementBounds = element.getBoundingClientRect();
            const rootBounds = (this.parent.element.closest('.tab-body') ?? this.parent.element).getBoundingClientRect();
            // Figure out positioning with anchor
            positioning = {
                top: elementBounds.top - rootBounds.top,
                ...(this.anchor === 'right'
                    ? {
                        right: rootBounds.right -
                            elementBounds.right +
                            elementBounds.width,
                    }
                    : {
                        left: elementBounds.left -
                            rootBounds.left -
                            elementBounds.width,
                    }),
            };
        }
        // Set positioning
        $(this._element).css('top', `${positioning.top}px`);
        if ('right' in positioning)
            $(this._element).css('right', `${positioning.right}px`);
        else
            $(this._element).css('left', `${positioning.left}px`);
        // Remove hidden
        $(this._element).addClass('expanded');
        $(this._element).removeClass('hidden');
        if (this.anchor === 'cursor' && positioning) {
            $(this._element).addClass('free');
        }
        // Set expanded
        this.expanded = true;
    }
    hide() {
        // Hide
        $(this._element).removeClass('expanded');
        $(this._element).addClass('hidden');
        // Unset expanded
        this.expanded = false;
        if (this.itemsFn)
            this.items = undefined;
    }
    setActive(active) {
        this._active = active;
        if (!this._active) {
            this.hide();
        }
    }
    async render() {
        // Clean up old element
        if (this._element)
            this.destroy();
        // Render the element
        this._element = await this.renderElement();
        // Add hidden class
        $(this._element).addClass('hidden');
        // Attach listeners
        $(this._element)
            .find('button[data-item]')
            .on('click', (event) => {
            // Get the index
            const index = Number($(event.target).closest('button[data-item]').data('item'));
            // Get the item
            const item = this.items[index];
            // Trigger the callback
            if (item.callback)
                item.callback(this.contextElement);
            // Hide the context menu
            this.hide();
        });
        // Add element to parent
        this.parent.element.appendChild(this._element);
    }
    destroy() {
        if (this._element) {
            this._element.remove();
            this._element = undefined;
        }
    }
    async renderElement() {
        const htmlStr = await renderTemplate(TEMPLATE, {
            items: this.items.map((item) => ({
                ...item,
                cssClasses: item.classes?.join(' ') ?? '',
            })),
        });
        const t = document.createElement('template');
        t.innerHTML = htmlStr;
        return t.content.children[0];
    }
}

// Documents
// Constants
const STATIC_SECTIONS = {
    weapons: {
        id: 'weapons',
        sortOrder: 0,
        label: 'COSMERE.Item.Type.Weapon.label_plural',
        itemTypeLabel: 'COSMERE.Item.Type.Weapon.label_action',
        default: false,
        filter: (item) => item.isWeapon(),
        new: (parent) => CosmereItem.create({
            type: "weapon" /* ItemType.Weapon */,
            name: game.i18n.localize('COSMERE.Item.Type.Weapon.New'),
            system: {
                activation: {
                    type: "skill_test" /* ActivationType.SkillTest */,
                    cost: {
                        type: "act" /* ActionCostType.Action */,
                        value: 1,
                    },
                },
                equipped: true,
            },
        }, { parent }),
    },
    armor: {
        id: 'armor',
        sortOrder: 400,
        label: 'COSMERE.Item.Type.Armor.label_plural',
        itemTypeLabel: 'COSMERE.Item.Type.Armor.label_action',
        default: false,
        filter: (item) => item.isArmor(),
        new: (parent) => CosmereItem.create({
            type: "equipment" /* ItemType.Equipment */,
            name: game.i18n.localize('COSMERE.Item.Type.Armor.New'),
            system: {
                activation: {
                    type: "utility" /* ActivationType.Utility */,
                    cost: {
                        type: "act" /* ActionCostType.Action */,
                        value: 1,
                    },
                },
            },
        }, { parent }),
    },
    equipment: {
        id: 'equipment',
        sortOrder: 500,
        label: 'COSMERE.Item.Type.Equipment.label_plural',
        itemTypeLabel: 'COSMERE.Item.Type.Equipment.label_action',
        default: false,
        filter: (item) => item.isEquipment(),
        new: (parent) => CosmereItem.create({
            type: "equipment" /* ItemType.Equipment */,
            name: game.i18n.localize('COSMERE.Item.Type.Equipment.New'),
            system: {
                activation: {
                    type: "utility" /* ActivationType.Utility */,
                    cost: {
                        type: "act" /* ActionCostType.Action */,
                        value: 1,
                    },
                },
            },
        }, { parent }),
    },
    'basic-actions': {
        id: 'basic-actions',
        sortOrder: 600,
        label: 'COSMERE.Item.Action.Type.Basic.label_plural',
        itemTypeLabel: 'COSMERE.Item.Action.Type.Basic.label_action',
        default: true,
        filter: (item) => item.isAction() && item.system.type === "basic" /* ActionType.Basic */,
        new: (parent) => CosmereItem.create({
            type: "action" /* ItemType.Action */,
            name: game.i18n.localize('COSMERE.Item.Type.Action.New'),
            system: {
                type: "basic" /* ActionType.Basic */,
                activation: {
                    type: "utility" /* ActivationType.Utility */,
                    cost: {
                        type: "act" /* ActionCostType.Action */,
                        value: 1,
                    },
                },
            },
        }, { parent }),
    },
};
const DYNAMIC_SECTIONS = {
    powers: (actor) => {
        // Get powers
        const powers = actor.powers;
        // Get list of unique power types
        const powerTypes = [...new Set(powers.map((p) => p.system.type))];
        return powerTypes.map((type) => {
            // Get config
            const config = CONFIG.COSMERE.power.types[type];
            return {
                id: type,
                sortOrder: 100,
                label: game.i18n.localize(config.plural),
                itemTypeLabel: game.i18n.localize(config.label),
                default: false,
                filter: (item) => item.isPower() && item.system.type === type,
                new: (parent) => CosmereItem.create({
                    type: "power" /* ItemType.Power */,
                    name: game.i18n.format('COSMERE.Item.Type.Power.New', {
                        type: game.i18n.localize(config.label),
                    }),
                    system: {
                        type,
                        activation: {
                            type: "utility" /* ActivationType.Utility */,
                            cost: {
                                type: "act" /* ActionCostType.Action */,
                                value: 1,
                            },
                            consume: {
                                type: "resource" /* ItemConsumeType.Resource */,
                                resource: "inv" /* Resource.Investiture */,
                                value: 1,
                            },
                        },
                    },
                }, { parent }),
            };
        });
    },
    paths: (actor) => {
        // Get paths
        const paths = actor.paths;
        return paths.map((path) => ({
            id: path.system.id,
            sortOrder: 200,
            label: game.i18n.format('COSMERE.Actor.Sheet.Actions.BaseSectionName', {
                type: path.name,
            }),
            itemTypeLabel: `${path.name} ${game.i18n?.localize('COSMERE.Item.Type.Action.label')}`,
            default: true,
            filter: (item) => item.hasRelationships() &&
                item.isRelatedTo(path, ItemRelationship.Type.Parent),
            new: (parent) => CosmereItem.create({
                type: "talent" /* ItemType.Talent */,
                name: game.i18n.localize('COSMERE.Item.Type.Talent.New'),
                system: {
                    path: path.system.id,
                    activation: {
                        type: "utility" /* ActivationType.Utility */,
                        cost: {
                            type: "act" /* ActionCostType.Action */,
                            value: 1,
                        },
                    },
                },
            }, { parent }),
        }));
    },
    ancestry: (actor) => {
        // Get ancestry
        const ancestry = actor.ancestry;
        if (!ancestry)
            return [];
        return [
            {
                id: ancestry.system.id,
                sortOrder: 300,
                label: game.i18n.format('COSMERE.Actor.Sheet.Actions.BaseSectionName', {
                    type: ancestry.name,
                }),
                itemTypeLabel: `${ancestry.name} ${game.i18n?.localize('COSMERE.Item.Type.Action.label')}`,
                default: false,
                filter: (item) => (item.hasRelationships() &&
                    item.isRelatedTo(ancestry, ItemRelationship.Type.Parent)) ||
                    (item.isAction() &&
                        item.system.type === "ancestry" /* ActionType.Ancestry */ &&
                        item.system.ancestry === ancestry.system.id),
                new: (parent) => CosmereItem.create({
                    type: "action" /* ItemType.Action */,
                    name: game.i18n.localize('COSMERE.Item.Type.Action.New'),
                    system: {
                        ancestry: ancestry.system.id,
                        activation: {
                            type: "utility" /* ActivationType.Utility */,
                            cost: {
                                type: "act" /* ActionCostType.Action */,
                                value: 1,
                            },
                        },
                    },
                }, { parent }),
            },
        ];
    },
};
const MISC_SECTION = {
    id: 'misc-actions',
    label: 'COSMERE.Actor.Sheet.Actions.MiscSectionName',
    default: false,
    filter: () => false, // Filter function is not used for this section
};
class ActorActionsListComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_ACTIONS_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'toggle-action-details': this.onToggleActionDetails,
        'use-item': this.onUseItem,
        'new-item': this.onNewItem,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    sections = [];
    /**
     * Map of id to state
     */
    itemState = {};
    /* --- Actions --- */
    static onToggleActionDetails(event) {
        // Get item element
        const itemElement = $(event.target).closest('.item[data-item-id]');
        // Get item id
        const itemId = itemElement.data('item-id');
        // Update the state
        this.itemState[itemId].expanded = !this.itemState[itemId].expanded;
        // Set classes
        itemElement.toggleClass('expanded', this.itemState[itemId].expanded);
        itemElement
            .find('a[data-action="toggle-action-details"')
            .empty()
            .append(this.itemState[itemId].expanded
            ? '<i class="fa-solid fa-compress"></i>'
            : '<i class="fa-solid fa-expand"></i>');
    }
    static onUseItem(event) {
        // Get item
        const item = AppUtils.getItemFromEvent(event, this.application.actor);
        if (!item)
            return;
        // Use the item
        void this.application.actor.useItem(item);
    }
    static async onNewItem(event) {
        // Get section element
        const sectionElement = $(event.target).closest('[data-section-id]');
        // Get section id
        const sectionId = sectionElement.data('section-id');
        // Get section
        const section = this.sections.find((s) => s.id === sectionId);
        if (!section)
            return;
        // Create a new item
        const item = await section.new?.(this.application.actor);
        // Render the item sheet
        void item?.sheet?.render(true);
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        // Get all activatable items (actions & items with an associated action)
        const activatableItems = this.application.actor.items
            .filter((item) => item.hasActivation())
            .filter((item) => !item.isEquippable() ||
            item.system.equipped ||
            item.system.alwaysEquipped);
        // Ensure all items have an expand state record
        activatableItems.forEach((item) => {
            if (!(item.id in this.itemState)) {
                this.itemState[item.id] = {
                    expanded: false,
                };
            }
        });
        const searchText = context.actionsSearch?.text ?? '';
        const sortMode = context.actionsSearch?.sort ?? "alphabetic" /* SortMode.Alphabetic */;
        // Prepare sections
        this.sections = this.prepareSections();
        // Prepare sections data
        const sectionsData = await this.prepareSectionsData(this.sections, activatableItems, searchText, sortMode);
        return {
            ...context,
            sections: sectionsData.filter((section) => section.items.length > 0 ||
                (this.application.mode === 'edit' && section.default)),
            itemState: this.itemState,
        };
    }
    prepareSections() {
        return [
            ...Object.values(CONFIG.COSMERE.sheet.actor.components.actions.sections.static),
            ...Object.values(CONFIG.COSMERE.sheet.actor.components.actions.sections.dynamic).flatMap((gen) => gen(this.application.actor)),
            MISC_SECTION,
        ].sort((a, b) => (a.sortOrder ?? Number.MAX_VALUE) -
            (b.sortOrder ?? Number.MAX_VALUE));
    }
    async prepareSectionsData(sections, items, searchText, sort) {
        // Filter items into sections, putting all items that don't fit into a section into a "Misc" section
        const itemsBySectionId = items.reduce((result, item) => {
            const section = sections.find((s) => s.filter(item));
            if (!section) {
                result['misc-actions'] ??= [];
                result['misc-actions'].push(item);
            }
            else {
                if (!result[section.id])
                    result[section.id] = [];
                result[section.id].push(item);
            }
            return result;
        }, {});
        // Prepare sections
        return await Promise.all(sections.map(async (section) => {
            // Get items for section, filter by search text, and sort
            let sectionItems = (itemsBySectionId[section.id] ?? []).filter((i) => i.name.toLowerCase().includes(searchText));
            if (sort === "alphabetic" /* SortMode.Alphabetic */) {
                sectionItems = sectionItems.sort((a, b) => a.name.compare(b.name));
            }
            return {
                ...section,
                canAddNewItems: !!section.new,
                createItemTooltip: section.createItemTooltip
                    ? typeof section.createItemTooltip === 'function'
                        ? section.createItemTooltip()
                        : section.createItemTooltip
                    : game.i18n.format('COSMERE.Actor.Sheet.Actions.NewItem', {
                        type: game.i18n.localize(section.itemTypeLabel ??
                            'COSMERE.Item.Type.Action.label'),
                    }),
                items: sectionItems,
                itemData: await this.prepareItemData(sectionItems),
            };
        }));
    }
    async prepareItemData(items) {
        return await items.reduce(async (prev, item) => ({
            ...(await prev),
            [item.id]: {
                ...(item.hasDescription() && item.system.description?.value
                    ? {
                        descriptionHTML: await TextEditor.enrichHTML(item.system.description.value, {
                            relativeTo: item.system
                                .parent,
                        }),
                    }
                    : {}),
            },
        }), Promise.resolve({}));
    }
    /* --- Lifecycle --- */
    _onInitialize() {
        if (this.application.isEditable) {
            // Create context menu
            AppContextMenu.create({
                parent: this,
                items: (element) => {
                    // Get item id
                    const itemId = $(element)
                        .closest('.item[data-item-id]')
                        .data('item-id');
                    // Get item
                    const item = this.application.actor.items.get(itemId);
                    // Check if actor is character
                    const isCharacter = this.application.actor.isCharacter();
                    // Check if item is favorited
                    const isFavorite = item.isFavorite;
                    return [
                        /**
                         * NOTE: This is a TEMPORARY context menu option
                         * until we can handle recharging properly.
                         */
                        {
                            name: 'COSMERE.Item.Activation.Uses.Recharge.Label',
                            icon: 'fa-solid fa-rotate-left',
                            callback: () => {
                                void item.recharge();
                            },
                        },
                        // Favorite (only for characters)
                        isCharacter
                            ? isFavorite
                                ? {
                                    name: 'GENERIC.Button.RemoveFavorite',
                                    icon: 'fa-solid fa-star',
                                    callback: () => {
                                        void item.clearFavorite();
                                    },
                                }
                                : {
                                    name: 'GENERIC.Button.Favorite',
                                    icon: 'fa-solid fa-star',
                                    callback: () => {
                                        void item.markFavorite(this.application.actor.favorites
                                            .length);
                                    },
                                }
                            : null,
                        {
                            name: 'GENERIC.Button.Edit',
                            icon: 'fa-solid fa-pen-to-square',
                            callback: () => {
                                void item.sheet?.render(true);
                            },
                        },
                        {
                            name: 'GENERIC.Button.Remove',
                            icon: 'fa-solid fa-trash',
                            callback: () => {
                                // Remove the item
                                void this.application.actor.deleteEmbeddedDocuments('Item', [item.id]);
                            },
                        },
                    ].filter((i) => !!i);
                },
                selectors: ['a[data-action="toggle-actions-controls"]'],
                anchor: 'right',
            });
        }
    }
}
// Register component
ActorActionsListComponent.register('app-actor-actions-list');
function configure$1() {
    // Register static sections
    Object.values(STATIC_SECTIONS).forEach((section) => {
        cosmereRPG.api.registerActionListSection({
            ...section,
            source: SYSTEM_ID,
        });
    });
    // Register dynamic sections
    Object.values(DYNAMIC_SECTIONS).forEach((gen) => {
        cosmereRPG.api.registerActionListDynamicSectionGenerator({
            source: SYSTEM_ID,
            id: gen.name,
            generator: gen,
        });
    });
}

const { ApplicationV2: ApplicationV2$b, HandlebarsApplicationMixin: HandlebarsApplicationMixin$8 } = foundry.applications.api;
class ConfigureDefenseDialog extends HandlebarsApplicationMixin$8((ApplicationV2$b)) {
    actor;
    group;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            positioned: true,
        },
        classes: ['dialog', 'configure-defense'],
        tag: 'dialog',
        position: {
            width: 350,
        },
        actions: {
            'update-defense': this.onUpdateDefense,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ACTOR_CONFIGURE_DEFENSE}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    defenseData;
    mode;
    constructor(actor, group) {
        super({
            id: `${actor.uuid}.AttributeGroup.${group}.Defense`,
            window: {
                title: game
                    .i18n.localize('DIALOG.ConfigureDefense.Title')
                    .replace('{attribute-group}', game.i18n.localize(CONFIG.COSMERE.attributeGroups[group].label))
                    .replace('{actor}', actor.name),
            },
        });
        this.actor = actor;
        this.group = group;
        this.defenseData = this.actor.system.defenses[group];
        this.defenseData.override =
            this.defenseData.override ?? this.defenseData.value ?? 10;
        this.mode = this.defenseData.mode;
    }
    /* --- Statics --- */
    static async show(actor, group) {
        await new ConfigureDefenseDialog(actor, group).render(true);
    }
    /* --- Actions --- */
    static onUpdateDefense() {
        void this.actor.update({
            [`system.defenses.${this.group}`]: this.defenseData,
        });
        void this.close();
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        const target = event.target;
        this.mode = formData.object.mode;
        if (this.mode === Derived.Mode.Override && target.name === 'formula')
            this.defenseData.override = formData.object.formula;
        if (target.name === 'bonus')
            this.defenseData.bonus = formData.object.bonus;
        // Assign mode
        this.defenseData.mode = this.mode;
        // Render
        void this.render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    /* --- Context --- */
    _prepareContext() {
        // Get attribute group config
        const config = CONFIG.COSMERE.attributeGroups[this.group];
        // Construct formula
        const formula = `10 + @attr.${config.attributes[0]} + @attr.${config.attributes[1]} + @bonus`;
        return Promise.resolve({
            actor: this.actor,
            group: this.group,
            ...config,
            formula,
            mode: this.mode,
            modes: Derived.Modes,
            override: this.defenseData.override,
            bonus: this.defenseData.bonus,
        });
    }
}

class ActorAttributesComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_ATTRIBUTES}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.ACTIONS), {
        'configure-defense': this.onConfigureDefense,
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onConfigureDefense(event) {
        // Get the group id
        const groupId = $(event.target)
            .closest('[data-id]')
            .data('id');
        void ConfigureDefenseDialog.show(this.application.actor, groupId);
    }
    /* --- Lifecycle --- */
    _onAttachListeners(params) {
        super._onAttachListeners(params);
        $(this.element)
            .find('.attribute input:not([readonly])')
            .on('focus', (event) => {
            // Get the source value
            const sourceValue = $(event.target).data('source-value');
            // Set the value to the source value
            $(event.target).val(sourceValue);
            // Select the input
            $(event.target).trigger('select');
        })
            .on('blur', (event) => {
            // Get the total
            const total = $(event.target).data('total');
            // Set the value to the total
            $(event.target).val(total);
        });
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            attributeGroups: Object.keys(CONFIG.COSMERE.attributeGroups).map(this.prepareAttributeGroup.bind(this)),
        });
    }
    prepareAttributeGroup(groupId) {
        // Get the attribute group config
        const groupConfig = CONFIG.COSMERE.attributeGroups[groupId];
        return {
            id: groupId,
            config: groupConfig,
            defense: this.application.actor.system.defenses[groupId],
            attributes: groupConfig.attributes.map(this.prepareAttribute.bind(this)),
        };
    }
    prepareAttribute(attrId) {
        // Get the attribute config
        const attrConfig = CONFIG.COSMERE.attributes[attrId];
        const attr = this.application.actor.system.attributes[attrId];
        const source = this.application.actor._source.system.attributes[attrId];
        const total = attr.value + attr.bonus;
        const sourceTotal = source.value + source.bonus;
        return {
            id: attrId,
            config: attrConfig,
            ...attr,
            total,
            source: source,
            modified: total !== sourceTotal,
        };
    }
}
// Register
ActorAttributesComponent.register('app-actor-attributes');

async function journalEntryPageTextFromUuid(uuid, options = {}) {
    // Default options
    options.includeHeading = options.includeHeading ?? true;
    // Parse the UUID
    const { collection, documentId, id, type } = foundry.utils.parseUuid(uuid);
    if (!collection || !documentId || !id)
        return null;
    if (type !== 'JournalEntryPage')
        return null;
    // Load the journal entry
    const journal = collection instanceof CompendiumCollection
        ? (await collection.getDocument(documentId))
        : collection.get(documentId);
    if (!journal)
        return null;
    const [pageId, target] = id.split('#');
    // Get the page
    const page = journal.pages.get(pageId);
    if (!page)
        return null;
    // Get the text content of the page
    const text = getPageTextContent(page, target, options.includeHeading);
    if (!text)
        return null;
    // Enrich the text if requested
    return options.enrich
        ? await TextEditor.enrichHTML(text, {
            relativeTo: page,
        })
        : text;
}
function getPageTextContent(page, target, includeHeading = true) {
    if (!target)
        return page.text.content;
    const renderTarget = document.createElement('template');
    renderTarget.innerHTML = page.text.content;
    const toc = JournalEntryPage.buildTOC(Array.from(renderTarget.content.children));
    const validTargets = Object.keys(toc);
    // Check if the target exists in the ToC
    if (!validTargets.includes(target))
        return null;
    // Get the target heading
    const heading = toc[target].element;
    if (!heading)
        return null;
    const headingIndex = validTargets.indexOf(target);
    const nextHeading = headingIndex + 1 < validTargets.length
        ? toc[validTargets[headingIndex + 1]].element
        : null;
    // Get the text between the heading and the next heading
    const els = $(heading)
        .nextUntil(nextHeading ?? '')
        .filter((_, el) => $(el).text().trim() !== '');
    // Return the text content of the elements and the heading
    return [
        includeHeading ? heading.outerHTML : '',
        ...els.toArray().map((el) => el.outerHTML),
    ].join('');
}

class ActorConditionsComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_CONDITIONS}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'cycle-condition': {
            handler: this.onCycleCondition,
            buttons: [MouseButton.Primary, MouseButton.Secondary],
        },
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static async onCycleCondition(event) {
        // Get condition
        const condition = $(event.target)
            .closest('[data-id]')
            .data('id');
        // Whether the condition is active
        const active = this.application.actor.conditions.has(condition);
        // Get the config
        const config = CONFIG.COSMERE.statuses[condition];
        if (config.stackable && active) {
            const cycleUp = event.type === 'click';
            // Get the condition effect
            const effect = this.application.actor.appliedEffects.find((effect) => effect.isCondition && effect.statuses.has(condition));
            // Calculate the new stacks
            const newStacks = cycleUp ? effect.stacks + 1 : effect.stacks - 1;
            if (newStacks > 0) {
                // Update the effect
                await effect.update({
                    'system.stacks': newStacks,
                });
            }
            else {
                await this.application.actor.toggleStatusEffect(condition);
            }
        }
        else if (event.type === 'click') {
            // Toggle the status effect for the condition
            await this.application.actor.toggleStatusEffect(condition);
        }
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        return {
            ...context,
            conditions: await Promise.all(Object.keys(CONFIG.COSMERE.statuses)
                .filter((id) => CONFIG.COSMERE.statuses[id].condition)
                .map(async (id) => {
                // Get the config
                const config = CONFIG.COSMERE.statuses[id];
                const active = this.application.actor.conditions.has(id);
                const description = config.reference
                    ? `<div class="conditiontip">${await journalEntryPageTextFromUuid(config.reference, {
                        enrich: true,
                    })}</div>`
                    : null;
                const baseContext = {
                    id,
                    name: config.label,
                    description,
                    icon: config.icon,
                    active,
                    stackable: config.stackable,
                    immune: this.application.actor.system.immunities
                        .condition[id],
                };
                if (!active || !config.stackable)
                    return baseContext;
                else {
                    // Get all effects that apply the condition
                    const effects = this.application.actor.appliedEffects.filter((effect) => effect.statuses.has(id));
                    // Calculate the total count
                    const count = effects.reduce((total, effect) => total + effect.stacks, 0);
                    return {
                        ...baseContext,
                        stacks: config.stacksDisplayTransform
                            ? config.stacksDisplayTransform(count)
                            : count,
                    };
                }
            })),
        };
    }
}
// Register
ActorConditionsComponent.register('app-actor-conditions');

const { ApplicationV2: ApplicationV2$a, HandlebarsApplicationMixin: HandlebarsApplicationMixin$7 } = foundry.applications.api;
class ConfigureMovementRateDialog extends HandlebarsApplicationMixin$7((ApplicationV2$a)) {
    actor;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            positioned: true,
        },
        classes: ['dialog', 'configure-movement-rate'],
        tag: 'dialog',
        position: {
            width: 350,
        },
        actions: {
            'update-movement': this.onUpdateMovementRate,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ACTOR_CONFIGURE_MOVEMENT}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    movementData;
    constructor(actor) {
        super({
            id: `${actor.uuid}.MovementRate`,
            window: {
                title: game
                    .i18n.localize('DIALOG.ConfigureMovementRate.Title')
                    .replace('{actor}', actor.name),
            },
        });
        this.actor = actor;
        this.movementData = this.actor.system.movement;
        Object.keys(CONFIG.COSMERE.movement.types).forEach((type) => {
            this.movementData[type].rate.override ??=
                this.movementData[type].rate.value ?? 0;
        });
    }
    /* --- Statics --- */
    static async show(actor) {
        await new ConfigureMovementRateDialog(actor).render(true);
    }
    /* --- Actions --- */
    static onUpdateMovementRate() {
        void this.actor.update({
            'system.movement': this.movementData,
        });
        void this.close();
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        // Get event target
        const target = event.target;
        Object.keys(CONFIG.COSMERE.movement.types).forEach((type) => {
            // Get mode
            const mode = (formData.get(`${type}.mode`) ??
                Derived.Mode.Override);
            // Assign mode
            this.movementData[type].rate.mode = mode;
            // Assign rate
            if (mode === Derived.Mode.Override &&
                target.name === `${type}.value`) {
                this.movementData[type].rate.override = parseInt(formData.get(`${type}.value`));
            }
        });
        // Render
        void this.render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    /* --- Context --- */
    _prepareContext() {
        const movementRates = Object.keys(CONFIG.COSMERE.movement.types).map((type) => ({
            rate: this.movementData[type].rate,
            mode: this.movementData[type].rate.mode,
            type,
            label: CONFIG.COSMERE.movement.types[type].label,
        }));
        return Promise.resolve({
            actor: this.actor,
            modes: Derived.Modes,
            movementRates,
        });
    }
}

const { ApplicationV2: ApplicationV2$9, HandlebarsApplicationMixin: HandlebarsApplicationMixin$6 } = foundry.applications.api;
class ConfigureSensesRangeDialog extends HandlebarsApplicationMixin$6((ApplicationV2$9)) {
    actor;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            positioned: true,
        },
        classes: ['dialog', 'configure-senses-range'],
        tag: 'dialog',
        position: {
            width: 350,
        },
        actions: {
            'update-sense': this.onUpdateSensesRange,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ACTOR_CONFIGURE_SENSES}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    sensesData;
    mode;
    constructor(actor) {
        super({
            id: `${actor.uuid}.SensesRange`,
            window: {
                title: game
                    .i18n.localize('DIALOG.ConfigureSensesRange.Title')
                    .replace('{actor}', actor.name),
            },
        });
        this.actor = actor;
        this.sensesData = this.actor.system.senses;
        this.sensesData.range.override ??= this.sensesData.range.value ?? 0;
        this.mode = this.sensesData.range.mode;
    }
    /* --- Statics --- */
    static async show(actor) {
        await new ConfigureSensesRangeDialog(actor).render(true);
    }
    /* --- Actions --- */
    static onUpdateSensesRange() {
        void this.actor.update({
            'system.senses': this.sensesData,
        });
        void this.close();
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        // Get event target
        const target = event.target;
        // Get mode
        this.mode = formData.object.mode;
        // Assign mode
        this.sensesData.range.mode = this.mode;
        // Assign range
        if (this.mode === Derived.Mode.Override && target.name === 'range')
            this.sensesData.range.override = formData.object.range;
        // Assign obscured affected
        if (this.mode === Derived.Mode.Override &&
            target.name === 'ignoreObscure') {
            this.sensesData.range.override = formData.object.ignoreObscure
                ? Number.MAX_VALUE
                : 0;
        }
        // Render
        void this.render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            actor: this.actor,
            mode: this.mode,
            modes: Derived.Modes,
            ...this.sensesData,
        });
    }
}

/**
 * Returns the advancement rule for the given level.
 */
/**
 * Returns the all advancement rules up to and including the given level.
 * If the level is higher than the last rule, the last rule is repeated.
 * @returns An array of advancement rules with the length equal to the given level.
 */
function getAdvancementRulesUpToLevel(level) {
    return getAdvancementRulesForLevelChange(0, level);
}
/**
 * Returns the all advancement rules between the start level (exclusive) and the end level (inclusive).
 * If the end level is higher than the last rule, the last rule is repeated.
 */
function getAdvancementRulesForLevelChange(startLevel, endLevel) {
    // Swap the levels if the end level is lower than the start level
    if (endLevel < startLevel)
        return getAdvancementRulesForLevelChange(endLevel, startLevel).reverse();
    // Ensure start level is at least 0
    startLevel = Math.max(0, startLevel);
    // Get the rules
    const rules = CONFIG.COSMERE.advancement.rules;
    return Array.from({ length: endLevel - startLevel }, (_, i) => {
        const index = startLevel + i;
        return index >= rules.length
            ? { ...rules[rules.length - 1], level: index + 1 }
            : { ...rules[index], level: index + 1 };
    });
}
function deriveMaxHealth(levelOrRules, strength) {
    // Get rules up to the given level
    const rules = Array.isArray(levelOrRules)
        ? levelOrRules
        : getAdvancementRulesUpToLevel(levelOrRules);
    // Calculate the health
    return rules.reduce((health, rule) => health +
        (rule.health ?? 0) +
        (rule.healthIncludeStrength ? strength : 0), 0);
}

class CharacterActorDataModel extends CommonActorDataModel {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            /* --- Advancement --- */
            level: new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                integer: true,
                min: 1,
                initial: 1,
                label: 'COSMERE.Actor.Level.Label',
            }),
            maxSkillRank: new foundry.data.fields.NumberField({
                required: true,
                nullable: false,
                integer: true,
                initial: 2,
                max: 5,
            }),
            /* --- Derived statistics --- */
            recovery: new foundry.data.fields.SchemaField({
                die: new DerivedValueField(new foundry.data.fields.StringField({
                    required: true,
                    blank: false,
                    initial: 'd4',
                    choices: RECOVERY_DICE,
                })),
            }),
            /* --- Goals, Connections, Purpose, and Obstacle --- */
            goals: new foundry.data.fields.ArrayField(new foundry.data.fields.SchemaField({
                text: new foundry.data.fields.StringField({
                    required: true,
                }),
                level: new foundry.data.fields.NumberField({
                    required: true,
                    integer: true,
                    initial: 0,
                    min: 0,
                    max: 3,
                }),
            }), {
                required: true,
                nullable: true,
                initial: null,
            }),
            connections: new foundry.data.fields.ArrayField(new foundry.data.fields.SchemaField({
                name: new foundry.data.fields.StringField({
                    required: true,
                }),
                description: new foundry.data.fields.HTMLField({
                    required: true,
                }),
            }), {
                required: true,
                nullable: false,
                initial: [],
            }),
            purpose: new foundry.data.fields.HTMLField({
                required: true,
                initial: '',
            }),
            obstacle: new foundry.data.fields.HTMLField({
                required: true,
                initial: '',
            }),
        });
    }
    prepareDerivedData() {
        super.prepareDerivedData();
        // Get advancement rules relevant to the character
        const advancementRules = getAdvancementRulesUpToLevel(this.level);
        const currentAdvancementRule = advancementRules[advancementRules.length - 1];
        // Derive the tier
        this.tier = currentAdvancementRule.tier;
        // Derive the maximum skill rank
        this.maxSkillRank = currentAdvancementRule.maxSkillRanks;
    }
    prepareSecondaryDerivedData() {
        // Get advancement rules relevant to the character
        const advancementRules = getAdvancementRulesUpToLevel(this.level);
        // Derive the recovery die based on the character's willpower
        this.recovery.die.derived = willpowerToRecoveryDie(this.attributes.wil);
        // Derive resource max
        Object.keys(this.resources).forEach((key) => {
            // Get the resource
            const resource = this.resources[key];
            if (key === "hea" /* Resource.Health */) {
                // Assign max
                resource.max.derived = deriveMaxHealth(advancementRules, this.attributes.str.value);
            }
            else if (key === "foc" /* Resource.Focus */) {
                // Assign max
                resource.max.derived = 2 + this.attributes.wil.value; // Should only be the value, not include the bonus
            }
        });
        // Perform super secondary derived data preparation after so resource max is set
        super.prepareSecondaryDerivedData();
    }
}
const RECOVERY_DICE = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
function willpowerToRecoveryDie(attr) {
    const willpower = attr.value + attr.bonus;
    return RECOVERY_DICE[Math.min(Math.ceil(willpower / 2), RECOVERY_DICE.length)];
}

const { ApplicationV2: ApplicationV2$8, HandlebarsApplicationMixin: HandlebarsApplicationMixin$5 } = foundry.applications.api;
class ConfigureRecoveryDieDialog extends HandlebarsApplicationMixin$5((ApplicationV2$8)) {
    actor;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            positioned: true,
        },
        classes: ['dialog', 'configure-recovery-die'],
        tag: 'dialog',
        position: {
            width: 350,
        },
        actions: {
            'update-recovery': this.onUpdateRecoveryDie,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ACTOR_CONFIGURE_RECOVERY}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    recoveryData;
    mode;
    constructor(actor) {
        super({
            id: `${actor.uuid}.RecoveryDie`,
            window: {
                title: game
                    .i18n.localize('DIALOG.ConfigureRecoveryDie.Title')
                    .replace('{actor}', actor.name),
            },
        });
        this.actor = actor;
        this.recoveryData = this.actor.system.recovery;
        this.recoveryData.die.override ??=
            this.recoveryData.die.value ?? RECOVERY_DICE[0];
        this.mode = this.recoveryData.die.mode;
    }
    /* --- Statics --- */
    static async show(actor) {
        await new ConfigureRecoveryDieDialog(actor).render(true);
    }
    /* --- Actions --- */
    static onUpdateRecoveryDie() {
        void this.actor.update({
            'system.recovery': this.recoveryData,
        });
        void this.close();
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        // Get event target
        const target = event.target;
        // Get mode
        this.mode = formData.object.mode;
        // Assign mode
        this.recoveryData.die.mode = this.mode;
        // Assign rate
        if (this.mode === Derived.Mode.Override && target.name === 'die')
            this.recoveryData.die.override = formData.object.die;
        // Render
        void this.render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            actor: this.actor,
            mode: this.mode,
            modes: Derived.Modes,
            ...this.recoveryData,
            value: this.recoveryData.die.value,
            recoveryDice: RECOVERY_DICE.reduce((dice, die) => ({
                ...dice,
                [die]: die,
            }), {}),
            override: this.recoveryData.die.override,
        });
    }
}

const { ApplicationV2: ApplicationV2$7, HandlebarsApplicationMixin: HandlebarsApplicationMixin$4 } = foundry.applications.api;
class ConfigureDeflectDialog extends HandlebarsApplicationMixin$4((ApplicationV2$7)) {
    actor;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            positioned: true,
        },
        classes: ['dialog', 'configure-deflect'],
        tag: 'dialog',
        position: {
            width: 350,
        },
        actions: {
            'update-deflect': this.onUpdateDeflect,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ACTOR_CONFIGURE_DEFLECT}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    data;
    mode;
    constructor(actor) {
        super({
            id: `${actor.uuid}.Deflect`,
            window: {
                title: game.i18n.format('DIALOG.ConfigureDeflect.Title', {
                    actor: actor.name,
                }),
            },
        });
        this.actor = actor;
        this.data = actor.system.deflect;
        this.data.natural ??= 0;
        this.data.override ??= this.data.value ?? 0;
        this.data.bonus ??= 0;
        this.mode = this.data.mode;
    }
    /* --- Statics --- */
    static show(actor) {
        void new ConfigureDeflectDialog(actor).render(true);
    }
    /* --- Actions --- */
    static onUpdateDeflect() {
        void this.actor.update({
            'system.deflect': this.data,
        });
        void this.close();
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        const target = event.target;
        this.mode = formData.get('mode');
        if (target.name !== 'mode') {
            if (this.mode === Derived.Mode.Override) {
                this.data.override = Number(formData.object.value ?? 0);
            }
            else {
                this.data.natural = Number(formData.object.natural ?? 0);
                this.data.bonus = Number(formData.object.bonus ?? 0);
            }
        }
        if (isNaN(this.data.override))
            this.data.override = 0;
        if (isNaN(this.data.natural))
            this.data.natural = 0;
        if (isNaN(this.data.bonus))
            this.data.bonus = 0;
        // Assign mode
        this.data.mode = this.mode;
        // Render
        void this.render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            ...this.data,
            mode: this.mode,
            modes: {
                ...Derived.Modes,
                [Derived.Mode.Derived]: 'TYPES.Item.armor',
            },
        });
    }
}

class ActorDetailsComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_DETAILS}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'short-rest': this.onShortRest,
        'long-rest': this.onLongRest,
        'configure-movement-rate': this.onConfigureMovementRate,
        'configure-senses-range': this.onConfigureSensesRange,
        'configure-recovery': this.onConfigureRecovery,
        'configure-deflect': this.onConfigureDeflect,
        'edit-img': this.onEditImg,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onShortRest() {
        void this.application.actor.shortRest();
    }
    static onLongRest() {
        void this.application.actor.longRest();
    }
    static onConfigureMovementRate() {
        void ConfigureMovementRateDialog.show(this.application.actor);
    }
    static onConfigureSensesRange() {
        void ConfigureSensesRangeDialog.show(this.application.actor);
    }
    static onConfigureDeflect() {
        void ConfigureDeflectDialog.show(this.application.actor);
    }
    static onConfigureRecovery() {
        if (this.application.actor.isCharacter())
            void ConfigureRecoveryDieDialog.show(this.application.actor);
    }
    static onEditImg() {
        if (this.application.mode !== 'edit')
            return;
        const { img: defaultImg } = CosmereActor.getDefaultArtwork(this.application.actor.toObject());
        void new FilePicker({
            current: this.application.actor.img,
            type: 'image',
            redirectToRoot: [defaultImg],
            top: this.application.position.top + 40,
            left: this.application.position.left + 10,
            callback: (path) => {
                void this.application.actor.update({
                    img: path,
                });
            },
        }).browse();
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        const actor = this.application.actor;
        // Determine movement type with the highest movement rate
        const preferredMovementType = Object.keys(CONFIG.COSMERE.movement.types)
            .map((type) => [type, actor.system.movement[type].rate.value])
            .filter(([, rate]) => rate > 0)
            .sort(([, rateA], [, rateB]) => rateB - rateA)[0]?.[0];
        return Promise.resolve({
            ...context,
            type: actor.type,
            displayRestButtons: actor.type === "character" /* ActorType.Character */,
            displayRecovery: actor.type === "character" /* ActorType.Character */,
            preferredMovementType,
            movementTooltip: this.generateMovementTooltip(),
            deflectTooltip: this.generateDeflectTooltip(),
        });
    }
    generateDeflectTooltip() {
        const actor = this.application.actor;
        if (!actor.system.deflect.types)
            return null;
        const entries = Object.keys(CONFIG.COSMERE.damageTypes)
            .filter((key) => actor.system.deflect.types[key] ?? false)
            .map((key) => game.i18n.localize(CONFIG.COSMERE.damageTypes[key].label));
        return `${game.i18n.localize('COSMERE.Actor.Statistics.Deflect')}: ${entries.join(', ')}`;
    }
    generateMovementTooltip() {
        const actor = this.application.actor;
        const entries = Object.entries(CONFIG.COSMERE.movement.types)
            .map(([type, config]) => ({
            type,
            rate: actor.system.movement[type].rate.value ?? 0,
            label: game.i18n.localize(config.label),
        }))
            .filter(({ rate }) => rate > 0)
            .map(({ rate, label }) => `
                <div>
                    <span><b>${label}:</b></span>
                    <span>${rate} ft.</span>
                </div>
            `);
        return `${entries.join('')}`;
    }
}
// Register
ActorDetailsComponent.register('app-actor-details');

// Constants
const TITLE_MAP$1 = {
    inactive: 'COSMERE.Sheet.Effects.Inactive',
    passive: 'COSMERE.Sheet.Effects.Passive',
    temporary: 'COSMERE.Sheet.Effects.Temporary',
};
class ActorEffectsListComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_EFFECTS_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'toggle-effect-active': this.onToggleEffectActive,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onToggleEffectActive(event) {
        const effect = this.getEffectFromEvent(event);
        if (!effect)
            return;
        // Toggle active
        void effect.update({
            disabled: !effect.disabled,
        });
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        // Get effects
        let effects = this.application.actor.applicableEffects
            .filter((effect) => !effect.id.startsWith('cond'))
            .filter((effect) => effect.name.toLowerCase().includes(context.effectsSearch.text));
        if (context.effectsSearch.sort === "alphabetic" /* SortMode.Alphabetic */) {
            effects = effects.sort((a, b) => a.name.compare(b.name));
        }
        // Filter effects down to the correct type
        if (params.type === 'inactive') {
            effects = effects.filter((effect) => !effect.active);
        }
        else if (params.type === 'passive') {
            effects = effects.filter((effect) => effect.active && !effect.isTemporary);
        }
        else if (params.type === 'temporary') {
            effects = effects.filter((effect) => effect.active && effect.isTemporary);
        }
        // Set context
        return Promise.resolve({
            ...context,
            effectsTitle: TITLE_MAP$1[params.type],
            effects,
        });
    }
    /* --- Lifecycle --- */
    _onInitialize() {
        if (this.application.isEditable) {
            // Create context menu
            AppContextMenu.create({
                parent: this,
                items: [
                    {
                        name: 'GENERIC.Button.Edit',
                        icon: 'fa-solid fa-pen-to-square',
                        callback: (element) => {
                            const effect = this.getEffectFromElement(element);
                            if (!effect)
                                return;
                            void effect.sheet?.render(true);
                        },
                    },
                    {
                        name: 'GENERIC.Button.Remove',
                        icon: 'fa-solid fa-trash',
                        callback: (element) => {
                            const effect = this.getEffectFromElement(element);
                            if (!effect)
                                return;
                            void effect.parent?.deleteEmbeddedDocuments('ActiveEffect', [effect.id]);
                        },
                    },
                ],
                selectors: ['a[data-action="toggle-effect-controls"]'],
                anchor: 'right',
            });
        }
    }
    /* --- Helpers --- */
    getEffectFromEvent(event) {
        if (!event.target && !event.currentTarget)
            return;
        return this.getEffectFromElement((event.target ?? event.currentTarget));
    }
    getEffectFromElement(element) {
        const effectElement = $(element).closest('.effect[data-id]');
        // Get the id
        const id = effectElement.data('id');
        // Get the parent id (if it exists)
        const parentId = effectElement.data('parent-id');
        // Get the effect
        return this.getEffect(id, parentId);
    }
    getEffect(effectId, parentId) {
        if (!parentId)
            return this.application.actor.getEmbeddedDocument('ActiveEffect', effectId);
        else {
            // Get item
            const item = this.application.actor.getEmbeddedDocument('Item', parentId);
            return item?.getEmbeddedDocument('ActiveEffect', effectId);
        }
    }
}
// Register
ActorEffectsListComponent.register('app-actor-effects-list');

// Documents
class ActorEquipmentListComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_EQUIPMENT_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'toggle-action-details': this.onToggleActionDetails,
        'use-item': this.onUseItem,
        'new-item': this.onNewItem,
        'toggle-equip': this.onToggleEquip,
        'cycle-equip': this.onCycleEquip,
        'decrease-quantity': this.onDecreaseQuantity,
        'increase-quantity': this.onIncreaseQuantity,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    sections = [];
    /**
     * Map of id to state
     */
    itemState = {};
    /* --- Actions --- */
    static onToggleActionDetails(event) {
        // Get item element
        const itemElement = $(event.target).closest('.item[data-item-id]');
        // Get item id
        const itemId = itemElement.data('item-id');
        // Update the state
        this.itemState[itemId].expanded = !this.itemState[itemId].expanded;
        // Set classes
        itemElement.toggleClass('expanded', this.itemState[itemId].expanded);
        itemElement
            .find('a[data-action="toggle-action-details"')
            .empty()
            .append(this.itemState[itemId].expanded
            ? '<i class="fa-solid fa-compress"></i>'
            : '<i class="fa-solid fa-expand"></i>');
    }
    static onUseItem(event) {
        // Get item
        const item = AppUtils.getItemFromEvent(event, this.application.actor);
        if (!item)
            return;
        // Use the item
        void this.application.actor.useItem(item);
    }
    static async onNewItem(event) {
        // Get section element
        const sectionElement = $(event.target).closest('[data-section-id]');
        // Get section id
        const sectionId = sectionElement.data('section-id');
        // Get section
        const section = this.sections.find((s) => s.id === sectionId);
        if (!section)
            return;
        // Create new item
        const item = await section.new?.(this.application.actor);
        if (!item)
            return;
        // Render the item sheet
        void item.sheet?.render(true);
    }
    static onToggleEquip(event) {
        if (!this.application.isEditable)
            return;
        // Get item
        const item = AppUtils.getItemFromEvent(event, this.application.actor);
        if (!item)
            return;
        if (!item.isEquippable())
            return;
        void item.update({
            'system.equipped': !item.system.equipped,
        });
    }
    static onCycleEquip(event) {
        if (!this.application.isEditable)
            return;
        // Get item
        const item = AppUtils.getItemFromEvent(event, this.application.actor);
        if (!item)
            return;
        if (!item.isEquippable())
            return;
        // Get hand types
        const handTypes = Object.keys(CONFIG.COSMERE.items.equip.hand);
        // Get current index
        const index = handTypes.indexOf(item.system.equip.hand ?? handTypes[handTypes.length - 1]);
        const shouldEquip = !item.system.equipped;
        const shouldUnequip = item.system.equipped && index === handTypes.length - 1;
        const newEquip = shouldEquip || !shouldUnequip;
        const newIndex = shouldEquip ? 0 : shouldUnequip ? index : index + 1;
        // Update item
        void item.update({
            'system.equipped': newEquip,
            'system.equip.hand': handTypes[newIndex],
        });
    }
    static async onDecreaseQuantity(event) {
        await this.triggerQuantityChange(event, false);
    }
    static async onIncreaseQuantity(event) {
        await this.triggerQuantityChange(event, true);
    }
    /* --- Event handlers --- */
    triggerCurrencyChange() {
        const event = new CustomEvent('currency', {});
        this.element.dispatchEvent(event);
    }
    async triggerQuantityChange(event, increase = true) {
        // Get item
        const item = AppUtils.getItemFromEvent(event, this.application.actor);
        if (!item)
            return;
        if (!item.isPhysical())
            return;
        let modifier = increase ? 1 : -1;
        if (areKeysPressed(KEYBINDINGS.CHANGE_QUANTITY_BY_5)) {
            modifier *= 5;
        }
        else if (areKeysPressed(KEYBINDINGS.CHANGE_QUANTITY_BY_10)) {
            modifier *= 10;
        }
        else if (areKeysPressed(KEYBINDINGS.CHANGE_QUANTITY_BY_50)) {
            modifier *= 50;
        }
        await item.update({
            'system.quantity': item.system.quantity + modifier,
        }, { render: false });
        await this.render();
        this.triggerCurrencyChange();
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        // Assume all physical items are part of inventory
        const physicalItems = this.application.actor.items.filter((item) => item.isPhysical());
        // Ensure all items have an expand state record
        physicalItems.forEach((item) => {
            if (!(item.id in this.itemState)) {
                this.itemState[item.id] = {
                    expanded: false,
                };
            }
        });
        // Prepare sections
        this.sections = [
            this.prepareSection("weapon" /* ItemType.Weapon */),
            this.prepareSection("armor" /* ItemType.Armor */),
            this.prepareSection("equipment" /* ItemType.Equipment */),
            this.prepareSection("loot" /* ItemType.Loot */),
        ];
        return {
            ...context,
            sections: await Promise.all(this.sections.map((section) => this.prepareSectionData(section, physicalItems, context.equipmentSearch.text, context.equipmentSearch.sort))),
            itemState: this.itemState,
        };
    }
    prepareSection(type) {
        return {
            id: type,
            label: CONFIG.COSMERE.items.types[type].labelPlural,
            default: true,
            filter: (item) => item.type === type,
            new: (parent) => CosmereItem.create({
                type,
                name: game.i18n.localize(`COSMERE.Item.Type.${type.capitalize()}.New`),
            }, { parent }),
        };
    }
    async prepareSectionData(section, items, filterText, sort) {
        // Get items for section, filter by search text, and sort
        let sectionItems = items
            .filter(section.filter)
            .filter((i) => i.name.toLowerCase().includes(filterText));
        if (sort === "alphabetic" /* SortMode.Alphabetic */) {
            sectionItems = sectionItems.sort((a, b) => a.name.compare(b.name));
        }
        return {
            ...section,
            canAddNewItems: !!section.new,
            items: sectionItems,
            itemData: await this.prepareItemData(sectionItems),
        };
    }
    async prepareItemData(items) {
        return await items.reduce(async (prev, item) => ({
            ...(await prev),
            [item.id]: {
                ...(item.hasDescription() && item.system.description?.value
                    ? {
                        descriptionHTML: await TextEditor.enrichHTML(item.system.description.value, {
                            relativeTo: item.system
                                .parent,
                        }),
                    }
                    : {}),
            },
        }), Promise.resolve({}));
    }
    /* --- Lifecycle --- */
    _onInitialize() {
        if (this.application.isEditable) {
            // Create context menu
            AppContextMenu.create({
                parent: this,
                items: (element) => {
                    // Get item id
                    const itemId = $(element)
                        .closest('.item[data-item-id]')
                        .data('item-id');
                    // Get item
                    const item = this.application.actor.items.get(itemId);
                    // Check if actor is character
                    const isCharacter = this.application.actor.isCharacter();
                    // Check if item is favorited
                    const isFavorite = item.isFavorite;
                    return [
                        // Favorite (only for characters)
                        isCharacter
                            ? isFavorite
                                ? {
                                    name: 'GENERIC.Button.RemoveFavorite',
                                    icon: 'fa-solid fa-star',
                                    callback: () => {
                                        void item.clearFavorite();
                                    },
                                }
                                : {
                                    name: 'GENERIC.Button.Favorite',
                                    icon: 'fa-solid fa-star',
                                    callback: () => {
                                        void item.markFavorite(this.application.actor.favorites
                                            .length);
                                    },
                                }
                            : null,
                        {
                            name: 'GENERIC.Button.Edit',
                            icon: 'fa-solid fa-pen-to-square',
                            callback: () => {
                                void item.sheet?.render(true);
                            },
                        },
                        {
                            name: 'GENERIC.Button.Remove',
                            icon: 'fa-solid fa-trash',
                            callback: () => {
                                // Remove the item
                                void this.application.actor.deleteEmbeddedDocuments('Item', [item.id]);
                            },
                        },
                    ].filter((i) => !!i);
                },
                selectors: ['a[data-action="toggle-actions-controls"]'],
                anchor: 'right',
            });
        }
    }
}
// Register
ActorEquipmentListComponent.register('app-actor-equipment-list');

class ActorInjuriesListComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_INJURIES_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'toggle-injury-controls': this.onToggleInjuryControls,
        'reduce-injury-duration': this.onDecreaseInjuryDuration,
        'increase-injury-duration': this.onIncreaseInjuryDuration,
        'edit-injury': this.onEditInjury,
        'remove-injury': this.onRemoveInjury,
        'create-injury': this.onCreateInjury,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    contextInjuryId = null;
    controlsDropdownExpanded = false;
    /* --- Actions --- */
    static onToggleInjuryControls(event) {
        // Get connection id
        const injuryId = $(event.currentTarget)
            .closest('[data-item-id]')
            .data('item-id');
        const target = event.currentTarget;
        const root = $(target).closest('.tab-body');
        const dropdown = $(target)
            .closest('.item-list')
            .siblings('.controls-dropdown');
        const targetRect = target.getBoundingClientRect();
        const rootRect = root[0].getBoundingClientRect();
        if (this.contextInjuryId !== injuryId) {
            dropdown.css({
                top: `${Math.round(targetRect.top - rootRect.top)}px`,
                right: `${Math.round(rootRect.right - targetRect.right + targetRect.width)}px`,
            });
            if (!this.controlsDropdownExpanded) {
                dropdown.addClass('expanded');
                this.controlsDropdownExpanded = true;
            }
            this.contextInjuryId = injuryId;
        }
        else if (this.controlsDropdownExpanded) {
            dropdown.removeClass('expanded');
            this.controlsDropdownExpanded = false;
            this.contextInjuryId = null;
        }
    }
    static onDecreaseInjuryDuration(event) {
        // Get injury item
        const injuryItem = AppUtils.getItemFromEvent(event, this.application.actor);
        if (!injuryItem?.isInjury())
            return;
        // Reduce duration by one
        void injuryItem.update({
            'system.duration.remaining': injuryItem.system.duration.remaining - 1,
        });
    }
    static onIncreaseInjuryDuration(event) {
        // Get injury item
        const injuryItem = AppUtils.getItemFromEvent(event, this.application.actor);
        if (!injuryItem?.isInjury())
            return;
        // Increase duration by one
        void injuryItem.update({
            'system.duration.remaining': injuryItem.system.duration.remaining + 1,
        });
    }
    static async onRemoveInjury() {
        this.controlsDropdownExpanded = false;
        // Ensure context goal id is set
        if (this.contextInjuryId !== null) {
            // Remove the connection
            await this.application.actor.deleteEmbeddedDocuments('Item', [this.contextInjuryId], { render: false });
            this.contextInjuryId = null;
        }
        // Render
        await this.render();
    }
    static onEditInjury() {
        this.controlsDropdownExpanded = false;
        // Ensure context goal id is set
        if (this.contextInjuryId !== null) {
            // Get the injur
            const injury = this.application.actor.items.find((i) => i.id === this.contextInjuryId);
            // Show injury sheet
            void injury.sheet?.render(true);
            this.contextInjuryId = null;
        }
        // Render
        void this.render();
    }
    static async onCreateInjury() {
        this.controlsDropdownExpanded = false;
        // Create new injury
        const item = (await Item.create({
            type: "injury" /* ItemType.Injury */,
            name: game.i18n.localize('COSMERE.Actor.Sheet.Injuries.NewInjury'),
        }, { parent: this.application.actor }));
        // Show sheet
        void item.sheet?.render(true);
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        // Get list of injuries
        const injuries = this.application.actor.items.filter((item) => item.isInjury());
        return Promise.resolve({
            ...context,
            injuries: injuries
                .map((item) => {
                const type = item.system.type;
                return {
                    ...item,
                    id: item.id,
                    type,
                    typeLabel: CONFIG.COSMERE.injury.types[type].label,
                    duration: item.system.duration,
                    isPermanent: type === "permanent_injury" /* InjuryType.PermanentInjury */ ||
                        type === "death" /* InjuryType.Death */,
                };
            })
                .sort((a, b) => {
                const remainingA = a.type === "permanent_injury" /* InjuryType.PermanentInjury */
                    ? Number.MAX_SAFE_INTEGER
                    : (a.duration.remaining ?? 0);
                const remainingB = b.type === "permanent_injury" /* InjuryType.PermanentInjury */
                    ? Number.MAX_SAFE_INTEGER
                    : (b.duration.remaining ?? 0);
                return remainingB - remainingA;
            }),
        });
    }
}
// Register
ActorInjuriesListComponent.register('app-actor-injuries-list');

class ActorCurrencyListComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_CURRENCY_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    static ACTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.ACTIONS), {});
    /* --- Context --- */
    async _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            currencies: await Promise.all(Object.keys(CONFIG.COSMERE.currencies).map(this.prepareCurrency.bind(this))),
        });
    }
    async prepareCurrency(currencyId) {
        const currencyConfig = foundry.utils.duplicate(CONFIG.COSMERE.currencies[currencyId]);
        try {
            await FilePicker.browse('data', currencyConfig.icon ?? '');
        }
        catch (ex) {
            currencyConfig.icon = undefined;
        }
        return {
            id: currencyId,
            config: currencyConfig,
            total: this.application.actor.system.currency[currencyId].total,
        };
    }
}
// Register
ActorCurrencyListComponent.register('app-actor-currency-list');

class ActorNotesFieldsComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_NOTES_FIELDS}`;
    _prepareContext(params, context) {
        return Promise.resolve({ ...context });
    }
}
// Register the comopnent
ActorNotesFieldsComponent.register('app-actor-notes-fields');

const { ApplicationV2: ApplicationV2$6, HandlebarsApplicationMixin: HandlebarsApplicationMixin$3 } = foundry.applications.api;
class ConfigureResourceDialog extends HandlebarsApplicationMixin$3((ApplicationV2$6)) {
    actor;
    resourceId;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            minimizable: false,
            positioned: true,
        },
        classes: ['dialog', 'configure-resource'],
        tag: 'dialog',
        position: {
            width: 350,
        },
        actions: {
            'update-resource': this.onUpdateResource,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ACTOR_CONFIGURE_RESOURCE}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    resourceData;
    mode;
    constructor(actor, resourceId) {
        super({
            id: `${actor.uuid}.Resource.${resourceId}`,
            window: {
                title: game
                    .i18n.localize('DIALOG.ConfigureResource.Title')
                    .replace('{resource}', game.i18n.localize(CONFIG.COSMERE.resources[resourceId].label))
                    .replace('{actor}', actor.name),
            },
        });
        this.actor = actor;
        this.resourceId = resourceId;
        this.resourceData = this.actor.system.schema.getField(`resources.${resourceId}`).initialize(foundry.utils.deepClone(this.actor.system.resources[resourceId]), this.actor);
        this.resourceData.max.override ??= this.resourceData.max.value ?? 0;
        this.mode = this.resourceData.max.mode;
    }
    /* --- Statics --- */
    static async show(actor, resource) {
        await new ConfigureResourceDialog(actor, resource).render(true);
    }
    /* --- Actions --- */
    static onUpdateResource() {
        void this.actor.update({
            [`system.resources.${this.resourceId}`]: {
                max: {
                    useOverride: this.resourceData.max.useOverride,
                    override: this.resourceData.max.override,
                },
            },
        });
        void this.close();
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        // Get event target
        const target = event.target;
        // Get mode
        this.mode = formData.object.mode;
        // Assign mode
        this.resourceData.max.mode = this.mode;
        // Assign rate
        if (this.mode === Derived.Mode.Override && target.name === 'max')
            this.resourceData.max.override = formData.object.max;
        // Render
        void this.render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    /* --- Context --- */
    _prepareContext() {
        // Get config
        const config = CONFIG.COSMERE.resources[this.resourceId];
        return Promise.resolve({
            actor: this.actor,
            mode: this.mode,
            modes: Derived.Modes,
            ...this.resourceData,
            formula: config.formula,
        });
    }
}

class ActorResourceComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_RESOURCE}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'edit-value': this.onEditValue,
        'configure-resource': this.onConfigureResource,
        'roll-injury': this.onRollInjury,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onEditValue(event) {
        if (!this.application.isEditable)
            return;
        const resourceBarElement = $(event.target).closest('.bar:not(.editing)');
        if (resourceBarElement.length === 0)
            return;
        // Add editing class
        resourceBarElement.addClass('editing');
        // Get input element
        const inputElement = resourceBarElement.find('input');
        inputElement.on('focusout', () => {
            inputElement.off('focusout');
            // Remove editing class
            resourceBarElement.removeClass('editing');
        });
        setTimeout(() => {
            inputElement.trigger('select');
        });
    }
    static async onConfigureResource(event) {
        // Get the resource id
        const resourceId = $(event.target ?? event.currentTarget)
            .closest('[data-id]')
            .data('id');
        // Show dialog
        await ConfigureResourceDialog.show(this.application.actor, resourceId);
    }
    static onRollInjury() {
        if (this.params.resource !== "hea" /* Resource.Health */)
            return;
        // Get actor
        const actor = this.application.actor;
        // Roll injury
        void actor.rollInjury();
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        // Get resource
        const resource = context.actor.system.resources[params.resource];
        // Get resource config
        const config = CONFIG.COSMERE.resources[params.resource];
        // Get value and max
        const value = resource.value;
        const max = resource.max.value;
        return Promise.resolve({
            ...context,
            resource: {
                id: params.resource,
                label: config.label,
                value,
                max,
            },
        });
    }
}
// Register
ActorResourceComponent.register('app-actor-resource');

// Component imports
class ActorSearchBarComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_SEARCH_BAR}`;
    /**
     * The amount of time to wait after a user's keypress before the name search filter is applied, in milliseconds.
     * @type {number}
     */
    static FILTER_DEBOUNCE_MS = 200;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'actions-clear-filter': this.onClearFilter,
        'actions-filter-by': this.onFilterBy,
        'actions-toggle-sort': this.onToggleSort,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    searchText = '';
    sortDirection = "alphabetic" /* SortMode.Alphabetic */;
    /* --- Actions --- */
    static onClearFilter() {
        this.searchText = '';
        void this.render();
        this.triggerChange();
    }
    static onFilterBy() { }
    static onToggleSort() {
        this.sortDirection =
            this.sortDirection === "alphabetic" /* SortMode.Alphabetic */
                ? "manual" /* SortMode.Manual */
                : "alphabetic" /* SortMode.Alphabetic */;
        void this.render();
        this.triggerChange();
    }
    /* --- Life cycle --- */
    _onAttachListeners() {
        const debounceSearch = foundry.utils.debounce(this.onSearchInput.bind(this), ActorSearchBarComponent.FILTER_DEBOUNCE_MS);
        $(this.element).find('input').on('input', debounceSearch);
    }
    /* --- Event handlers --- */
    async onSearchInput(event) {
        if (event.type !== 'input')
            return;
        event.preventDefault();
        event.stopPropagation();
        this.searchText = event.target.value;
        await this.render();
        this.triggerChange();
        const search = $(this.element).find('input')[0];
        search.selectionStart = search.selectionEnd = this.searchText.length;
    }
    triggerChange() {
        const event = new CustomEvent('search', {
            detail: {
                text: this.searchText.toLocaleLowerCase(game.i18n.lang),
                sort: this.sortDirection,
            },
        });
        this.element.dispatchEvent(event);
    }
    /* --- Context --- */
    _prepareContext(params) {
        return Promise.resolve({
            text: this.searchText,
            sort: this.sortDirection,
            placeholder: params.placeholder,
        });
    }
}
// Register
ActorSearchBarComponent.register('app-actor-search-bar');

class ActorSkillsGroupComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_SKILLS_GROUP}`;
    /* --- Accessors --- */
    get skillIds() {
        if (this.params?.skills) {
            return this.params.skills;
        }
        else {
            // Ensure group-id is provided
            if (!this.params?.['group-id'])
                throw new Error('ActorSkillsGroupComponent: No group-id provided.');
            // Get the group id from params
            const groupId = this.params['group-id'];
            // Get the attribute group config
            const groupConfig = CONFIG.COSMERE.attributeGroups[groupId];
            // Get the skill ids
            const skillIds = groupConfig.attributes
                .map((attrId) => CONFIG.COSMERE.attributes[attrId])
                .map((attr) => attr.skills)
                .flat()
                .filter((skillId) => this.params.core === false ||
                CONFIG.COSMERE.skills[skillId].core)
                .sort((a, b) => a.localeCompare(b)); // Sort alphabetically
            return skillIds;
        }
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            id: params['group-id'],
            skills: this.skillIds
                .map((skillId) => {
                // Get skill
                const skill = this.application.actor.system.skills[skillId];
                // Get config
                const config = CONFIG.COSMERE.skills[skillId];
                // Get attribute config
                const attrConfig = CONFIG.COSMERE.attributes[config.attribute];
                return {
                    id: skillId,
                    config: {
                        ...config,
                        attrLabel: attrConfig.labelShort,
                    },
                    ...skill,
                    active: !config.hiddenUntilAcquired || skill.rank >= 1,
                };
            })
                .sort((a, b) => {
                const _a = a.config.hiddenUntilAcquired ? 1 : 0;
                const _b = b.config.hiddenUntilAcquired ? 1 : 0;
                return _a - _b;
            }),
        });
    }
}
// Register
ActorSkillsGroupComponent.register('app-actor-skills-group');

class ActorSkillComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_SKILL}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'roll-skill': this.onRollSkill,
        'adjust-skill-rank': {
            handler: this.onAdjustSkillRank,
            buttons: [MouseButton.Primary, MouseButton.Secondary],
        },
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onRollSkill(event) {
        event.preventDefault();
        const skillId = $(event.currentTarget)
            .closest('[data-id]')
            .data('id');
        void this.application.actor.rollSkill(skillId);
    }
    static async onAdjustSkillRank(event) {
        event.preventDefault();
        // Check if click is left or right mouse button
        const isLeftClick = event.type === 'click' ? true : false;
        // Check if the legacy behavior is toggled on
        const shouldIncDec = getSystemSetting(SETTINGS.SHEET_SKILL_INCDEC_TOGGLE);
        // Get skill id
        const skillId = $(event.currentTarget)
            .closest('[data-id]')
            .data('id');
        if (!skillId)
            return;
        if (!shouldIncDec) {
            // Get the index of the clicked pip
            const rankIndex = $(event.currentTarget).data('index');
            // Get current skill rank
            const currentRank = this.application.actor.system.skills[skillId].rank;
            // We want to increase or decrease based on the relative position of the clicked pip to the current rank
            const changeAmount = rankIndex + 1 - currentRank;
            // Set the skill rank to the clicked pip, clear the clicked pip, or clear all ranks on rightclick
            await this.application.actor.modifySkillRank(skillId, isLeftClick ? changeAmount : -999);
        }
        else {
            // Increment/Decrement the skill rank based on click type
            await this.application.actor.modifySkillRank(skillId, isLeftClick);
        }
    }
    /* --- Accessors --- */
    get readonly() {
        return this.params?.readonly === true;
    }
    get pips() {
        return this.params?.pips !== false;
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        // Get skill
        const skill = this.application.actor.system.skills[params.skill];
        // Get skill config
        const config = CONFIG.COSMERE.skills[params.skill];
        let maxSkillRank = 5;
        if (this.application.actor.type === "character" /* ActorType.Character */) {
            const actor = this.application.actor;
            maxSkillRank = actor.system.maxSkillRank;
        }
        // Get attribute config
        const attributeConfig = CONFIG.COSMERE.attributes[config.attribute];
        return Promise.resolve({
            ...context,
            skill: {
                ...skill,
                id: params.skill,
                label: config.label,
                attribute: config.attribute,
                attributeLabel: attributeConfig.labelShort,
            },
            editable: !this.readonly,
            pips: this.pips,
            maxSkillRank: maxSkillRank,
            legacyMode: getSystemSetting(SETTINGS.SHEET_SKILL_INCDEC_TOGGLE),
        });
    }
}
// Register the component
ActorSkillComponent.register('app-actor-skill');

const { ApplicationV2: ApplicationV2$5, HandlebarsApplicationMixin: HandlebarsApplicationMixin$2 } = foundry.applications.api;
class EditImmunitiesDialog extends HandlebarsApplicationMixin$2((ApplicationV2$5)) {
    actor;
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            title: 'COSMERE.Actor.Sheet.EditImmunities',
            minimizable: false,
            positioned: true,
        },
        classes: ['edit-immunities', 'dialog'],
        tag: 'dialog',
        position: {
            width: 300,
            height: 800,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ACTOR_EDIT_IMMUNITIES}`,
            // See note above
            /* eslint-disable @typescript-eslint/unbound-method */
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
            /* eslint-enable @typescript-eslint/unbound-method */
        },
    });
    constructor(actor) {
        super({
            id: `${actor.uuid}.immunities`,
        });
        this.actor = actor;
    }
    /* --- Statics --- */
    static async show(actor) {
        // Show the dialog
        await new EditImmunitiesDialog(actor).render(true);
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        event.preventDefault();
        const data = formData.object;
        const paths = Object.keys(data);
        const configuredImmunities = paths
            .filter((path) => typeof data[path] === 'boolean')
            .map((path) => {
            const [type, name] = path.split('.');
            return {
                type: type,
                label: this.getLabelForImmunity(type, name),
                isImmune: data[path],
            };
        })
            .filter((i) => i.isImmune)
            .partition((i) => i.type === "condition" /* ImmunityType.Condition */);
        // Get immunities
        const currentImmunities = this.actor.system.immunities;
        const immunityDiffersCheck = (action, name, currentValue, type) => {
            return action === 'add'
                ? // any immunities that aren't currently enabled but are found in the filtered input list
                    !currentValue &&
                        configuredImmunities[type === "damage" /* ImmunityType.Damage */ ? 0 : 1].findIndex((input) => input.label.toLowerCase() === name) > -1
                : // any immunities that are currently enabled but aren't found in the filtered input list
                    currentValue &&
                        configuredImmunities[type === "damage" /* ImmunityType.Damage */ ? 0 : 1].findIndex((input) => input.label.toLowerCase() === name) === -1;
        };
        // Figure out changes
        const damageRemovals = Object.entries(currentImmunities.damage).filter(([name, value]) => immunityDiffersCheck('remove', name, value, "damage" /* ImmunityType.Damage */));
        const damageAdditions = Object.entries(currentImmunities.damage).filter(([name, value]) => immunityDiffersCheck('add', name, value, "damage" /* ImmunityType.Damage */));
        const conditionRemovals = Object.entries(currentImmunities.condition).filter(([name, value]) => immunityDiffersCheck('remove', name, value, "condition" /* ImmunityType.Condition */));
        const conditionAdditions = Object.entries(currentImmunities.condition).filter(([name, value]) => immunityDiffersCheck('add', name, value, "condition" /* ImmunityType.Condition */));
        // Mutate current immunities
        damageRemovals.forEach(([name]) => (currentImmunities.damage[name] = false));
        damageAdditions.forEach(([name]) => (currentImmunities.damage[name] = true));
        conditionRemovals.forEach(([name]) => (currentImmunities.condition[name] = false));
        conditionAdditions.forEach(([name]) => (currentImmunities.condition[name] = true));
        // Update actor
        void this.actor.update({
            'system.immunities': currentImmunities,
        });
    }
    /* --- Context --- */
    _prepareContext() {
        // Get all configured immunity types
        const immunityTypes = Object.keys(CONFIG.COSMERE.immunityTypes);
        return Promise.resolve({
            actor: this.actor,
            categories: immunityTypes.map((type) => {
                const config = CONFIG.COSMERE.immunityTypes[type];
                return {
                    type,
                    label: config.label,
                    icon: config.icon,
                    configuredImmunities: this.getConfiguredImmunitiesForType(type),
                };
            }),
        });
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
        $(this.element)
            .find('input')
            .on('keypress', (event) => {
            if (event.which !== 13)
                return; // Enter key
            event.preventDefault();
            event.stopPropagation();
            $(event.target).trigger('blur');
        });
    }
    /* --- Helpers --- */
    getConfiguredImmunitiesForType(type) {
        if (type === "damage" /* ImmunityType.Damage */) {
            return Object.entries(CONFIG.COSMERE.damageTypes).map(([name, config]) => ({
                name,
                ...config,
                isImmune: this.actor.hasImmunity(type, name),
            }));
        }
        else if (type === "condition" /* ImmunityType.Condition */) {
            return Object.entries(CONFIG.COSMERE.statuses).map(([name, config]) => ({
                name,
                ...config,
                isImmune: this.actor.hasImmunity(type, name),
            }));
        }
        else {
            return [];
        }
    }
    getLabelForImmunity(type, name) {
        if (type === "damage" /* ImmunityType.Damage */) {
            return game.i18n.localize(Object.entries(CONFIG.COSMERE.damageTypes)?.find(([damageType]) => damageType === name)?.[1].label ?? '');
        }
        else if (type === "condition" /* ImmunityType.Condition */) {
            return game.i18n.localize(Object.entries(CONFIG.COSMERE.statuses)?.find(([conditionName]) => conditionName === name)?.[1].label ?? '');
        }
        else {
            return undefined;
        }
    }
}

class ActorImmunitiesComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_BASE_IMMUNITIES}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'edit-immunities': this.onEditImmunities,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    sectionCollapsed = false;
    /* --- Actions --- */
    static async onEditImmunities(event) {
        event.preventDefault();
        event.stopPropagation();
        await EditImmunitiesDialog.show(this.application.actor);
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        const immunities = [
            ...Object.entries(this.application.actor.system.immunities?.damage).map(([immunityName, value]) => ({
                name: immunityName,
                label: game.i18n?.localize(CONFIG.COSMERE.damageTypes[immunityName]
                    .label),
                isImmune: value,
                typeIcon: CONFIG.COSMERE.immunityTypes.damage.icon,
                typeLabel: game.i18n?.localize(CONFIG.COSMERE.immunityTypes.damage.label),
            })),
            ...Object.entries(this.application.actor.system.immunities?.condition).map(([immunityName, value]) => ({
                name: immunityName,
                label: game.i18n?.localize(CONFIG.COSMERE.statuses[immunityName].label),
                isImmune: value,
                typeIcon: CONFIG.COSMERE.immunityTypes.condition.icon,
                typeLabel: game.i18n?.localize(CONFIG.COSMERE.immunityTypes.condition.label),
            })),
        ];
        return Promise.resolve({
            ...context,
            sectionCollapsed: this.sectionCollapsed,
            immunities,
        });
    }
    /* --- Lifecycle --- */
    _onInitialize(params) {
        super._onInitialize(params);
        this.sectionCollapsed = this.application.areImmunitiesCollapsed;
    }
    _onRender(params) {
        super._onRender(params);
        $(this.element)
            .find('.collapsible .icon-header')
            .on('click', (event) => this.onClickCollapsible(event));
    }
    /* --- Event handlers --- */
    onClickCollapsible(event) {
        const target = event.currentTarget;
        target?.parentElement?.classList.toggle('expanded');
        this.sectionCollapsed = !this.sectionCollapsed;
        if (!this.application.isEditable)
            return;
        void this.application.actor.update({
            'flags.cosmere-rpg.sheet.immunitiesCollapsed': this.sectionCollapsed,
        }, { render: false });
    }
}
// Register
ActorImmunitiesComponent.register('app-actor-immunities');

class CharacterFavoritesComponent extends DragDropComponentMixin(HandlebarsApplicationComponent) {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_CHARACTER_FAVORITES}`;
    static DRAG_DROP = [
        {
            dropSelector: '*',
        },
    ];
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'use-item': this.onUseItem,
        'remove-favorite': this.onRemoveFavorite,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onUseItem(event) {
        // Get item
        const item = AppUtils.getItemFromEvent(event, this.application.actor);
        if (!item)
            return;
        // Use the item
        void this.application.actor.useItem(item);
    }
    static onRemoveFavorite(event) {
        // Get item
        const item = AppUtils.getItemFromEvent(event, this.application.actor);
        if (!item)
            return;
        // Remove favorite
        void item.clearFavorite();
    }
    /* --- Drag drop --- */
    _canDragDrop() {
        return this.application.isEditable;
    }
    _onDragOver(event) {
        if (!event.dataTransfer?.types.includes('document/item'))
            return;
        // Clean up
        $(this.element).find('.drop-area').removeClass('dropping');
        $(this.element).find('.drop-indicator').remove();
        if ($(event.target).closest('.drop-area').length) {
            $(event.target).closest('.drop-area').addClass('dropping');
        }
        else if ($(event.target).closest('.favorite.item').length) {
            const el = $(event.target)
                .closest('.favorite.item')
                .get(0);
            // Get bounding rect
            const bounds = el.getBoundingClientRect();
            if (event.clientY < bounds.top + bounds.height / 2) {
                $(el).before(`<li class="drop-indicator"></li>`);
            }
            else {
                $(el).after(`<li class="drop-indicator"></li>`);
            }
        }
    }
    async _onDrop(event) {
        const data = TextEditor.getDragEventData(event);
        // Ensure document type can be embedded on actor
        if (!(data.type in CosmereActor.metadata.embedded))
            return;
        // Get the document
        const document = fromUuidSync(data.uuid);
        if (!document)
            return;
        if (document.parent === this.application.actor) {
            // Document already on this actor
            if (data.type !== 'Item')
                return;
            const item = document;
            if ($(event.target).closest('.drop-area').length &&
                !item.isFavorite) {
                // Mark item as favorited
                void item.markFavorite(this.application.actor.favorites.length);
            }
            else if ($(event.target).closest('.favorite.item').length) {
                const el = $(event.target)
                    .closest('.favorite.item')
                    .get(0);
                // Get the index
                let index = $(event.target)
                    .closest('app-character-favorites')
                    .find('.favorite.item')
                    .toArray()
                    .indexOf(el);
                // Get bounding rect
                const bounds = el.getBoundingClientRect();
                // If item is dropped below the current element, move index over by 1
                if (event.clientY > bounds.top + bounds.height / 2) {
                    index++;
                }
                await Promise.all([
                    // Increase index of all subsequent favorites
                    ...this.application.actor.favorites
                        .slice(index)
                        .map((item, i) => item.markFavorite(index + i + 1, false)),
                    // Mark as favorite
                    item.markFavorite(index, false),
                ]);
                // Normalize
                this.application.actor.favorites.forEach((item, i) => void item.markFavorite(i, false));
                // Render
                void this.render();
            }
            // Clean up
            $(this.element)
                .find('app-character-favorites .drop-area')
                .removeClass('dropping');
            $(this.element)
                .find('app-character-favorites .drop-indicator')
                .remove();
        }
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            favorites: this.application.actor.favorites,
        });
    }
}
// Register
CharacterFavoritesComponent.register('app-character-favorites');

class CharacterPathsComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_CHARACTER_PATHS}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        remove: this.onRemove,
        view: this.onView,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onRemove(event) {
        const pathId = $(event.currentTarget)
            .closest('.path[data-id]')
            .data('id');
        // Find the path
        const pathItem = this.application.actor.items.get(pathId);
        // Remove the path
        void pathItem?.delete();
    }
    static onView(event) {
        const pathId = $(event.currentTarget)
            .closest('.path[data-id]')
            .data('id');
        // Find the path
        const pathItem = this.application.actor.items.get(pathId);
        // Open the path sheet
        void pathItem?.sheet?.render(true);
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        // Find all paths
        const pathItems = this.application.actor.items.filter((item) => item.isPath());
        return Promise.resolve({
            ...context,
            paths: pathItems.map((path) => ({
                ...path,
                id: path.id,
                img: path.img,
                typeLabel: CONFIG.COSMERE.paths.types[path.system.type].label,
                numTalents: path.system.relationships
                    .filter((rel) => rel.type === ItemRelationship.Type.Child)
                    .filter((rel) => rel.itemType === "talent" /* ItemType.Talent */).length,
                skills: path.system.linkedSkills
                    .filter((skillId) => this.application.actor.system.skills[skillId]
                    .unlocked === true)
                    .map((skillId) => ({
                    id: skillId,
                    label: CONFIG.COSMERE.skills[skillId].label,
                    attribute: CONFIG.COSMERE.skills[skillId].attribute,
                    attributeLabel: CONFIG.COSMERE.attributes[CONFIG.COSMERE.skills[skillId].attribute].label,
                    rank: this.application.actor.system.skills[skillId]
                        .rank,
                    mod: this.application.actor.system.skills[skillId].mod,
                })),
                level: this.application.actor.talents.filter((talent) => talent.pathId === path.id).length,
            })),
        });
    }
}
// Register
CharacterPathsComponent.register('app-character-paths-list');

// Component imports
class CharacterAncestryComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_CHARACTER_ANCESTRY}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        remove: this.onRemove,
        view: this.onView,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onRemove() {
        void this.ancestry?.delete();
    }
    static onView() {
        void this.ancestry?.sheet?.render(true);
    }
    /* --- Accessors --- */
    get ancestry() {
        return this.application.actor.ancestry;
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        const hasAncestry = !!this.ancestry;
        return Promise.resolve({
            ...context,
            hasAncestry,
            ...(hasAncestry
                ? {
                    ancestry: {
                        label: this.ancestry.name,
                        img: this.ancestry.img,
                        skills: this.ancestry.system.linkedSkills
                            .filter((skillId) => this.application.actor.system.skills[skillId].unlocked === true)
                            .map((skillId) => ({
                            id: skillId,
                            label: CONFIG.COSMERE.skills[skillId].label,
                            attribute: CONFIG.COSMERE.skills[skillId].attribute,
                            attributeLabel: CONFIG.COSMERE.attributes[CONFIG.COSMERE.skills[skillId]
                                .attribute].label,
                            rank: this.application.actor.system.skills[skillId].rank,
                            mod: this.application.actor.system.skills[skillId].mod,
                        })),
                    },
                }
                : {}),
        });
    }
}
// Register
CharacterAncestryComponent.register('app-character-ancestry');

const HIDE_COMPLETED_FLAG = 'goals.hide-completed';
class CharacterGoalsListComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_CHARACTER_GOALS_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'toggle-goal-controls': this.onToggleGoalControls,
        'adjust-goal-progress': {
            handler: this.onAdjustGoalProgress,
            buttons: [MouseButton.Primary, MouseButton.Secondary],
        },
        'toggle-hide-completed-goals': this.onToggleHideCompletedGoals,
        'edit-goal': this.onEditGoal,
        'remove-goal': this.onRemoveGoal,
        'add-goal': this.onAddGoal,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    contextGoalId = null;
    controlsDropdownExpanded = false;
    /* --- Actions --- */
    static onToggleGoalControls(event) {
        // Get goal id
        const goalId = $(event.currentTarget)
            .closest('[data-id]')
            .data('id');
        const target = event.currentTarget;
        const root = $(target).closest('.tab-body');
        const dropdown = $(target)
            .closest('.item-list')
            .siblings('.controls-dropdown');
        const targetRect = target.getBoundingClientRect();
        const rootRect = root[0].getBoundingClientRect();
        if (this.contextGoalId !== goalId) {
            dropdown.css({
                top: `${Math.round(targetRect.top - rootRect.top)}px`,
                right: `${Math.round(rootRect.right - targetRect.right + targetRect.width)}px`,
            });
            if (!this.controlsDropdownExpanded) {
                dropdown.addClass('expanded');
                this.controlsDropdownExpanded = true;
            }
            this.contextGoalId = goalId;
        }
        else if (this.controlsDropdownExpanded) {
            dropdown.removeClass('expanded');
            this.controlsDropdownExpanded = false;
            this.contextGoalId = null;
        }
    }
    static async onAdjustGoalProgress(event) {
        if (!this.application.isEditable)
            return;
        const incrementBool = event.type === 'click' ? true : false;
        // Get goal id
        const goalId = $(event.currentTarget)
            .closest('[data-id]')
            .data('id');
        if (!goalId)
            return;
        // Get the goal
        const goalItem = this.application.actor.items.get(goalId);
        if (!goalItem?.isGoal())
            return;
        // Get the goal's current level
        const currentLevel = goalItem.system.level;
        // Calculate the new level
        const newLevel = incrementBool
            ? Math.min(currentLevel + 1, 3)
            : Math.max(currentLevel - 1, 0);
        // Update the goal
        await goalItem.update({
            'system.level': newLevel,
        });
        // Render
        await this.render();
    }
    static async onToggleHideCompletedGoals() {
        // Get current state
        const hideCompletedGoals = this.application.actor.getFlag(SYSTEM_ID, HIDE_COMPLETED_FLAG) ?? false;
        // Update
        await this.application.actor.update({
            [`flags.cosmere-rpg.${HIDE_COMPLETED_FLAG}`]: !hideCompletedGoals,
        }, { render: false });
        // Close controls dropdown if it happens to be open
        this.controlsDropdownExpanded = false;
        // Render
        await this.render();
    }
    static async onEditGoal() {
        this.controlsDropdownExpanded = false;
        // Render
        await this.render();
        // Ensure context goal id is set
        if (this.contextGoalId !== null) {
            // Get the goal
            const goalItem = this.application.actor.items.get(this.contextGoalId);
            if (!goalItem?.isGoal())
                return;
            // Show item sheet
            void goalItem.sheet?.render(true);
            this.contextGoalId = null;
        }
    }
    static async onRemoveGoal() {
        this.controlsDropdownExpanded = false;
        // Ensure context goal id is set
        if (this.contextGoalId !== null) {
            // Get the goal
            const goalItem = this.application.actor.items.get(this.contextGoalId);
            if (!goalItem?.isGoal())
                return;
            // Delete the goal
            await goalItem.delete();
            this.contextGoalId = null;
        }
    }
    static async onAddGoal() {
        // Ensure controls dropdown is closed
        this.controlsDropdownExpanded = false;
        // Create goal
        const goal = (await Item.create({
            type: "goal" /* ItemType.Goal */,
            name: game.i18n.localize('COSMERE.Actor.Sheet.Details.Goals.NewText'),
            system: {
                level: 0,
            },
        }, { parent: this.application.actor }));
        setTimeout(() => {
            // Edit the goal
            this.editGoal(goal.id);
        }, 50);
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        const hideCompletedGoals = this.application.actor.getFlag(SYSTEM_ID, HIDE_COMPLETED_FLAG) ?? false;
        return Promise.resolve({
            ...context,
            goals: this.application.actor.goals
                .map((goal) => ({
                id: goal.id,
                name: goal.name,
                level: goal.system.level,
                achieved: goal.system.level === 3,
            }))
                .filter((goal) => !hideCompletedGoals || !goal.achieved),
            hideCompletedGoals,
        });
    }
    /* --- Helpers --- */
    editGoal(id) {
        // Get goal element
        const element = $(this.element).find(`.item[data-id="${id}"]`);
        // Get input element
        const input = element.find('input.name');
        // Set not readonly
        input.prop('readonly', false);
        setTimeout(() => {
            // Focus input
            input.trigger('select');
            // Add event handler
            input.on('focusout', async () => {
                // Remove handler
                input.off('focusout');
                // Get the goal
                const goal = this.application.actor.items.get(id);
                // Update the connection
                await goal.update({
                    name: input.val(),
                });
                // Render
                void this.render();
            });
            input.on('keypress', (event) => {
                if (event.which !== 13)
                    return; // Enter key
                event.preventDefault();
                event.stopPropagation();
                input.trigger('focusout');
            });
        });
    }
}
// Register
CharacterGoalsListComponent.register('app-character-goals-list');

class CharacterConnectionsListComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_CHARACTER_CONNECTIONS_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'toggle-connection-controls': this.onToggleConnectionControls,
        'add-connection': this.onAddConnection,
        'remove-connection': this.onRemoveConnection,
        'edit-connection': this.onEditConnection,
        'toggle-expand-connection': this.onToggleExpandConnection,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    connectionItemStates = {};
    contextConnectionId = null;
    controlsDropdownExpanded = false;
    /* --- Connections --- */
    static onToggleConnectionControls(event) {
        // Get connection id
        const connectionId = $(event.currentTarget)
            .closest('[data-id]')
            .data('id');
        const target = event.currentTarget;
        const root = $(target).closest('.tab-body');
        const dropdown = $(target)
            .closest('.item-list')
            .siblings('.controls-dropdown');
        const targetRect = target.getBoundingClientRect();
        const rootRect = root[0].getBoundingClientRect();
        if (this.contextConnectionId !== connectionId) {
            dropdown.css({
                top: `${Math.round(targetRect.top - rootRect.top)}px`,
                right: `${Math.round(rootRect.right - targetRect.right + targetRect.width)}px`,
            });
            if (!this.controlsDropdownExpanded) {
                dropdown.addClass('expanded');
                this.controlsDropdownExpanded = true;
            }
            this.contextConnectionId = connectionId;
        }
        else if (this.controlsDropdownExpanded) {
            dropdown.removeClass('expanded');
            this.controlsDropdownExpanded = false;
            this.contextConnectionId = null;
        }
    }
    static async onAddConnection() {
        // Create connection
        const [{ id }] = await this.application.actor.createEmbeddedDocuments('Item', [
            {
                type: "connection" /* ItemType.Connection */,
                name: game.i18n.localize('COSMERE.Actor.Sheet.Details.Connections.NewText'),
            },
        ], {
            render: false,
        });
        // Render
        await this.render();
        setTimeout(() => {
            // Edit the connection
            this.editConnection(id);
        }, 50);
    }
    static async onRemoveConnection() {
        this.controlsDropdownExpanded = false;
        // Ensure context goal id is set
        if (this.contextConnectionId !== null) {
            // Remove the connection
            await this.application.actor.deleteEmbeddedDocuments('Item', [this.contextConnectionId], { render: false });
            this.contextConnectionId = null;
        }
        // Render
        await this.render();
    }
    static onEditConnection() {
        this.controlsDropdownExpanded = false;
        // Ensure context goal id is set
        if (this.contextConnectionId !== null) {
            // Get the connection
            const connection = this.application.actor.items.find((i) => i.id === this.contextConnectionId);
            // Show connection sheet
            void connection.sheet?.render(true);
            this.contextConnectionId = null;
        }
        // Render
        void this.render();
    }
    static onToggleExpandConnection(event) {
        // Get connection element
        const connectionElement = $(event.target).closest('.item[data-id]');
        // Get connection id
        const connectionId = connectionElement.data('id');
        // Toggle expanded state
        this.connectionItemStates[connectionId].expanded =
            !this.connectionItemStates[connectionId].expanded;
        connectionElement.toggleClass('expanded', this.connectionItemStates[connectionId].expanded);
        connectionElement
            .find('a[data-action="toggle-expand-connection"')
            .empty()
            .append(this.connectionItemStates[connectionId].expanded
            ? '<i class="fa-solid fa-compress"></i>'
            : '<i class="fa-solid fa-expand"></i>');
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        // Get connections
        const connections = this.application.actor.items.filter((item) => item.isConnection());
        // Ensure item state exists for each connection
        connections.forEach((item) => {
            if (!(item.id in this.connectionItemStates)) {
                this.connectionItemStates[item.id] = {};
            }
        });
        return {
            ...context,
            connections: await Promise.all(connections.map(async (item) => ({
                ...item,
                ...this.connectionItemStates[item.id],
                id: item.id,
                descriptionHTML: await TextEditor.enrichHTML(
                // NOTE: We use a logical OR here to catch both nullish values and empty string
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                item.system.description?.value || '<p>—</p>', {
                    relativeTo: item.system
                        .parent,
                }),
            }))),
        };
    }
    /* --- Helpers --- */
    editConnection(id) {
        // Get goal element
        const element = $(this.element).find(`.item[data-id="${id}"]`);
        // Get input element
        const input = element.find('input.name');
        // Set not readonly
        input.prop('readonly', false);
        setTimeout(() => {
            // Focus input
            input.trigger('select');
            // Add event handler
            input.on('focusout', async () => {
                // Remove handler
                input.off('focusout');
                // Get the connection
                const connection = this.application.actor.items.find((i) => i.id === id);
                // Update the connection
                await connection.update({
                    name: input.val(),
                });
                // Render
                void this.render();
            });
            input.on('keypress', (event) => {
                if (event.which !== 13)
                    return; // Enter key
                event.preventDefault();
                event.stopPropagation();
                input.trigger('focusout');
            });
        });
    }
}
// Register
CharacterConnectionsListComponent.register('app-character-connections-list');

class CharacterCultureComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_CHARACTER_CULTURE}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        remove: this.onRemove,
        view: this.onView,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onRemove() {
        void this.params.culture.delete();
    }
    static onView() {
        void this.params.culture.sheet?.render(true);
    }
    /* --- Accessors --- */
    get item() {
        return this.params.culture;
    }
    get culture() {
        return this.params.culture;
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            culture: {
                label: this.culture.name,
                img: this.culture.img,
            },
            skills: this.culture.hasLinkedSkills()
                ? this.culture.system.linkedSkills
                    .filter((skillId) => this.application.actor.system.skills[skillId]
                    .unlocked === true)
                    .map((skillId) => ({
                    id: skillId,
                    label: CONFIG.COSMERE.skills[skillId].label,
                    attribute: CONFIG.COSMERE.skills[skillId].attribute,
                    attributeLabel: CONFIG.COSMERE.attributes[CONFIG.COSMERE.skills[skillId].attribute].label,
                    rank: this.application.actor.system.skills[skillId]
                        .rank,
                    mod: this.application.actor.system.skills[skillId]
                        .mod,
                }))
                : [],
        });
    }
}
// Register the component
CharacterCultureComponent.register('app-character-culture');

// Component imports
class CharacterSkillLinkedItemComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_CHARACTER_SKILL_LINKED_ITEM}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        view: this.onView,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onView(event) {
        void this.item.sheet?.render(true);
    }
    /* --- Accessors --- */
    get item() {
        return this.params.item;
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            item: this.item,
            id: this.item.id,
            img: this.item.img,
            typeLabel: this.item.isTyped() ? this.item.system.typeLabel : null,
            skills: this.item.hasLinkedSkills()
                ? this.item.system.linkedSkills
                    .filter((skillId) => this.application.actor.system.skills[skillId]
                    .unlocked === true)
                    .map((skillId) => ({
                    id: skillId,
                    label: CONFIG.COSMERE.skills[skillId].label,
                    attribute: CONFIG.COSMERE.skills[skillId].attribute,
                    attributeLabel: CONFIG.COSMERE.attributes[CONFIG.COSMERE.skills[skillId].attribute].label,
                    rank: this.application.actor.system.skills[skillId]
                        .rank,
                    mod: this.application.actor.system.skills[skillId]
                        .mod,
                }))
                : [],
        });
    }
}
// Register the component
CharacterSkillLinkedItemComponent.register('app-character-skill-linked-item');

// Documents
// Constants
class AdversaryActionsListComponent extends ActorActionsListComponent {
    /* --- Context --- */
    async _prepareContext(params, context) {
        // Get all activatable items (actions & items with an associated action)
        const activatableItems = this.application.actor.items
            .filter((item) => item.hasActivation())
            .filter((item) => !item.isEquippable() ||
            item.system.equipped ||
            item.system.alwaysEquipped);
        // Ensure all items have an expand state record
        activatableItems.forEach((item) => {
            if (!(item.id in this.itemState)) {
                this.itemState[item.id] = {
                    expanded: false,
                };
            }
        });
        // Prepare sections
        this.sections = [
            this.prepareSection("trait" /* ItemType.Trait */),
            this.prepareSection("weapon" /* ItemType.Weapon */),
            this.prepareSection("action" /* ItemType.Action */),
        ];
        const searchText = context.actionsSearch?.text ?? '';
        const sortMode = context.actionsSearch?.sort ?? "alphabetic" /* SortMode.Alphabetic */;
        return {
            ...context,
            sections: [
                await this.prepareSectionData(this.sections[0], activatableItems, searchText, sortMode),
                await this.prepareSectionData(this.sections[1], activatableItems, searchText, sortMode),
                await this.prepareSectionData(this.sections[2], activatableItems, searchText, sortMode),
            ].filter((section) => section.items.length > 0 ||
                (this.application.mode === 'edit' && section.default)),
            itemState: this.itemState,
        };
    }
    /* --- Helpers --- */
    prepareSection(type) {
        return {
            id: type,
            label: CONFIG.COSMERE.items.types[type].labelPlural,
            default: true,
            filter: (item) => item.type === type,
            new: (parent) => CosmereItem.create({
                type,
                name: game.i18n.localize(`COSMERE.Item.Type.${type.capitalize()}.New`),
                system: {
                    activation: {
                        type: "utility" /* ActivationType.Utility */,
                        cost: {
                            type: "act" /* ActionCostType.Action */,
                            value: 1,
                        },
                    },
                    ...(type === "weapon" /* ItemType.Weapon */
                        ? {
                            equipped: true,
                        }
                        : {}),
                },
            }, { parent }),
        };
    }
    async prepareSectionData(section, items, searchText, sort) {
        // Get items for section, filter by search text, and sort
        let sectionItems = items
            .filter(section.filter)
            .filter((i) => i.name.toLowerCase().includes(searchText));
        if (sort === "alphabetic" /* SortMode.Alphabetic */) {
            sectionItems = sectionItems.sort((a, b) => a.name.compare(b.name) * -1);
        }
        return {
            ...section,
            canAddNewItems: !!section.new,
            items: sectionItems,
            itemData: await this.prepareItemData(sectionItems),
        };
    }
}
// Register
AdversaryActionsListComponent.register('app-adversary-actions-list');

const { ApplicationV2: ApplicationV2$4, HandlebarsApplicationMixin: HandlebarsApplicationMixin$1 } = foundry.applications.api;
class EditCreatureTypeDialog extends HandlebarsApplicationMixin$1((ApplicationV2$4)) {
    actor;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            title: 'COSMERE.Actor.Sheet.EditType',
            minimizable: false,
            positioned: true,
        },
        classes: ['dialog', 'edit-creature-type'],
        tag: 'dialog',
        position: {
            width: 350,
        },
        actions: {
            'update-type': this.onUpdateType,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ADVERSARY_EDIT_CREATURE_TYPE}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    type;
    constructor(actor) {
        super({
            id: `${actor.uuid}.type`,
        });
        this.actor = actor;
        this.type = actor.system.type;
    }
    /* --- Statics --- */
    static async show(actor) {
        await new EditCreatureTypeDialog(actor).render(true);
    }
    /* --- Actions --- */
    static onUpdateType() {
        void this.actor.update({
            'system.type': this.type,
        });
        void this.close();
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        const target = event.target;
        if (formData.object.custom && target.name !== 'primaryType') {
            this.type.id = "custom" /* CreatureType.Custom */;
            this.type.custom = formData.object.custom;
        }
        else {
            this.type.id = formData.object.primaryType;
            this.type.custom = null;
        }
        this.type.subtype = formData.object.subtype;
        // Render
        void this.render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    /* --- Context --- */
    _prepareContext() {
        // Get list of all configured types
        const configuredTypes = Object.entries(CONFIG.COSMERE.creatureTypes).map(([id, config]) => ({
            id,
            ...config,
            selected: this.type.id === id,
        }));
        return Promise.resolve({
            actor: this.actor,
            type: this.type,
            typeLabel: getTypeLabel(this.type),
            configuredTypes,
        });
    }
}

class AdversaryHeaderComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_ADVERSARY_HEADER}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.ACTIONS), {
        'edit-type': this.onEditType,
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onEditType() {
        void EditCreatureTypeDialog.show(this.application.actor);
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            roles: Object.entries(CONFIG.COSMERE.adversary.roles).reduce((roles, [id, config]) => ({
                ...roles,
                [id]: config.label,
            }), {}),
            sizes: Object.entries(CONFIG.COSMERE.sizes).reduce((sizes, [id, config]) => ({
                ...sizes,
                [id]: config.label,
            }), {}),
            roleLabel: CONFIG.COSMERE.adversary.roles[context.actor.system.role].label,
            sizeLabel: CONFIG.COSMERE.sizes[context.actor.system.size].label,
            typeLabel: getTypeLabel(context.actor.system.type),
        });
    }
}
// Register
AdversaryHeaderComponent.register('app-adversary-header');

const { ApplicationV2: ApplicationV2$3 } = foundry.applications.api;
class ConfigureSkillsDialog extends ComponentHandlebarsApplicationMixin((ApplicationV2$3)) {
    actor;
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            title: 'COSMERE.Actor.Sheet.ConfigureSkills',
            minimizable: false,
            positioned: true,
        },
        classes: ['dialog', 'configure-skills'],
        tag: 'dialog',
        position: {
            width: 300,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ADVERSARY_CONFIGURE_SKILLS}`,
        },
    });
    constructor(actor) {
        super({
            id: `${actor.uuid}.skills`,
        });
        this.actor = actor;
    }
    /* --- Statics --- */
    static async show(actor) {
        await new ConfigureSkillsDialog(actor).render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    _onFirstRender(context, options) {
        super._onFirstRender(context, options);
        this.actor.apps[this.id] = this;
    }
    _onClose(options) {
        super._onClose(options);
        if (this.id in this.actor.apps) {
            delete this.actor.apps[this.id];
        }
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            actor: this.actor,
            attributeGroups: Object.keys(CONFIG.COSMERE.attributeGroups),
            isEditMode: true,
        });
    }
}

class AdversarySkillsComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_ADVERSARY_SKILLS}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'roll-skill': this.onRollSkill,
        'toggle-hide-unranked': this.onToggleHideUnranked,
        'configure-skills': this.onConfigureSkills,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    sectionCollapsed = false;
    /* --- Actions --- */
    static onRollSkill(event) {
        event.preventDefault();
        event.stopPropagation();
        const skillId = $(event.currentTarget)
            .closest('[data-id]')
            .data('id');
        void this.application.actor.rollSkill(skillId);
    }
    static onToggleHideUnranked(event) {
        event.preventDefault();
        event.stopPropagation();
        // Update the flag
        void this.application.actor.setFlag(SYSTEM_ID, 'sheet.hideUnranked', !this.application.hideUnrankedSkills);
    }
    static onConfigureSkills(event) {
        event.preventDefault();
        event.stopPropagation();
        void ConfigureSkillsDialog.show(this.application.actor);
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        // Get the skill ids
        const skillIds = Object.keys(CONFIG.COSMERE.skills).sort((a, b) => a.localeCompare(b)); // Sort alphabetically
        // Get skills
        const skills = skillIds
            .map((skillId) => {
            const skillConfig = CONFIG.COSMERE.skills[skillId];
            return {
                id: skillId,
                config: skillConfig,
                attributeLabel: CONFIG.COSMERE.attributes[skillConfig.attribute].label,
                ...this.application.actor.system.skills[skillId],
                active: (!skillConfig.hiddenUntilAcquired &&
                    !this.application.hideUnrankedSkills) ||
                    this.application.actor.system.skills[skillId].rank >= 1,
            };
        })
            .sort((a, b) => {
            const _a = a.config.hiddenUntilAcquired ? 1 : 0;
            const _b = b.config.hiddenUntilAcquired ? 1 : 0;
            return _a - _b;
        });
        return Promise.resolve({
            ...context,
            sectionCollapsed: this.sectionCollapsed,
            hideUnranked: this.application.hideUnrankedSkills,
            skills,
            hasActiveSkills: skills.some((skill) => skill.active),
        });
    }
    /* --- Lifecycle --- */
    _onInitialize(params) {
        super._onInitialize(params);
        this.sectionCollapsed = this.application.areSkillsCollapsed;
    }
    _onRender(params) {
        super._onRender(params);
        $(this.element)
            .find('.collapsible .icon-header')
            .on('click', (event) => this.onClickCollapsible(event));
    }
    /* --- Event handlers --- */
    onClickCollapsible(event) {
        const target = event.currentTarget;
        target?.parentElement?.classList.toggle('expanded');
        this.sectionCollapsed = !this.sectionCollapsed;
        if (!this.application.isEditable)
            return;
        void this.application.actor.update({
            'flags.cosmere-rpg.sheet.skillsCollapsed': this.sectionCollapsed,
        }, { render: false });
    }
}
// Register
AdversarySkillsComponent.register('app-adversary-skills');

class AdversarySheet extends BaseActorSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'actor', 'adversary'],
        position: {
            width: 850,
            height: 850,
        },
        dragDrop: [
            {
                dropSelector: '*',
            },
        ],
        actions: {},
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_ADVERSARY_CONTENT}`,
        },
    });
    get actor() {
        return super.document;
    }
    get areSkillsCollapsed() {
        return this.actor.getFlag(SYSTEM_ID, 'sheet.skillsCollapsed') ?? false;
    }
    get hideUnrankedSkills() {
        return this.actor.getFlag(SYSTEM_ID, 'sheet.hideUnranked') ?? false;
    }
    /* --- Event handlers --- */
    onActionsSearchChange(event) {
        this.actionsSearchText = event.detail.text;
        this.actionsSearchSort = event.detail.sort;
        void this.render({
            parts: [],
            components: ['app-adversary-actions-list'],
        });
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
            skillsCollapsed: this.areSkillsCollapsed,
            hideUnrankedSkills: this.hideUnrankedSkills,
        };
    }
}

class CharacterSheet extends BaseActorSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'actor', 'character'],
        position: {
            width: 850,
            height: 1000,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        header: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_CHARACTER_HEADER}`,
        },
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ACTOR_CHARACTER_CONTENT}`,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        ["details" /* CharacterSheetTab.Details */]: {
            label: 'COSMERE.Actor.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-feather-pointed"></i>',
            sortIndex: 0,
        },
        ["goals" /* CharacterSheetTab.Goals */]: {
            label: 'COSMERE.Actor.Sheet.Tabs.Goals',
            icon: '<i class="fa-solid fa-list"></i>',
            sortIndex: 25,
        },
    });
    get actor() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        // Find the ancestry
        const ancestryItem = this.actor.items.find((item) => item.type === "ancestry" /* ItemType.Ancestry */);
        // Find all paths
        const pathItems = this.actor.items.filter((item) => item.isPath());
        // Split paths by type
        const pathTypes = pathItems
            .map((item) => item.system.type)
            .filter((v, i, self) => self.indexOf(v) === i); // Filter out duplicates
        return {
            ...(await super._prepareContext(options)),
            pathTypes: pathTypes.map((type) => ({
                type,
                typeLabel: CONFIG.COSMERE.paths.types[type].label,
                paths: pathItems.filter((i) => i.system.type === type),
            })),
            ancestryLabel: ancestryItem?.name ??
                game.i18n?.localize('COSMERE.Item.Type.Ancestry.label'),
        };
    }
}

function configure() {
    configure$1();
}

class ItemHeaderComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_BASE_HEADER}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'edit-img': this.onEditImg,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static onEditImg() {
        if (!this.application.isEditable)
            return;
        const { img: defaultImg } = CosmereItem.getDefaultArtwork(this.application.item.toObject());
        void new FilePicker({
            current: this.application.item.img,
            type: 'image',
            redirectToRoot: [defaultImg],
            top: this.application.position.top + 40,
            left: this.application.position.left + 10,
            callback: (path) => {
                void this.application.item.update({
                    img: path,
                });
            },
        }).browse();
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            typeLabel: CONFIG.COSMERE.items.types[this.application.item.type].label,
        });
    }
}
// Register the component
ItemHeaderComponent.register('app-item-header');

// Constants
const TITLE_MAP = {
    inactive: 'COSMERE.Sheet.Effects.Inactive',
    passive: 'COSMERE.Sheet.Effects.Passive',
    temporary: 'COSMERE.Sheet.Effects.Temporary',
};
class ItemEffectsListComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_EFFECTS_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'create-effect': this.onCreateEffect,
        'toggle-effect-active': this.onToggleEffectActive,
        'edit-effect': this.onEditEffect,
        'delete-effect': this.onDeleteEffect,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static async onCreateEffect() {
        // Create effect
        const effect = (await ActiveEffect.create({
            name: this.application.item.name,
            img: this.application.item.img,
            disabled: this.params.type === 'inactive',
            duration: this.params.type === 'temporary'
                ? { rounds: 1 }
                : undefined,
        }, { parent: this.application.item }));
        // Show effect sheet
        await effect.sheet.render(true);
    }
    static async onToggleEffectActive(event) {
        const effect = this.getEffectFromEvent(event);
        if (!effect)
            return;
        // Toggle active
        await effect.update({
            disabled: !effect.disabled,
        });
    }
    static onEditEffect(event) {
        const effect = this.getEffectFromEvent(event);
        if (!effect)
            return;
        // Show effect sheet
        void effect.sheet.render(true);
    }
    static async onDeleteEffect(event) {
        const effect = this.getEffectFromEvent(event);
        if (!effect)
            return;
        // Delete effect
        await effect.delete();
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        const effects = this.application.item.effects.filter((effect) => {
            switch (params.type) {
                case 'inactive':
                    return !effect.active;
                case 'passive':
                    return effect.active && !effect.isTemporary;
                case 'temporary':
                    return effect.active && effect.isTemporary;
            }
        });
        return Promise.resolve({
            ...context,
            effects,
            title: TITLE_MAP[params.type],
        });
    }
    /* --- Helpers --- */
    getEffectFromEvent(event) {
        if (!event.target && !event.currentTarget)
            return;
        return this.getEffectFromElement((event.target ?? event.currentTarget));
    }
    getEffectFromElement(element) {
        const effectElement = $(element).closest('.effect[data-id]');
        // Get the id
        const id = effectElement.data('id');
        // Get the effect
        return this.application.item.effects.get(id);
    }
}
// Register the component
ItemEffectsListComponent.register('app-item-effects-list');

// Component imports
const { ApplicationV2: ApplicationV2$2 } = foundry.applications.api;
class ItemEditEventRuleDialog extends ComponentHandlebarsApplicationMixin((ApplicationV2$2)) {
    item;
    rule;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            title: 'DIALOG.EditEventRule.Title',
            minimizable: false,
            resizable: false,
            positioned: true,
        },
        classes: ['dialog', 'edit-event-rule'],
        tag: 'dialog',
        position: {
            width: 500,
        },
        actions: {
            update: this.onUpdateRule,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.DIALOG_ITEM_EDIT_EVENT_RULE}`,
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    constructor(item, rule) {
        super({
            id: `${item.uuid}.Events.${rule.id}`,
        });
        this.item = item;
        this.rule = rule;
    }
    /* --- Statics --- */
    static async show(item, rule) {
        const dialog = new this(item, rule.clone());
        await dialog.render(true);
    }
    /* --- Actions --- */
    static onUpdateRule() {
        // Get changes
        const changes = foundry.utils.mergeObject(getObjectChanges(this.item.system.events.get(this.rule.id).toObject(), this.rule.toObject()), {
            /**
             * NOTE: We have to always include the handler type in the changes
             * otherwise the handler field cannot determine which schema to use
             * for validation.
             */
            'handler.type': this.rule.handler.type,
        });
        void this.item.update({
            [`system.events.${this.rule.id}`]: changes,
        });
        void this.close();
    }
    /* --- Form --- */
    static onFormEvent(event, form, formData) {
        event.preventDefault();
        // Ignore submit events
        if (event instanceof SubmitEvent)
            return;
        // Prepare changes
        const changes = Object.entries(formData.object).reduce((changes, [key, value]) => {
            if (foundry.utils.getType(value) === 'Object') {
                changes[key] = getObjectChanges(foundry.utils.getProperty(this.rule, key), value);
            }
            else {
                changes[key] = value;
            }
            return changes;
        }, {});
        // Update the rule with the form data
        this.rule.updateSource(changes, { fallback: true });
        // Render
        void this.render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    async _preRender(context, options) {
        await super._preRender(context, options);
        // Handle handler config rendering
        const handlerConfigHtml = await this.rule.handler.configRenderer?.({
            ...context,
            event: this.rule.event,
            handler: this.rule.handler,
            // Emulate component system
            __application: this,
            partId: 'form',
        });
        context.shouldAutoPopulateConfigFields = !handlerConfigHtml;
        context.handlerConfigHtml = handlerConfigHtml;
    }
    /* --- Context --- */
    _prepareContext() {
        const allEventSelectOptions = this.rule.schema.fields.event
            .choices();
        // Prepare the context
        return Promise.resolve({
            editable: true,
            item: this.item,
            rule: this.rule,
            eventSelectOptions: Object.entries(allEventSelectOptions)
                .filter(([event]) => CONFIG.COSMERE.items.events.types[event]?.filter?.(this.item) !== false)
                .reduce((acc, [event, label]) => ({
                ...acc,
                [event]: label,
            }), {}),
        });
    }
}

// Dialogs
class ItemEventRulesListComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_EVENT_RULES_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'create-rule': this.onCreateRule,
        'edit-rule': this.onEditRule,
        'delete-rule': this.onDeleteRule,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Accessors --- */
    get item() {
        return this.application.item;
    }
    /* --- Actions --- */
    static async onCreateRule() {
        // Generate id
        const id = foundry.utils.randomID();
        // Create the rule
        await this.item.update({
            [`system.events.${id}`]: {
                id,
                description: game.i18n.localize('COSMERE.Item.EventSystem.Event.Rule.NewRuleDescription'),
                event: 'none',
                handler: {
                    type: 'none',
                },
            },
        });
        // Get the rule
        const rule = this.item.system.events.get(id);
        // Show the edit dialog
        void ItemEditEventRuleDialog.show(this.item, rule);
    }
    static onEditRule(event) {
        // Get id
        const id = $(event.target).closest('.rule[data-id]').data('id');
        if (!id)
            return;
        // Get the rule
        const rule = this.item.system.events.get(id);
        if (!rule)
            return;
        // Show the edit dialog
        void ItemEditEventRuleDialog.show(this.item, rule);
    }
    static onDeleteRule(event) {
        // Get id
        const id = $(event.target).closest('.rule[data-id]').data('id');
        if (!id)
            return;
        // Delete the rule
        void this.item.update({
            [`system.events.-=${id}`]: {},
        });
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        const rules = Array.from(this.item.system.events).sort((a, b) => a.order - b.order);
        return Promise.resolve({
            ...context,
            rules,
        });
    }
}
// Register the component
ItemEventRulesListComponent.register('app-item-event-rules-list');

class DetailsIdComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_DETAILS_ID}`;
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            hasId: this.application.item.hasId(),
        });
    }
}
// Register the component
DetailsIdComponent.register('app-item-details-id');

class DetailsTypeComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_DETAILS_TYPE}`;
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            isTyped: this.application.item.isTyped(),
        });
    }
}
// Register the component
DetailsTypeComponent.register('app-item-details-type');

class DetailsEquipComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_DETAILS_EQUIP}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'toggle-traits-collapsed': DetailsEquipComponent.onToggleTraitsCollapsed,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    normalTraitsCollapsed = true;
    expertTraitsCollapsed = true;
    /* --- Actions --- */
    static onToggleTraitsCollapsed(event) {
        const target = event.currentTarget;
        switch (target.dataset.trait) {
            case 'normal':
                this.normalTraitsCollapsed = !this.normalTraitsCollapsed;
                break;
            case 'expert':
                this.expertTraitsCollapsed = !this.expertTraitsCollapsed;
                break;
        }
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        const isEquippable = this.application.item.isEquippable();
        if (!isEquippable) {
            return Promise.resolve({
                ...context,
                isEquippable,
            });
        }
        return Promise.resolve({
            ...context,
            isEquippable,
            equipTypes: Object.entries(CONFIG.COSMERE.items.equip.types).reduce((acc, [key, type]) => ({
                ...acc,
                [key]: type.label,
            }), {}),
            holdTypeLabel: this.application.item.system.equip.hold
                ? CONFIG.COSMERE.items.equip.hold[this.application.item.system.equip.hold].label
                : '—',
            normalTraitsCollapsed: this.normalTraitsCollapsed,
            expertTraitsCollapsed: this.expertTraitsCollapsed,
            normalTraits: this.prepareTraitsData(false),
            expertTraits: this.prepareTraitsData(true),
            normalTraitsString: this.prepareNormalTraitsString(),
            expertTraitsString: this.prepareExpertTraitsString(),
        });
    }
    prepareTraitsData(expert) {
        const item = this.application.item;
        if (!item.isArmor() && !item.isWeapon())
            return null;
        const isArmor = item.isArmor();
        return Object.entries(isArmor
            ? CONFIG.COSMERE.traits.armorTraits
            : CONFIG.COSMERE.traits.weaponTraits)
            .map(([id, config]) => {
            // Look up trait
            const traitData = isArmor
                ? item.system.traits[id]
                : item.system.traits[id];
            if (!expert) {
                return {
                    id,
                    label: config.label,
                    hasValue: config.hasValue ?? false,
                    active: traitData?.defaultActive,
                    value: traitData?.defaultValue,
                };
            }
            if (traitData?.defaultActive) {
                return [
                    ...(config.hasValue
                        ? [
                            {
                                id,
                                type: 'modify-trait-value',
                                label: game
                                    .i18n.localize('COSMERE.Item.Sheet.Equip.ModifyTraitValue')
                                    .replace('[trait]', game.i18n.localize(config.label))
                                    .replace('[value]', (traitData.defaultValue ?? 0).toString()),
                                value: traitData.expertise.value ??
                                    traitData.defaultValue,
                                active: !!traitData.expertise.value,
                            },
                        ]
                        : []),
                    {
                        id,
                        type: 'lose-trait',
                        label: game
                            .i18n.localize('COSMERE.Item.Sheet.Equip.LoseTrait')
                            .replace('[trait]', game.i18n.localize(config.label)),
                        active: traitData.expertise.toggleActive,
                    },
                ];
            }
            else {
                return [
                    {
                        id,
                        type: 'gain-trait',
                        label: config.label,
                        active: traitData?.expertise.toggleActive,
                        value: traitData?.defaultValue,
                    },
                ];
            }
        })
            .flat();
    }
    prepareNormalTraitsString() {
        const item = this.application.item;
        if (!item.hasTraits())
            return null;
        const isArmor = item.isArmor();
        return item.system.traitsArray
            .filter((trait) => trait.defaultActive)
            .map((trait) => {
            const config = isArmor
                ? CONFIG.COSMERE.traits.armorTraits[trait.id]
                : CONFIG.COSMERE.traits.weaponTraits[trait.id];
            return game.i18n.localize(config.label);
        })
            .join(', ');
    }
    prepareExpertTraitsString() {
        const item = this.application.item;
        if (!item.hasTraits())
            return null;
        const isArmor = item.isArmor();
        return item.system.traitsArray
            .filter((trait) => !!trait.expertise.toggleActive ||
            trait.expertise.value !== null)
            .map((trait) => {
            const config = isArmor
                ? CONFIG.COSMERE.traits.armorTraits[trait.id]
                : CONFIG.COSMERE.traits.weaponTraits[trait.id];
            if (trait.defaultActive && trait.expertise.toggleActive) {
                return game
                    .i18n.localize('COSMERE.Item.Sheet.Equip.LoseTrait')
                    .replace('[trait]', game.i18n.localize(config.label));
            }
            else if (!trait.defaultActive &&
                trait.expertise.toggleActive) {
                return game.i18n.localize(config.label);
            }
            else if (trait.defaultValue !== null &&
                trait.expertise.value !== null) {
                return game
                    .i18n.localize('COSMERE.Item.Sheet.Equip.ModifyTraitValue')
                    .replace('[trait]', game.i18n.localize(config.label))
                    .replace('[value]', trait.defaultValue.toString())
                    .replace('[newValue]', trait.expertise.value.toString());
            }
        })
            .join(', ');
    }
}
// Register the component
DetailsEquipComponent.register('app-item-details-equip');

class DetailsDeflectComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_DETAILS_DEFLECT}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'toggle-deflected-collapsed': DetailsDeflectComponent.onToggleDeflectedCollapsed,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    deflectedTypesCollapsed = true;
    /* --- Actions --- */
    static onToggleDeflectedCollapsed() {
        this.deflectedTypesCollapsed = !this.deflectedTypesCollapsed;
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            deflectedTypes: this.prepareDeflectedTypesData(),
            deflectedTypesString: this.prepareDeflectedTypesString(),
        });
    }
    prepareDeflectedTypesData() {
        const item = this.application.item;
        if (!item.isArmor())
            return null;
        return Object.entries(CONFIG.COSMERE.damageTypes).map(([id, config]) => {
            const deflectData = item.system.deflects[id];
            return {
                id,
                label: config.label,
                active: deflectData?.active,
            };
        });
    }
    prepareDeflectedTypesString() {
        const item = this.application.item;
        if (!item.hasDeflect())
            return null;
        return item.system.deflectsArray
            .filter((deflect) => deflect.active)
            .map((deflect) => {
            const config = CONFIG.COSMERE.damageTypes[deflect.id];
            return game.i18n.localize(config.label);
        })
            .join(', ');
    }
}
// Register the component
DetailsDeflectComponent.register('app-item-details-deflect');

class DetailsActivationComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_DETAILS_ACTIVATION}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'add-consumption-option': this.addConsumptionOption,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static addConsumptionOption() {
        if (!this.application.item.hasActivation())
            return;
        // Get the activation data
        const { activation } = this.application.item.system;
        activation.consume?.push({
            type: "resource" /* ItemConsumeType.Resource */,
            value: {
                min: 0,
                max: 0,
            },
            resource: "foc" /* Resource.Focus */,
        });
        void this.application.item.update({
            ['system.activation.consume']: activation.consume,
        });
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            ...this.prepareActivationContext(),
            hasActivation: this.application.item.hasActivation(),
        });
    }
    prepareActivationContext() {
        if (!this.application.item.hasActivation())
            return {};
        // Get the activation data
        const { activation } = this.application.item.system;
        return {
            hasActivationType: activation.type !== "none" /* ActivationType.None */,
            hasActivationCost: !!activation.cost.type,
            consume: activation.consume,
            hasUses: !!activation.uses,
            hasSkill: !!activation.resolvedSkill,
            usesTypeSelectOptions: {
                [NONE]: 'GENERIC.None',
                ...this.application.item
                    .system.schema.getField('activation.uses.type').options.choices,
            },
            consumeTypeSelectOptions: {
                '': 'GENERIC.None',
                ...this.application.item
                    .system.schema.getField('activation.consume.element.type').options.choices,
            },
        };
    }
}
// Register the component
DetailsActivationComponent.register('app-item-details-activation');

class DetailsAttackComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_DETAILS_ATTACK}`;
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            ...this.prepareAttackContext(),
            hasAttack: this.application.item.hasAttack(),
        });
    }
    prepareAttackContext() {
        if (!this.application.item.hasAttack())
            return {};
        const item = this.application.item;
        const hasRange = item.system.attack.range;
        return {
            hasRange,
            attackTypeSelectOptions: Object.entries(CONFIG.COSMERE.attack.types).reduce((acc, [key, config]) => ({
                ...acc,
                [key]: config.label,
            }), {}),
            rangeUnitSelectOptions: {
                ...(item.system.attack.type === "melee" /* AttackType.Melee */
                    ? {
                        none: 'GENERIC.None',
                    }
                    : {}),
                ...Object.entries(CONFIG.COSMERE.units.distance).reduce((acc, [key, label]) => ({
                    ...acc,
                    [key]: label,
                }), {}),
            },
        };
    }
}
// Register the component
DetailsAttackComponent.register('app-item-details-attack');

class DetailsDamageComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_DETAILS_DAMAGE}`;
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'toggle-graze-collapsed': DetailsDamageComponent.onToggleGrazeCollapsed,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    grazeOverrideCollapsed = true;
    /* --- Actions --- */
    static onToggleGrazeCollapsed() {
        this.grazeOverrideCollapsed = !this.grazeOverrideCollapsed;
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            ...this.prepareDamageContext(),
            hasDamage: this.application.item.hasDamage(),
        });
    }
    prepareDamageContext() {
        if (!this.application.item.hasDamage())
            return {};
        const hasSkillTest = this.application.item.hasActivation() &&
            this.application.item.system.activation.type ===
                "skill_test" /* ActivationType.SkillTest */;
        const hasSkill = hasSkillTest &&
            this.application.item.system.activation.resolvedSkill;
        this.grazeOverrideCollapsed = this.application.item.system.damage
            .grazeOverrideFormula
            ? this.application.item.system.damage.grazeOverrideFormula === ''
            : this.grazeOverrideCollapsed;
        return {
            hasSkillTest,
            hasSkill,
            grazeInputCollapsed: this.grazeOverrideCollapsed,
            typeSelectOptions: {
                none: '—',
                ...Object.entries(CONFIG.COSMERE.damageTypes).reduce((acc, [key, config]) => ({
                    ...acc,
                    [key]: config.label,
                }), {}),
            },
            ...(hasSkillTest
                ? {
                    skillSelectOptions: {
                        none: 'GENERIC.Default',
                        ...Object.entries(CONFIG.COSMERE.skills).reduce((acc, [key, config]) => ({
                            ...acc,
                            [key]: config.label,
                        }), {}),
                    },
                    attributeSelectOptions: {
                        none: 'GENERIC.Default',
                        ...Object.entries(CONFIG.COSMERE.attributes).reduce((acc, [key, config]) => ({
                            ...acc,
                            [key]: config.label,
                        }), {}),
                    },
                }
                : {}),
        };
    }
}
// Register the component
DetailsDamageComponent.register('app-item-details-damage');

class DetailsModalityComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_DETAILS_MODALITY}`;
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            hasModality: this.application.item.hasModality(),
            modalityEnabled: this.application.item.hasModality() &&
                this.application.item.system.modality !== null,
        });
    }
}
// Register component
DetailsModalityComponent.register('app-item-details-modality');

class DetailsTalentsProviderComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_DETAILS_TALENTS_PROVIDER}`;
    /* --- Context --- */
    _prepareContext(params, context) {
        return Promise.resolve({
            ...context,
            isTalentsProvider: this.application.item.isTalentsProvider(),
        });
    }
}
// Register the component
DetailsTalentsProviderComponent.register('app-item-details-talents-provider');

class DetailsLinkedSkillsComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_DETAILS_LINKED_SKILLS}`;
    /* --- Context --- */
    _prepareContext(params, context) {
        const hasLinkedSkills = this.application.item.hasLinkedSkills();
        if (!hasLinkedSkills)
            return Promise.resolve({ ...context, hasLinkedSkills });
        let linkedSkillsOptions = this.application.item
            .system.schema.getField('linkedSkills').element.choices;
        if (linkedSkillsOptions instanceof Function)
            linkedSkillsOptions = linkedSkillsOptions();
        return Promise.resolve({
            ...context,
            hasLinkedSkills,
            linkedSkillsOptions,
        });
    }
}
// Register the component
DetailsLinkedSkillsComponent.register('app-item-details-linked-skills');

class ItemPropertiesComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_BASE_PROPERTIES}`;
    /* --- Context --- */
    _prepareContext(params, context) {
        const isPhysical = this.application.item.isPhysical();
        const hasProperties = isPhysical;
        return Promise.resolve({
            ...context,
            isPhysical,
            hasProperties,
            units: {
                weight: CONFIG.COSMERE.units.weight.reduce((acc, unit) => ({
                    ...acc,
                    [unit]: unit,
                }), {}),
                price: {
                    none: '—',
                    ...Object.entries(CONFIG.COSMERE.currencies).reduce((acc, [currencyId, currency]) => {
                        // Get all primary denominations with units
                        const denominations = currency.denominations.primary.filter((denomination) => denomination.unit);
                        return {
                            ...acc,
                            ...denominations.reduce((acc, denomination) => ({
                                ...acc,
                                [`${currencyId}.${denomination.id}`]: denomination.unit,
                            }), {}),
                        };
                    }, {}),
                },
            },
        });
    }
}
// Register component
ItemPropertiesComponent.register('app-item-properties');

class AdvancementTalentListComponent extends DragDropComponentMixin((HandlebarsApplicationComponent)) {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_ANCESTRY_TALENT_LIST}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'remove-talent': this.onRemoveTalent,
        'edit-talent': this.onEditTalent,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    static DRAG_DROP = [
        {
            dropSelector: '*',
        },
    ];
    /* --- Actions --- */
    static onRemoveTalent(event) {
        // Get the element
        const el = $(event.currentTarget).closest('.talent');
        // Get the index
        const index = Number(el.data('item'));
        // Get the extra talents from the item
        const { extraTalents } = this.application.item.system.advancement;
        // Remove the talent
        extraTalents.splice(index, 1);
        // Remove the talent
        void this.application.item.update({
            'system.advancement.extraTalents': extraTalents,
        });
    }
    static onEditTalent(event) {
        // Get the element
        const el = $(event.currentTarget).closest('.talent');
        // Get the index
        const index = Number(el.data('item'));
        this.editTalent(index);
    }
    /* --- Drag drop --- */
    _canDragDrop() {
        return this.application.isEditable;
    }
    _onDragOver(event) {
        if (!this.application.isEditable)
            return;
        $(this.element).find('.drop-area').addClass('dropping');
    }
    async _onDrop(event) {
        if (!this.application.isEditable)
            return;
        $(this.element).find('.drop-area').removeClass('dropping');
        // Get data
        const data = TextEditor.getDragEventData(event);
        // Validate type
        if (data.type !== 'Item') {
            return ui.notifications.warn(game.i18n.localize('COSMERE.Item.Sheet.Ancestry.Component.AdvancementTalentList.Warning.WrongType'));
        }
        // Get the document
        const doc = (await fromUuid(data.uuid));
        // Ensure the document is a talent
        if (doc.type !== 'talent') {
            return ui.notifications.warn(game.i18n.localize('COSMERE.Item.Sheet.Ancestry.Component.AdvancementTalentList.Warning.WrongType'));
        }
        // Get the talents list
        let talents = this.application.item.system.advancement.extraTalents;
        // Append
        talents.push({
            uuid: data.uuid,
            level: 1,
        });
        // Sort
        talents = talents.sort((a, b) => a.level - b.level);
        // Add the talent
        await this.application.item.update({
            [`system.advancement.extraTalents`]: talents,
        });
        // Find the index
        const index = talents.findIndex((talent) => talent.uuid === data.uuid);
        setTimeout(() => {
            this.editTalent(index);
        });
    }
    /* --- Lifecycle --- */
    _onAttachListeners(params) {
        super._onAttachListeners(params);
        $(this.element).on('dragleave', () => {
            $(this.element).find('.drop-area').removeClass('dropping');
        });
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        // Get the extra talents from the item
        let { extraTalents } = this.application.item.system.advancement;
        // Sort
        extraTalents = extraTalents.sort((a, b) => a.level - b.level);
        // Process uuids to content links
        extraTalents = await Promise.all(extraTalents.map(async (ref) => {
            // Get the document
            const doc = (await fromUuid(ref.uuid));
            // Generate content link
            const link = new Handlebars.SafeString(doc.toAnchor().outerHTML);
            return {
                ...ref,
                link,
            };
        }));
        return {
            ...context,
            extraTalents,
        };
    }
    /* --- Helpers --- */
    editTalent(index) {
        const extraTalents = this.application.item.system.advancement.extraTalents;
        // Get talent
        const talent = extraTalents[index];
        // Find the new element
        const el = $(this.element).find(`.talent[data-item="${index}"]`);
        // Get the level span
        const level = el.find('.detail.level span');
        // Hide the level span
        level.hide();
        // Create the input
        const input = $(`<input type="number" value="${talent.level}" min="1">`);
        // Append input
        level.after(input);
        setTimeout(() => {
            // Focus the input
            input.trigger('select');
            input.on('keydown', (event) => {
                if (event.which === 13) {
                    input.trigger('blur');
                }
            });
            input.on('blur', () => {
                // Get the new level
                const newLevel = Number(input.val());
                // Update the item
                if (!isNaN(newLevel) && newLevel !== talent.level) {
                    // Update
                    extraTalents[index].level = newLevel;
                    void this.application.item.update({
                        'system.advancement.extraTalents': extraTalents,
                    });
                }
                else {
                    // Trigger render
                    void this.render();
                }
            });
        });
    }
}
// Register the component
AdvancementTalentListComponent.register('app-ancestry-advancement-talent-list');

const { ApplicationV2: ApplicationV2$1, HandlebarsApplicationMixin } = foundry.applications.api;
class EditBonusTalentsRuleDialog extends HandlebarsApplicationMixin((ApplicationV2$1)) {
    resolve;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            title: 'DIALOG.EditBonusTalentsRule.Title',
            minimizable: false,
            resizable: true,
            positioned: true,
        },
        classes: ['dialog', 'edit-bonus-talents-rule'],
        tag: 'dialog',
        position: {
            width: 350,
        },
        actions: {
            update: this.onSubmit,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: 'systems/cosmere-rpg/templates/item/ancestry/dialogs/edit-bonus-talents-rule.hbs',
            forms: {
                form: {
                    handler: this.onFormEvent,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    rule;
    submitted = false;
    constructor(rule, resolve) {
        super({});
        this.resolve = resolve;
        this.rule = foundry.utils.deepClone(rule);
    }
    /* --- Statics --- */
    static show(rule) {
        return new Promise((resolve) => {
            const dialog = new this(rule, resolve);
            void dialog.render(true);
        });
    }
    /* --- Form --- */
    static onFormEvent(event) {
        event.preventDefault();
    }
    /* --- Actions --- */
    static onSubmit() {
        const form = this.element.querySelector('form');
        this.rule.level = Number(form.level.value);
        this.rule.quantity = Number(form.quantity.value);
        this.rule.restrictions = form.restrictions.value;
        this.resolve(this.rule);
        this.submitted = true;
        void this.close();
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
    }
    _onClose() {
        if (!this.submitted)
            this.resolve(null);
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            ...this.rule,
        });
    }
}

class AncestryBonusTalentsComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_ANCESTRY_BONUS_TALENTS}`;
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'add-rule': this.onAddRule,
        'edit-rule': this.onEditRule,
        'remove-rule': this.onRemoveRule,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Actions --- */
    static async onAddRule(event) {
        // Get bonus talents
        const { bonusTalents } = this.application.item.system.advancement;
        // Find the highest level
        const highest = bonusTalents.reduce((acc, rule) => Math.max(acc, rule.level), 0);
        // Create a new rule
        bonusTalents.push({
            level: highest + 1,
            quantity: 1,
            restrictions: '',
        });
        // Update the item
        await this.application.item.update({
            'system.advancement.bonusTalents': bonusTalents,
        });
        // Edit the rule
        void this.editRule(bonusTalents.length - 1);
    }
    static onEditRule(event) {
        // Get the element
        const el = $(event.currentTarget).closest('li');
        // Get the index
        const index = Number(el.data('index'));
        // Edit the rule
        void this.editRule(index);
    }
    static onRemoveRule(event) {
        // Get the element
        const el = $(event.currentTarget).closest('li');
        // Get the index
        const index = Number(el.data('index'));
        // Get the bonus talents
        const { bonusTalents } = this.application.item.system.advancement;
        // Remove the rule
        bonusTalents.splice(index, 1);
        // Update the item
        void this.application.item.update({
            'system.advancement.bonusTalents': bonusTalents,
        });
    }
    /* --- Context --- */
    _prepareContext(params, context) {
        const levels = this.application.item.system.advancement.bonusTalents.sort((a, b) => a.level - b.level);
        return Promise.resolve({
            ...context,
            levels,
        });
    }
    /* --- Helpers --- */
    async editRule(index) {
        // Get bonus talents
        const { bonusTalents } = this.application.item.system.advancement;
        // Get the rule
        const rule = bonusTalents[index];
        const changes = await EditBonusTalentsRuleDialog.show(rule);
        if (changes) {
            if (changes.level !== rule.level) {
                // Ensure no other rule has the same level
                const existing = bonusTalents.find((r) => r.level === changes.level);
                if (existing) {
                    return ui.notifications.warn(game.i18n.format('DIALOG.EditBonusTalentsRule.Warning.DuplicateLevel', {
                        level: changes.level,
                    }));
                }
            }
            bonusTalents[index] = changes;
            void this.application.item.update({
                'system.advancement.bonusTalents': bonusTalents,
            });
        }
    }
}
// Register the component
AncestryBonusTalentsComponent.register('app-ancestry-bonus-talents');

class Viewport extends PIXI.Container {
    app;
    world;
    _view;
    allowPan;
    allowZoom;
    viewBounds;
    // Interaction
    panning = false;
    constructor(app, world, options = {}) {
        super();
        this.app = app;
        this.world = world;
        this.allowPan = options.allowPan ?? true;
        this.allowZoom = options.allowZoom ?? true;
        // Add world to viewport
        this.addChild(world);
        // Set view
        this._view = {
            x: 0,
            y: 0,
            zoom: 1,
            width: this.app.renderer.width,
            height: this.app.renderer.height,
        };
        // Set view bounds if provided
        this.viewBounds = options.bounds;
        // Add viewport to app
        this.app.stage.addChild(this);
        // Set event mode
        this.eventMode = 'static';
        // Attach event listeners
        this.app.renderer.addListener('resize', this._onResize.bind(this));
        this.on('wheel', (e) => this._onWheel(e));
        this.on('mousedown', (e) => this._onMouseDown(e));
        this.on('mouseup', (e) => this._onMouseUp(e));
        this.on('mouseout', (e) => this._onMouseOut(e));
        this.on('mousemove', (e) => this._onMouseMove(e));
    }
    /* --- Initialization --- */
    async initialize() {
        // Initialize world
        await this.world.initialize();
    }
    /* --- Accessors --- */
    get view() {
        return this._view;
    }
    set view(view) {
        view = {
            ...this._view,
            ...view,
        };
        // Clamp zoom - min and max
        view.zoom = Math.min(Math.max(view.zoom ?? this._view.zoom, Viewport.MIN_ZOOM_DEFAULT), Viewport.MAX_ZOOM_DEFAULT);
        // Clamp zoom - if view bounds are set, ensure zoom does not exceed bounds
        if (this.viewBounds) {
            const zoomXLimit = this._view.width / this.viewBounds.width;
            const zoomYLimit = this._view.height / this.viewBounds.height;
            const zoomLimit = Math.max(zoomXLimit, zoomYLimit);
            view.zoom = Math.max(view.zoom, zoomLimit);
        }
        const minX = this.viewBounds
            ? this.viewBounds.x * view.zoom
            : -Number.MAX_VALUE;
        const minY = this.viewBounds
            ? this.viewBounds.y * view.zoom
            : -Number.MAX_VALUE;
        const maxX = this.viewBounds
            ? minX + this.viewBounds.width * view.zoom
            : Number.MAX_VALUE;
        const maxY = this.viewBounds
            ? minY + this.viewBounds.height * view.zoom
            : Number.MAX_VALUE;
        // Clamp x and y
        view.x = Math.max(minX, Math.min(maxX - this._view.width, view.x));
        view.y = Math.max(minY, Math.min(maxY - this._view.height, view.y));
        // Update view
        this._view = view;
        // Update world
        this.world.position.set(-this._view.x, -this._view.y);
        this.world.scale.set(this._view.zoom);
    }
    get visibleBounds() {
        return new PIXI.Rectangle(this._view.x / this._view.zoom, this._view.y / this._view.zoom, this._view.width / this._view.zoom, this._view.height / this._view.zoom);
    }
    /* --- Drawing --- */
    async draw(force = false) {
        await this.world.draw(force);
    }
    /* --- Utility --- */
    /**
     * Converts a point from view coordinates to world coordinates.
     */
    viewToWorld(point) {
        return {
            x: (point.x + this._view.x) / this._view.zoom,
            y: (point.y + this._view.y) / this._view.zoom,
        };
    }
    /**
     * Converts a point from world coordinates to view coordinates.
     */
    worldToView(point) {
        return {
            x: point.x * this._view.zoom - this._view.x,
            y: point.y * this._view.zoom - this._view.y,
        };
    }
    /* --- Event handlers --- */
    _onResize() {
        // Get actual app width and height
        const boundingRect = this.app.view.getBoundingClientRect?.();
        // Update viewport size
        this._view.width = boundingRect?.width ?? this.app.view.width;
        this._view.height = boundingRect?.height ?? this.app.view.height;
        // // Set size
        // this.width = this._view.width;
        // this.height = this._view.height;
    }
    _onMouseDown(event) {
        if (!this.allowPan)
            return;
        // Set panning
        this.panning = true;
    }
    _onMouseUp(event) {
        // Set panning
        this.panning = false;
    }
    _onMouseOut(event) {
        // Set panning
        this.panning = false;
    }
    _onMouseMove(event) {
        if (!this.panning)
            return;
        // Get delta
        const dx = event.movementX;
        const dy = event.movementY;
        // Update view
        this.view = {
            x: this.view.x - dx,
            y: this.view.y - dy,
        };
    }
    _onWheel(event) {
        if (!this.allowZoom)
            return;
        // Get delta
        const delta = event.deltaY;
        // Get zoom change
        let zoom = delta > 0
            ? -Viewport.ZOOM_STEP_DEFAULT
            : Viewport.ZOOM_STEP_DEFAULT;
        // Clamp zoom - min and max
        zoom = Math.min(Math.max(zoom, Viewport.MIN_ZOOM_DEFAULT - this.view.zoom), Viewport.MAX_ZOOM_DEFAULT - this.view.zoom);
        // Clamp zoom - if view bounds are set, ensure zoom does not exceed bounds
        if (this.viewBounds) {
            const zoomXLimit = this._view.width / this.viewBounds.width;
            const zoomYLimit = this._view.height / this.viewBounds.height;
            const zoomLimit = Math.max(zoomXLimit, zoomYLimit);
            zoom = Math.max(zoom, zoomLimit - this.view.zoom);
        }
        const worldSpaceCenter = this.viewToWorld({
            x: this._view.width / 2,
            y: this._view.height / 2,
        });
        const newWorldSpaceCenter = {
            x: worldSpaceCenter.x / (1 + zoom),
            y: worldSpaceCenter.y / (1 + zoom),
        };
        const diff = {
            x: newWorldSpaceCenter.x - worldSpaceCenter.x,
            y: newWorldSpaceCenter.y - worldSpaceCenter.y,
        };
        // Update view
        this.view = {
            zoom: this.view.zoom + zoom,
            x: this.view.x - diff.x * (1 + zoom),
            y: this.view.y - diff.y * (1 + zoom),
        };
    }
}
(function (Viewport) {
    Viewport.ZOOM_STEP_DEFAULT = 0.1;
    Viewport.MIN_ZOOM_DEFAULT = 0.1;
    Viewport.MAX_ZOOM_DEFAULT = 10;
})(Viewport || (Viewport = {}));

class Drawable extends PIXI.Graphics {
    canvas;
    _dirty = true;
    _initialized = false;
    constructor(canvas) {
        super();
        this.canvas = canvas;
    }
    /* --- Accessors --- */
    get debug() {
        return this.canvas.debug;
    }
    get initialized() {
        return this._initialized;
    }
    get isDirty() {
        return this._dirty;
    }
    /* --- Initialization --- */
    async initialize() {
        if (this._initialized)
            return;
        // Initialize children
        await Promise.all(this.children
            .filter((child) => child instanceof Drawable)
            .map((child) => child._initialize()));
        // Perform initialization logic
        await this._initialize();
        // Mark as initialized
        this._initialized = true;
    }
    _initialize() {
        return Promise.resolve();
    }
    /* --- Update --- */
    /**
     * Updates the drawable and all of its children.
     *
     * @param delta Time since last update.
     */
    update(delta) {
        // Perform update logic
        this._update(delta);
        // Update children
        this.children
            .filter((child) => child instanceof Drawable)
            .forEach((child) => child.update(delta));
    }
    /**
     * Override this function with custom update logic.
     *
     * @param delta Time since last update.
     */
    _update(delta) { }
    /* --- Drawing --- */
    /**
     * Draws the drawable and all of its children.
     * Will only redraw if the drawable is marked as dirty, or if force is `true`.
     *
     * @param force Whether to force a redraw.
     */
    async draw(force = false) {
        if (!this._initialized)
            await this.initialize();
        if (this._dirty || force) {
            // Clear the graphics
            this.clear();
            // Perform drawing logic
            this._draw();
            // Mark as clean
            this._dirty = false;
        }
        // Draw children
        await Promise.all(this.children
            .filter((child) => child instanceof Drawable)
            .map((child) => child.draw(force)));
    }
    /**
     * Override this function with custom drawing logic.
     */
    _draw() { }
    markDirty() {
        this._dirty = true;
        // Mark children as dirty
        this.children
            .filter((child) => child instanceof Drawable)
            .forEach((child) => child.markDirty());
    }
    /* --- Hierarchy --- */
    /**
     * Adds one or more children to the drawable.
     *
     * @param children Children to add.
     * @returns The first child added.
     */
    addChild(...children) {
        // Add children
        super.addChild(...children);
        // Mark as dirty
        children
            .filter((child) => child instanceof Drawable)
            .forEach((child) => child.markDirty());
        return children[0];
    }
}

class World extends Drawable {
    constructor(canvas) {
        super(canvas);
        // Set hit area
        this.hitArea = new PIXI.Polygon(new PIXI.Point(-Number.MAX_VALUE, -Number.MAX_VALUE), new PIXI.Point(Number.MAX_VALUE, -Number.MAX_VALUE), new PIXI.Point(Number.MAX_VALUE, Number.MAX_VALUE), new PIXI.Point(-Number.MAX_VALUE, Number.MAX_VALUE));
    }
}

class CanvasDebug {
    graphics = new PIXI.Graphics();
    constructor() {
        this.graphics.zIndex = 1000;
    }
    drawLine(origin, destination, color = 'white', width = 1) {
        this.graphics.lineStyle(width, color);
        this.graphics.moveTo(origin.x, origin.y);
        this.graphics.lineTo(destination.x, destination.y);
        this.graphics.moveTo(0, 0);
        this.graphics.lineStyle({
            width: 1,
            color: 0x000000,
        });
    }
    drawRay(rayOrConfig, options = {}) {
        // Get values
        const { origin, direction } = rayOrConfig;
        const { width = 1, color = 'white', length = 50 } = options;
        // Draw the ray
        this.graphics.lineStyle(width, color);
        this.graphics.moveTo(origin.x, origin.y);
        this.graphics.lineTo(origin.x + direction.x * length, origin.y + direction.y * length);
        this.graphics.moveTo(0, 0);
        this.graphics.lineStyle({
            width: 1,
            color: 0x000000,
        });
    }
    drawCircle(center, radius, color = 'white') {
        this.graphics.beginFill(color);
        this.graphics.drawCircle(center.x, center.y, radius);
        this.graphics.endFill();
    }
    clear() {
        this.graphics.clear();
    }
}

class PIXICanvasApplication {
    debug = new CanvasDebug();
    app;
    _world;
    _viewport;
    constructor(options = {}) {
        this.app = new PIXI.Application({
            backgroundAlpha: options.backgroundAlpha ?? 0,
            backgroundColor: options.backgroundColor ?? 'black',
            autoDensity: true,
            antialias: true,
            width: 200,
            height: 200,
        });
        this.app.renderer.resolution = window.devicePixelRatio;
        // Create world container
        this._world = new (options.worldClass ?? World)(this);
        // Create viewport
        this._viewport = new (options.viewportClass ?? Viewport)(this.app, this._world);
        // Add debug graphics
        this.app.stage.addChild(this.debug.graphics);
        // Update loop
        this.app.ticker.add(this._update.bind(this));
    }
    /* --- Accessors --- */
    get world() {
        return this._world;
    }
    get view() {
        return this._viewport.view;
    }
    set view(view) {
        this._viewport.view = view;
    }
    get viewport() {
        return this._viewport;
    }
    get width() {
        return this.app.view.width;
    }
    get height() {
        return this.app.view.height;
    }
    /* --- General --- */
    /**
     * Bind the canvas to an html element.
     * This will append the canvas to that element.
     */
    bind(element) {
        // Append the canvas to the element
        element.appendChild(this.app.view);
        // Set resize target
        this.app.resizeTo = element;
    }
    destroy() {
        this.app.destroy(true, { children: true, texture: true });
    }
    resize() {
        this.app.resize();
    }
    /* --- Drawing --- */
    async draw(force = false) {
        await this._viewport.draw(force);
    }
    /* --- Update --- */
    /**
     * Update the canvas.
     *
     * @param delta Time since last update.
     */
    _update(delta) {
        this._world.update(delta);
    }
    /* --- Utility --- */
    /**
     * Convert a point from view coordinates to world coordinates.
     */
    viewToWorld(point) {
        return this._viewport.viewToWorld(point);
    }
    /**
     * Convert a point from world coordinates to view coordinates.
     */
    worldToView(point) {
        return this._viewport.worldToView(point);
    }
}

class Animation {
    loop;
    _running = false;
    _time = 0;
    _duration;
    ticker;
    easing;
    callback;
    updateHandler = this._update.bind(this);
    constructor({ duration, ticker, loop, easing, callback, }) {
        this._duration = duration;
        this.ticker = ticker;
        this.easing = easing;
        this.callback = callback;
        this.loop = loop ?? false;
    }
    /* --- Accessors --- */
    /**
     * Is the animation running?
     */
    get running() {
        return this._running;
    }
    /**
     * Elapsed time in milliseconds
     */
    get time() {
        return this._time;
    }
    /**
     * Total duration in milliseconds
     */
    get duration() {
        return this._duration;
    }
    /**
     * Progress from 0 to 1
     */
    get progress() {
        const p = Math.clamp(this._time / this._duration, 0, 1);
        return this.easing ? this.easing(p) : p;
    }
    /* --- Public --- */
    start() {
        if (this._running)
            return;
        this._running = true;
        this.ticker.add(this.updateHandler);
    }
    stop() {
        if (!this._running)
            return;
        this._running = false;
        this.ticker.remove(this.updateHandler);
        // Invoke callback
        this.callback?.();
    }
    /* --- Private --- */
    _update() {
        // Delta in milliseconds
        const delta = this.ticker.deltaMS;
        // Update time
        this._time += delta;
        // Check if the animation is over
        if (this._time >= this._duration) {
            if (this.loop) {
                this._time = this._time % this._duration;
            }
            else {
                this.stop();
                return;
            }
        }
        // Perform update
        this.update(delta);
    }
}
class AnimationFunction extends Animation {
    _func;
    constructor(config) {
        super(config);
        this._func = config.func;
    }
    update(delta) {
        // Invoke the function with `this`
        this._func.call(this, delta);
    }
}
(function (Animation) {
    Animation.EASING = {
        easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
    };
})(Animation || (Animation = {}));

var f=`attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,p=`varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

uniform float outerStrength;
uniform float innerStrength;

uniform vec4 glowColor;

uniform vec4 filterArea;
uniform vec4 filterClamp;
uniform bool knockout;
uniform float alpha;

const float PI = 3.14159265358979323846264;

const float DIST = __DIST__;
const float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);
const float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);

const float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;

void main(void) {
    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);

    float totalAlpha = 0.0;

    vec2 direction;
    vec2 displaced;
    vec4 curColor;

    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {
       direction = vec2(cos(angle), sin(angle)) * px;

       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {
           displaced = clamp(vTextureCoord + direction * 
                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);

           curColor = texture2D(uSampler, displaced);

           totalAlpha += (DIST - curDistance) * curColor.a;
       }
    }
    
    curColor = texture2D(uSampler, vTextureCoord);

    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);

    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;
    float innerGlowStrength = min(1.0, innerGlowAlpha);
    
    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);

    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);
    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);

    if (knockout) {
      float resultAlpha = (outerGlowAlpha + innerGlowAlpha) * alpha;
      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);
    }
    else {
      vec4 outerGlowColor = outerGlowStrength * glowColor.rgba * alpha;
      gl_FragColor = innerColor + outerGlowColor;
    }
}
`;const e=class extends Filter{constructor(n){const r=Object.assign({},e.defaults,n),{outerStrength:a,innerStrength:i,color:u,knockout:c,quality:s,alpha:h}=r,o=Math.round(r.distance);super(f,p.replace(/__ANGLE_STEP_SIZE__/gi,`${(1/s/o).toFixed(7)}`).replace(/__DIST__/gi,`${o.toFixed(0)}.0`)),this.uniforms.glowColor=new Float32Array([0,0,0,1]),this.uniforms.alpha=1,Object.assign(this,{color:u,outerStrength:a,innerStrength:i,padding:o,knockout:c,alpha:h});}get color(){return utils.rgb2hex(this.uniforms.glowColor)}set color(n){utils.hex2rgb(n,this.uniforms.glowColor);}get outerStrength(){return this.uniforms.outerStrength}set outerStrength(n){this.uniforms.outerStrength=n;}get innerStrength(){return this.uniforms.innerStrength}set innerStrength(n){this.uniforms.innerStrength=n;}get knockout(){return this.uniforms.knockout}set knockout(n){this.uniforms.knockout=n;}get alpha(){return this.uniforms.alpha}set alpha(n){this.uniforms.alpha=n;}};let l=e;l.defaults={distance:10,outerStrength:4,innerStrength:0,color:16777215,quality:.1,knockout:!1,alpha:1};

const GRID_SIZE = 50;
const SUB_GRID_SIZE = 50 / 5;
const MIN_SUB_GRID_ZOOM = 0.5;
const EDIT_MENU_WIDTH = 480;

class GridViewport extends Viewport {
    grid = new PIXI.Graphics();
    _displayGrid = true;
    constructor(app, world, options = {}) {
        super(app, world, options);
        this.grid.interactive = false;
        this.grid.zIndex = -10;
        // Set display grid
        this._displayGrid = options.displayGrid ?? true;
        // Remove world from viewport
        this.removeChild(world);
        // Add grid to viewport
        this.addChild(this.grid);
        // Re-add world to viewport
        this.addChild(world);
        // Draw grid initially
        this.drawGrid();
    }
    get view() {
        return super.view;
    }
    set view(view) {
        super.view = view;
        this.drawGrid();
    }
    get displayGrid() {
        return this._displayGrid;
    }
    set displayGrid(displayGrid) {
        this._displayGrid = displayGrid;
        this.drawGrid();
    }
    _onResize() {
        super._onResize();
        this.drawGrid();
    }
    viewToWorld(point, nearestSubgrid = false) {
        const worldPoint = super.viewToWorld(point);
        if (nearestSubgrid) {
            // Round to nearest subgrid
            worldPoint.x =
                Math.round(worldPoint.x / SUB_GRID_SIZE) * SUB_GRID_SIZE;
            worldPoint.y =
                Math.round(worldPoint.y / SUB_GRID_SIZE) * SUB_GRID_SIZE;
        }
        return worldPoint;
    }
    drawGrid() {
        // Clear grid
        this.grid.clear();
        // Check if grid should be displayed
        if (!this._displayGrid)
            return;
        // Set line style
        this.grid.lineStyle({
            width: 1,
            color: '#42414d', // Light grey
            alpha: 0.2,
        });
        // Scale grid size to match zoom
        const scaledGridSize = GRID_SIZE * this.view.zoom;
        // Find view offset from grid
        const offsetX = -this.view.x % scaledGridSize;
        const offsetY = -this.view.y % scaledGridSize;
        // Draw vertical lines
        for (let x = offsetX; x < this.view.width; x += scaledGridSize) {
            this.grid.moveTo(x, 0);
            this.grid.lineTo(x, this.view.height);
        }
        // Draw horizontal lines
        for (let y = offsetY; y < this.view.height; y += scaledGridSize) {
            this.grid.moveTo(0, y);
            this.grid.lineTo(this.view.width, y);
        }
        if (this.view.zoom < MIN_SUB_GRID_ZOOM)
            return;
        // Set line style
        this.grid.lineStyle({
            width: 1,
            color: '#42414d', // Light grey
            alpha: 0.06,
        });
        // Scale sub grid size to match zoom
        const scaledSubGridSize = SUB_GRID_SIZE * this.view.zoom;
        // Draw vertical lines
        for (let x = offsetX; x < this.view.width; x += scaledSubGridSize) {
            if (x % scaledGridSize === 0)
                continue;
            this.grid.moveTo(x, 0);
            this.grid.lineTo(x, this.view.height);
        }
        // Draw horizontal lines
        for (let y = offsetY; y < this.view.height; y += scaledSubGridSize) {
            if (y % scaledGridSize === 0)
                continue;
            this.grid.moveTo(0, y);
            this.grid.lineTo(this.view.width, y);
        }
    }
}

class BaseNode extends Drawable {
    data;
    selected = false;
    constructor(canvas, data) {
        super(canvas);
        this.data = data;
        this.zIndex = 1;
        this.x = data.position.x;
        this.y = data.position.y;
        this.interactive = true;
        this.cursor = 'pointer';
    }
    /* --- Accessors --- */
    get size() {
        return {
            width: GRID_SIZE,
            height: GRID_SIZE,
        };
    }
    get origin() {
        return this.position;
    }
    /* --- Public functions --- */
    refresh() {
        this.x = this.data.position.x;
        this.y = this.data.position.y;
        return Promise.resolve();
    }
    select() {
        this.selected = true;
        this.markDirty();
    }
    deselect() {
        this.selected = false;
        this.markDirty();
    }
}

/**
 * Represents a ray in 2D space.
 * Rays are defined by an origin point and a direction vector and extend infinitely in one direction.
 */
class Ray {
    origin;
    direction;
    constructor(origin, direction) {
        this.origin = origin;
        this.direction = direction;
    }
    /**
     * Returns the point of intersection between this ray and another ray.
     * If the rays do not intersect, `null` is returned.
     */
    intersection(ray) {
        // Check if the rays are parallel
        const cross = this.direction.x * ray.direction.y -
            this.direction.y * ray.direction.x;
        if (cross === 0)
            return null; // Parallel rays do not intersect
        // Calculate the difference in origins
        const originDiff = new PIXI.Point(ray.origin.x - this.origin.x, ray.origin.y - this.origin.y);
        // Calculate the t and u parameters for the intersection point
        const t = (originDiff.x * ray.direction.y - originDiff.y * ray.direction.x) /
            cross;
        const u = (originDiff.x * this.direction.y -
            originDiff.y * this.direction.x) /
            cross;
        // Ensure the intersection lies on both rays
        if (t < 0 || u < 0)
            return null; // Intersection is behind the ray origin
        // Calculate the intersection point
        const intersectionPoint = new PIXI.Point(this.origin.x + t * this.direction.x, this.origin.y + t * this.direction.y);
        return intersectionPoint;
    }
}

// Glow filter
// Constants
const HIT_AREA_SIZE = 5;
class BaseConnection extends Drawable {
    from;
    to;
    path;
    selected = false;
    fromPos;
    toPos;
    prevIsObtained = false;
    constructor(canvas, from, to, path) {
        super(canvas);
        this.from = from;
        this.to = to;
        this.path = path;
        this.zIndex = 2;
        this.fromPos = this.from.position;
        this.toPos = this.to.position;
        // Set filters
        this.filters = [
            new l({
                distance: 15,
                outerStrength: 1,
                alpha: 0,
            }),
            new PIXI.ColorMatrixFilter(),
        ];
        this.refresh();
    }
    /* --- Accessors --- */
    get glowFilter() {
        return this.filters[0];
    }
    get colorMatrixFilter() {
        return this.filters[1];
    }
    get parentNode() {
        const parent = this.parent?.parent;
        return parent instanceof TalentTreeNode ? parent : null;
    }
    get fromOffset() {
        return { x: 0, y: 0 };
    }
    get toOffset() {
        return { x: 0, y: 0 };
    }
    /* --- Public methods --- */
    select() {
        this.selected = true;
        this.markDirty();
    }
    deselect() {
        this.selected = false;
        this.markDirty();
    }
    refresh() {
        if (this.prevIsObtained !== this.isObtained)
            this.markDirty();
        if (this.parentNode?.contentEditable) {
            this.interactive = true;
            this.cursor = 'pointer';
            // Generate hit area
            this.generateHitArea();
        }
        else {
            this.interactive = false;
            this.cursor = 'default';
        }
    }
    /* --- Lifecycle --- */
    _update() {
        // Check if the from or to node has moved
        const nodesMoved = this.from.position.x !== this.fromPos.x ||
            this.from.position.y !== this.fromPos.y ||
            this.to.position.x !== this.toPos.x ||
            this.to.position.y !== this.toPos.y;
        if (nodesMoved) {
            this.fromPos = this.from.position;
            this.toPos = this.to.position;
            void this.draw(true);
        }
    }
    /* --- Drawing --- */
    _draw() {
        // Draw path
        this.drawPath();
        // // Debug hit area
        // this.lineStyle(1, 'red');
        // this.drawPolygon(this.hitArea as PIXI.Polygon);
        // Update filters
        if (!this.canvas.world.editable &&
            !!this.canvas.world.contextActor &&
            !this.isObtained) {
            this.glowFilter.alpha = 0;
            if (this.isAvailable) {
                this.colorMatrixFilter.greyscale(0.1, false);
                this.alpha = 1;
            }
            else {
                this.colorMatrixFilter.greyscale(0.01, false);
                this.alpha = 0.5;
            }
        }
        else {
            this.colorMatrixFilter.reset();
            this.glowFilter.alpha = 0.4;
            this.alpha = 1;
        }
        this.prevIsObtained = this.isObtained;
    }
    drawPath() {
        // Set line style
        this.lineStyle(this.getLineStyle());
        if (!this.path || this.path.length === 0) {
            this.moveTo(this.from.origin.x +
                this.from.size.width / 2 +
                this.fromOffset.x, this.from.origin.y +
                this.from.size.height / 2 +
                this.fromOffset.y);
            this.lineTo(this.to.origin.x + this.to.size.width / 2 + this.toOffset.x, this.to.origin.y + this.to.size.height / 2 + this.toOffset.y);
        }
        else {
            for (let i = 0; i < this.path.length; i++) {
                const point = this.path[i];
                if (i === 0) {
                    this.moveTo(point.x, point.y);
                }
                else {
                    this.lineTo(point.x, point.y);
                }
            }
        }
    }
    getLineStyle() {
        return {
            width: 3,
            color: this.canvas.world.editable && !!this.canvas.world.contextActor
                ? !this.selected
                    ? 'white'
                    : 'gold'
                : this.isObtained
                    ? '#7ba8fc'
                    : 'white',
        };
    }
    /* --- Helpers --- */
    /**
     * Helper function to generate a polygon hit area for the connection.
     * This is used to make the connection clickable.
     */
    generateHitArea() {
        const from = new PIXI.Point(this.from.position.x + this.from.size.width / 2 + this.fromOffset.x, this.from.position.y +
            this.from.size.height / 2 +
            this.fromOffset.y);
        const to = new PIXI.Point(this.to.position.x + this.to.size.width / 2 + this.toOffset.x, this.to.position.y + this.to.size.height / 2 + this.toOffset.y);
        const path = [to, ...(this.path ?? []), from].map((p) => new PIXI.Point(p.x, p.y));
        const polygonPoints = new Array();
        // Walk through the path and generate a hit area
        path.forEach((point, index) => {
            const isFirst = index === 0;
            const isLast = index === path.length - 1;
            // For the first point, add the first and last points to the hit area polygon
            if (isFirst) {
                return polygonPoints.push(point, point
                    .add(path[1]
                    .subtract(point)
                    .normalize()
                    .multiplyScalar(HIT_AREA_SIZE))
                    .add(path[1]
                    .subtract(point)
                    .tanget()
                    .multiplyScalar(HIT_AREA_SIZE)), path[path.length - 1]
                    .add(path[path.length - 2]
                    .subtract(path[path.length - 1])
                    .normalize()
                    .multiplyScalar(HIT_AREA_SIZE))
                    .add(path[path.length - 2]
                    .subtract(path[path.length - 1])
                    .tanget()
                    .multiplyScalar(-HIT_AREA_SIZE)), path[path.length - 1], path[path.length - 1]
                    .add(path[path.length - 2]
                    .subtract(path[path.length - 1])
                    .normalize()
                    .multiplyScalar(HIT_AREA_SIZE))
                    .add(path[path.length - 2]
                    .subtract(path[path.length - 1])
                    .tanget()
                    .multiplyScalar(HIT_AREA_SIZE)), point
                    .add(path[1]
                    .subtract(point)
                    .normalize()
                    .multiplyScalar(HIT_AREA_SIZE))
                    .add(path[1]
                    .subtract(point)
                    .tanget()
                    .multiplyScalar(-HIT_AREA_SIZE)));
            }
            else if (isLast) {
                return;
            }
            // Get the previous and next points
            const prevPoint = path[index - 1];
            const nextPoint = path[index + 1];
            // Calculate the vectors to the previous and next points
            const toPrevVec = prevPoint.subtract(point).normalize();
            const toNextVec = nextPoint.subtract(point).normalize();
            // Calculate the facing of the corner (1 = left, -1 = right)
            const cornerFacing = toPrevVec.dot(toNextVec.tanget()) > 0 ? 1 : -1;
            // Get the angle between the vectors
            const angle = toNextVec.angle(toPrevVec) * cornerFacing;
            // Calculate the middle of the corner
            const cornerMiddle = toPrevVec.rotate(angle / 2).normalize();
            // Calculate the corner points
            const cornerL = new Ray(prevPoint.add(toPrevVec.tanget().multiplyScalar(-HIT_AREA_SIZE)), toPrevVec.multiplyScalar(-1)).intersection(new Ray(point, cornerMiddle.multiplyScalar(cornerFacing)));
            const cornerR = new Ray(prevPoint.add(toPrevVec.tanget().multiplyScalar(HIT_AREA_SIZE)), toPrevVec.multiplyScalar(-1)).intersection(new Ray(point, cornerMiddle.multiplyScalar(-cornerFacing)));
            if (!cornerL || !cornerR) {
                console.error('Failed to generate corner points:', cornerL, cornerR);
                return;
            }
            // Add the corner points to the hit area polygon
            polygonPoints.splice(index + 1, 0, cornerL);
            polygonPoints.splice(index + 5, 0, cornerR);
        });
        this.hitArea = new PIXI.Polygon(polygonPoints);
    }
}
class TalentsConnection extends BaseConnection {
    constructor(canvas, from, to, path) {
        super(canvas, from, to, path);
    }
    /* --- Accessors --- */
    /**
     * Whether the connection is obtained by the context actor.
     * A connection is obtained if the context actor both the talents represented by the FROM and TO nodes.
     */
    get isObtained() {
        // Get context actor
        const actor = this.canvas.world.contextActor;
        if (!actor)
            return false;
        // Check if the actor has the talents
        return (actor.hasTalent(this.from.data.talentId) &&
            actor.hasTalent(this.to.data.talentId));
    }
    /**
     * Whether the connection is available to be unlocked.
     * A connection is available if the TO talent is obtained and the FROM talent is not obtained,
     * and the context actor has the required prerequisites for the FROM talent.
     */
    get isAvailable() {
        // Get context actor
        const actor = this.canvas.world.contextActor;
        if (!actor)
            return false;
        // Ensure the actor has the TO talent
        if (!actor.hasTalent(this.to.data.talentId))
            return false;
        // Ensure the actor does NOT have the FROM talent
        if (actor.hasTalent(this.from.data.talentId))
            return false;
        // Check prerequisites
        return actor.hasTalentPreRequisites(this.from.data.prerequisites, this.canvas.world.tree.item);
    }
}
class NestedTreeConnection extends BaseConnection {
    constructor(canvas, from, to, path) {
        super(canvas, from, to, path);
    }
    /* --- Accessors --- */
    get isObtained() {
        // Get context actor
        const actor = this.canvas.world.contextActor;
        if (!actor)
            return false;
        // Check if the actor has the talent and tree
        return actor.hasTalent(this.to.data.talentId) && this.from.isObtained;
    }
    get isAvailable() {
        // Get context actor
        const actor = this.canvas.world.contextActor;
        if (!actor)
            return false;
        // Ensure the actor has the TO talent
        if (!actor.hasTalent(this.to.data.talentId))
            return false;
        // Check if tree is available
        return this.from.isAvailable;
    }
    get fromOffset() {
        return {
            x: 0,
            y: -(this.from.size.height / 2 -
                (this.from.header?.size.height ?? 0) / 2),
        };
    }
}

// Import base node
class Layer extends Drawable {
    constructor(canvas, zIndex) {
        super(canvas);
        this.zIndex = zIndex;
        this.filters = [new PIXI.ColorMatrixFilter()];
    }
    get colorMatrixFilter() {
        return this.filters[0];
    }
    /**
     * Initializes any uninitialized children.
     */
    async initializeChildren() {
        await Promise.all(this.children
            .filter((child) => child instanceof Drawable && !child.initialized)
            .map((child) => child.initialize()));
    }
}
class TreeHeader extends Drawable {
    node;
    text;
    constructor(node) {
        super(node.canvas);
        this.node = node;
        // Add text
        this.text = new PIXI.Text(this.node.item.name, {
            fontSize: 16,
            fill: 'white',
            fontFamily: 'Penumbra Serif Std',
            fontWeight: 'bold',
        });
        // Set text anchor
        this.text.anchor.set(0.5, 0.5);
        // Add text to the drag handle
        this.addChild(this.text);
        // Check interactivity
        if (!this.node.editable) {
            this.eventMode = 'none';
            this.cursor = 'default';
        }
    }
    get size() {
        return {
            width: this.node.size.width,
            height: SUB_GRID_SIZE * 4,
        };
    }
    _draw() {
        this.clear();
        if (this.node.isRoot)
            return;
        // Get size
        const size = this.size;
        // Draw drag handle
        this.beginFill('#010e2d');
        this.drawRect(this.node.contentBounds.x - this.node.padding.x, this.node.contentBounds.y - this.node.padding.y - size.height, size.width, size.height);
        // Update text position
        this.text.position.set(this.node.contentBounds.x + this.node.contentBounds.width / 2, this.node.contentBounds.y - this.node.padding.y - size.height / 2);
    }
}
class TreeBackground extends Drawable {
    node;
    constructor(node) {
        super(node.canvas);
        this.node = node;
        // Check interactivity
        if (!this.node.editable) {
            this.eventMode = 'none';
            this.cursor = 'default';
        }
    }
    _draw() {
        this.clear();
        if (this.node.isRoot)
            return;
        // Draw background
        this.beginFill('#111', 0.7);
        this.drawRect(this.node.contentBounds.x - this.node.padding.x, this.node.contentBounds.y - this.node.padding.y, this.node.size.width, this.node.size.height);
        this.endFill();
    }
}
class TalentTreeNode extends BaseNode {
    item;
    header;
    nodesLayer;
    connectionsLayer;
    _contentBounds;
    _contentOffset;
    _padding = {
        x: SUB_GRID_SIZE,
        y: SUB_GRID_SIZE,
    };
    constructor(canvas, data, item) {
        super(canvas, data);
        this.item = item;
        if (!this.isRoot) {
            this.addChild(new TreeBackground(this));
        }
        this.name = item.name;
        // Create layers
        this.nodesLayer = new Layer(this.canvas, 2);
        this.connectionsLayer = new Layer(this.canvas, 1);
        // Add layers
        this.addChild(this.connectionsLayer);
        this.addChild(this.nodesLayer);
        if (!this.isRoot) {
            this.header = new TreeHeader(this);
            this.addChild(this.header);
        }
    }
    async _initialize() {
        await this.refresh();
    }
    /* --- Accessors --- */
    get size() {
        return {
            width: (this._contentBounds?.width ?? 0) + this._padding.x * 2,
            height: (this._contentBounds?.height ?? 0) + this._padding.y * 2,
        };
    }
    get origin() {
        // Get the content origin
        const contentOrigin = this.contentOrigin;
        return {
            x: contentOrigin.x - this._padding.x,
            y: contentOrigin.y -
                this._padding.y -
                (this.header?.size.height ?? 0),
        };
    }
    get contentOrigin() {
        return {
            x: this.position.x - (this._contentOffset?.x ?? 0),
            y: this.position.y - (this._contentOffset?.y ?? 0),
        };
    }
    get nodes() {
        return this.nodesLayer?.children;
    }
    get connections() {
        return this.connectionsLayer?.children;
    }
    get isRoot() {
        return !!this.data.isRoot;
    }
    get editable() {
        return this.canvas.world.editable;
    }
    get contentEditable() {
        return this.editable && this.isRoot;
    }
    get contentBounds() {
        return this._contentBounds;
    }
    get contentOffset() {
        return this._contentOffset;
    }
    get padding() {
        return this._padding;
    }
    get rootTalents() {
        return this.item.system.nodes.filter((node) => node.type === "talent" /* TalentTree.Node.Type.Talent */ &&
            node.connections.size === 0);
    }
    get isObtained() {
        // Get context actor
        const actor = this.canvas.world.contextActor;
        if (!actor)
            return false;
        // Check if the actor has any of the root talents
        return this.rootTalents.some((talent) => actor.hasTalent(talent.talentId));
    }
    get isAvailable() {
        // Get context actor
        const actor = this.canvas.world.contextActor;
        if (!actor)
            return false;
        // Check if the actor meets the prerequisites for any of the root talents
        return this.rootTalents.some((talent) => !actor.hasTalent(talent.id) &&
            actor.hasTalentPreRequisites(talent.prerequisites, this.item));
    }
    /* --- Drawing --- */
    _draw() {
        if (this.isRoot)
            return;
        // Draw bounds
        this.lineStyle({
            width: 1,
            color: '#d0a552',
            alignment: 1,
        });
        this.drawRect(this.contentBounds.x - SUB_GRID_SIZE, this.contentBounds.y - SUB_GRID_SIZE * 5, this.contentBounds.width + SUB_GRID_SIZE * 2, this.contentBounds.height + SUB_GRID_SIZE * 6);
    }
    /* --- Public functions --- */
    async refresh() {
        await super.refresh();
        await this.refreshContents();
        if (this.canvas.world.editable && !this.isRoot) {
            this.nodesLayer.colorMatrixFilter.saturate(-0.5, false);
            this.connectionsLayer.colorMatrixFilter.saturate(-0.5, false);
            this.nodesLayer.colorMatrixFilter.brightness(0.75, true);
            this.connectionsLayer.colorMatrixFilter.brightness(0.75, true);
        }
        else {
            this.nodesLayer.colorMatrixFilter.reset();
            this.connectionsLayer.colorMatrixFilter.reset();
        }
    }
    /* --- Helpers --- */
    async refreshContents() {
        const dataNodes = Array.from(this.item.system.nodes);
        // Check if any new nodes have been added
        const addedNodes = dataNodes
            .filter((node) => !this.nodes.some((child) => child.data.id === node.id))
            .filter((node) => !('uuid' in node) || fromUuidSync(node.uuid) !== null);
        // Add new nodes to the canvas
        await Promise.all(addedNodes.map(async (node) => {
            if (node.type === "talent" /* TalentTree.Node.Type.Talent */) {
                this.nodesLayer.addChild(new TalentNode(this.canvas, node));
            }
            else if (node.type === "tree" /* TalentTree.Node.Type.Tree */) {
                // Get the tree item
                const item = (await fromUuid(node.uuid));
                this.nodesLayer.addChild(new TalentTreeNode(this.canvas, node, item));
            }
        }));
        // Check if any nodes have been removed
        const removedNodes = this.nodes.filter((child) => !dataNodes.some((node) => node.id === child.data.id));
        // Remove nodes from the canvas
        removedNodes.forEach((child) => this.nodesLayer.removeChild(child));
        // Get list of all node connections
        const nodeConnections = dataNodes
            .filter((node) => node.type === "talent" /* TalentTree.Node.Type.Talent */)
            .map((node) => {
            return node.connections.map((connection) => ({
                fromId: node.id,
                toId: connection.id,
                path: connection.path,
            }));
        })
            .flat()
            .filter(({ fromId, toId }) => !!fromId && toId);
        const treeConnections = dataNodes
            .filter((node) => node.type === "tree" /* TalentTree.Node.Type.Tree */)
            .map((dataNode) => {
            // Get the talent tree node
            const talentTreeNode = this.nodesLayer.children.find((child) => child.data.id === dataNode.id);
            return talentTreeNode.rootTalents
                .filter((talentNode) => talentNode.prerequisites.size > 0 &&
                talentNode.prerequisites.some((prereq) => prereq.type ===
                    "talent" /* TalentTree.Node.Prerequisite.Type.Talent */))
                .map((talentNode) => talentNode.prerequisites
                .filter((prereq) => prereq.type ===
                "talent" /* TalentTree.Node.Prerequisite.Type.Talent */)
                .map((prereq) => prereq.talents
                .map((ref) => ({
                talentId: this.item.system.nodes.find((n) => n.type ===
                    "talent" /* TalentTree.Node.Type
                                                                            .Talent */ &&
                    n.talentId === ref.id)?.id,
                treeId: dataNode.id,
            }))
                .filter((v) => !!v.talentId)))
                .flat(2)
                .filter((v, i, self) => self.findIndex((t) => t.talentId === v.talentId &&
                t.treeId === v.treeId) === i);
        })
            .flat(2);
        const connections = [...nodeConnections, ...treeConnections];
        // Check if any connections have been added
        const addedConnections = connections.filter((connection) => !this.connections.some((child) => ('fromId' in connection &&
            child.from.data.id === connection.fromId &&
            child.to.data.id === connection.toId) ||
            ('talentId' in connection &&
                child.from.data.id === connection.treeId &&
                child.to.data.id === connection.talentId)));
        // Add new connections to the canvas
        addedConnections.forEach((connection) => {
            if ('fromId' in connection) {
                // Find from and to nodes
                const from = this.nodesLayer.children.find((child) => child.data.id === connection.fromId);
                const to = this.nodesLayer.children.find((child) => child.data.id === connection.toId);
                // Create the connection element
                const connectionElement = new TalentsConnection(this.canvas, from, to, connection.path?.map((point) => new PIXI.Point(point.x, point.y)));
                this.connectionsLayer.addChild(connectionElement);
            }
            else {
                // Find the talent node
                const talentNode = this.nodesLayer.children.find((child) => child.data.id === connection.talentId);
                // Find the tree node
                const treeNode = this.nodesLayer.children.find((child) => child.data.id === connection.treeId);
                // Create the connection element
                const connectionElement = new NestedTreeConnection(this.canvas, treeNode, talentNode);
                this.connectionsLayer.addChild(connectionElement);
            }
        });
        // Check if any connections have been removed
        const removedConnections = this.connections.filter((child) => {
            const connection = child;
            if (connection instanceof TalentsConnection) {
                // Get the from node
                const fromNode = dataNodes.find((node) => node.id === connection.from.data.id);
                // Check if the from node still exists and has the connection
                return (!fromNode ||
                    fromNode.type !== "talent" /* TalentTree.Node.Type.Talent */ ||
                    !fromNode.connections.some((c) => c.id === connection.to.data.id));
            }
            else {
                // Get the from node
                const fromTreeNode = dataNodes.find((node) => node.id === connection.from.data.id);
                const toTalentNode = dataNodes.find((node) => node.id === connection.to.data.id);
                // Check if the from and to nodes still exist
                return (!fromTreeNode ||
                    fromTreeNode.type !== "tree" /* TalentTree.Node.Type.Tree */ ||
                    !toTalentNode);
            }
        });
        // Remove connections from the canvas
        removedConnections.forEach((child) => this.connectionsLayer.removeChild(child));
        const contentsChanged = addedNodes.length > 0 ||
            removedNodes.length > 0 ||
            addedConnections.length > 0 ||
            removedConnections.length > 0;
        if (contentsChanged) {
            // Initialize children
            await this.nodesLayer.initializeChildren();
        }
        // Refresh nodes
        await Promise.all(this.nodes.map((node) => node.refresh()));
        // Refresh connections
        this.connections.forEach((connection) => connection.refresh());
        // Calculate content bounds
        this.calculateContentBounds();
    }
    calculateContentBounds() {
        const leftMostPosition = Math.min(...this.nodesLayer.children.map((node) => node.data.position.x));
        const rightMostPosition = Math.max(...this.nodesLayer.children.map((node) => {
            if (node instanceof TalentNode) {
                return node.data.position.x + node.data.size.width;
            }
            else if (node instanceof TalentTreeNode) {
                return node.data.position.x + node.contentBounds.width;
            }
            else {
                return 0;
            }
        }));
        const topMostPosition = Math.min(...this.nodesLayer.children.map((node) => node.data.position.y));
        const bottomMostPosition = Math.max(...this.nodesLayer.children.map((node) => {
            if (node instanceof TalentNode) {
                return node.data.position.y + node.data.size.height;
            }
            else if (node instanceof TalentTreeNode) {
                return node.data.position.y + node.contentBounds.height;
            }
            else {
                return 0;
            }
        }));
        // Calculate width and height
        const width = rightMostPosition - leftMostPosition;
        const height = bottomMostPosition - topMostPosition;
        // Set content offset
        this._contentOffset = new PIXI.Point(-leftMostPosition, -topMostPosition);
        // Set content bounds
        this._contentBounds = new PIXI.Rectangle(leftMostPosition, topMostPosition, width, height);
    }
}

// PIXI
class TalentNode extends BaseNode {
    img;
    texture;
    _highlighted = false;
    hoverAnimations = [];
    prevIsTalentObtained = false;
    constructor(canvas, data) {
        super(canvas, data);
        // Get the item
        const item = fromUuidSync(this.data.uuid);
        this.name = item.name;
        this.img = item.img;
        // Set event mode
        this.eventMode = 'static';
        // Set filters
        this.filters = [
            new l({
                distance: 15,
                outerStrength: 1.5,
                alpha: 0,
                quality: 0.2,
                color: 0x7fa4e9,
            }),
            new PIXI.ColorMatrixFilter(),
        ];
        // Register event handlers
        this.on('mouseover', this.onMouseOver.bind(this));
        this.on('mouseout', this.onMouseOut.bind(this));
    }
    async _initialize() {
        this.texture = (await loadTexture(this.img));
    }
    /* --- Accessors --- */
    get size() {
        return {
            width: this.data.size.width,
            height: this.data.size.height,
        };
    }
    get glowFilter() {
        return this.filters[0];
    }
    get colorMatrixFilter() {
        return this.filters[1];
    }
    get highlighted() {
        return this._highlighted;
    }
    set highlighted(value) {
        this._highlighted = value;
        if (this._highlighted) {
            this.glowFilter.color = 0xffd700;
            this.glowFilter.alpha = 0.5;
        }
        else {
            this.glowFilter.color = 0x7fa4e9;
            this.glowFilter.alpha = 0.2;
        }
    }
    /**
     * Whether the talent represented by this node is obtained
     * by the context actor.
     */
    get isTalentObtained() {
        // Get context actor
        const actor = this.canvas.world.contextActor;
        if (!actor)
            return false;
        // Check if the actor has the talent
        return actor.hasTalent(this.data.talentId);
    }
    /**
     * Whether the talent represented by this node is available
     * to be unlocked by the context actor.
     * For a talent to be available, all of its prerequisites must be met.
     */
    get isTalentAvailable() {
        // Get context actor
        const actor = this.canvas.world.contextActor;
        if (!actor)
            return false;
        // Check if the actor has the talent already
        if (actor.hasTalent(this.data.talentId))
            return false;
        // Check prerequisites
        return actor.hasTalentPreRequisites(this.data.prerequisites, this.canvas.world.tree.item);
    }
    get parentNode() {
        const parent = this.parent.parent;
        return parent instanceof TalentTreeNode ? parent : null;
    }
    /* --- Event handlers --- */
    onMouseOver(event) {
        if (this.canvas.world.editable)
            return;
        if (this.isTalentObtained || !this.isTalentAvailable)
            return;
        // Get available connections from this node
        const connections = this.parentNode.connections.filter((connection) => connection.from.data.id === this.data.id).filter((connection) => connection.isAvailable);
        // Get glow filter
        const glowFilter = this.glowFilter;
        const colorMatrixFilter = this.colorMatrixFilter;
        this.hoverAnimations.push(new AnimationFunction({
            func: function (delta) {
                colorMatrixFilter.saturate(0.5 + this.progress * 0.5, false);
                colorMatrixFilter.brightness(0.6 + this.progress * 0.4, false);
                connections.forEach((c) => {
                    c.colorMatrixFilter.greyscale(0.1 + this.progress * 0.1, false);
                });
            },
            duration: 300,
            ticker: this.canvas.app.ticker,
            easing: Animation.EASING.easeInOutQuad,
        }));
        glowFilter.alpha = 0.2;
        this.hoverAnimations.push(new AnimationFunction({
            // Animate glow filter outer strength from 0 to 2 and back
            func: function (delta) {
                glowFilter.outerStrength =
                    Math.sin(this.progress * Math.PI) * 2;
            },
            duration: 2000,
            ticker: this.canvas.app.ticker,
            loop: true,
            callback: () => {
                // Reset outer strength
                glowFilter.outerStrength = 1;
                glowFilter.alpha = 0;
            },
        }));
        // Start animations
        this.hoverAnimations.forEach((animation) => animation.start());
    }
    onMouseOut(event) {
        if (this.canvas.world.editable)
            return;
        if (this.isTalentObtained || !this.isTalentAvailable)
            return;
        // Get available connections from this node
        const connections = this.parentNode.connections.filter((connection) => connection.from.data.id === this.data.id).filter((connection) => connection.isAvailable);
        // Stop animations
        this.hoverAnimations.forEach((animation) => animation.stop());
        this.hoverAnimations = [];
        // Reset color matrix filter
        this.colorMatrixFilter.reset();
        this.colorMatrixFilter.saturate(0.5, false);
        this.colorMatrixFilter.brightness(0.6, false);
        // Reset connections
        connections.forEach((c) => {
            if (c.isObtained)
                c.colorMatrixFilter.reset();
            else
                c.colorMatrixFilter.greyscale(0.1, false);
        });
    }
    /* --- Drawing --- */
    _draw() {
        // Create container for masked content
        const container = new PIXI.Container();
        const width = this.data.size.width;
        const height = this.data.size.height;
        if (!this.data.showName) {
            if (!this.texture)
                return;
            // Create the sprite
            const sprite = new PIXI.Sprite(this.texture);
            // Set the size
            sprite.width = width;
            sprite.height = height;
            // Add the sprite
            container.addChild(sprite);
            // Create the mask
            const mask = new PIXI.Graphics();
            mask.beginFill(0xffffff);
            mask.drawRoundedRect(0, 0, width, height, TalentNode.CORNER_RADIUS_DEFAULT);
            // Apply the mask
            sprite.mask = mask;
            // Add the mask
            container.addChild(mask);
        }
        else {
            // Create the text
            const text = new PIXI.Text(this.name, {
                fontSize: 16,
                fill: '#010e2d',
                fontFamily: 'Didact Gothic',
                fontWeight: 'bold',
            });
            // Set the position
            text.position.set(width / 2, height / 2);
            text.anchor.set(0.5);
            // Add the text
            container.addChild(text);
        }
        // Add container
        this.addChild(container);
        // Draw the border
        if (!this.data.showName) {
            // Determine color
            const color = this.canvas.world.editable || !this.canvas.world.contextActor
                ? this.selected
                    ? 'gold'
                    : 'white'
                : this.isTalentObtained
                    ? '#7ba8fc'
                    : this.isTalentAvailable
                        ? 'gray'
                        : 'white';
            this.lineStyle({
                width: 4,
                color,
            });
        }
        else {
            this.beginFill('white');
        }
        // Draw the rounded rectangle
        this.drawRoundedRect(0, 0, width, height, !this.data.showName ? TalentNode.CORNER_RADIUS_DEFAULT : 0);
        // Update filters
        if (!this.canvas.world.editable && !!this.canvas.world.contextActor) {
            if (!this.isTalentObtained) {
                this.glowFilter.alpha = 0;
                if (this.isTalentAvailable) {
                    this.colorMatrixFilter.reset();
                    this.colorMatrixFilter.saturate(0.5, false);
                    this.colorMatrixFilter.brightness(0.6, false);
                    this.cursor = 'pointer';
                }
                else {
                    this.colorMatrixFilter.greyscale(0.05, false);
                    this.cursor = 'default';
                }
            }
            else {
                this.colorMatrixFilter.reset();
                this.glowFilter.alpha = 0.4;
                this.cursor = 'pointer';
            }
        }
        else {
            this.colorMatrixFilter.reset();
            this.cursor = this.canvas.world.editable ? 'pointer' : 'default';
        }
        this.prevIsTalentObtained = this.isTalentObtained;
    }
    /* --- Lifecycle --- */
    async refresh() {
        await super.refresh();
        if (this.prevIsTalentObtained !== this.isTalentObtained)
            this.markDirty();
        if (!this.parentNode)
            return;
        this.eventMode =
            !this.canvas.world.editable || this.parentNode.contentEditable
                ? 'static'
                : 'none';
    }
}
(function (TalentNode) {
    TalentNode.NODE_SIZE_DEFAULT = 50;
    TalentNode.CORNER_RADIUS_DEFAULT = 3;
})(TalentNode || (TalentNode = {}));

// Canvas
class TalentTreeCanvasElement extends Drawable {
    item;
    backgroundAlpha = 1;
    rootNode;
    background = new PIXI.Sprite();
    backgroundTexture;
    constructor(canvas, item) {
        super(canvas);
        this.item = item;
        // Set background z-index
        this.background.zIndex = 0;
        // Create root node
        this.rootNode = new TalentTreeNode(this.canvas, {
            id: this.item.id,
            position: { x: 0, y: 0 },
            type: "tree" /* TalentTree.Node.Type.Tree */,
            uuid: this.item.uuid,
            isRoot: true,
        }, this.item);
        // Add layers
        this.addChild(this.background);
        this.addChild(this.rootNode);
    }
    /* --- Accessors --- */
    get data() {
        return this.item.system;
    }
    get nodes() {
        return this.rootNode.nodes;
    }
    get connections() {
        return this.rootNode.connections;
    }
    get editable() {
        return this.canvas.world.editable;
    }
    /* --- Drawing --- */
    _draw() {
        if (!this.backgroundTexture)
            return;
        // Set the background texture
        this.background.texture = this.backgroundTexture;
        // Set sprite position
        this.background.position.set(this.data.background.position.x, this.data.background.position.y);
        // Set sprite size
        this.background.width = this.data.background.width;
        this.background.height = this.data.background.height;
        // Set sprite alpha
        this.background.alpha = this.backgroundAlpha;
    }
    /* --- Public functions --- */
    async refresh() {
        if (this.data.background.img &&
            !this.backgroundTexture?.baseTexture.resource.src.endsWith(this.data.background.img)) {
            if (this.backgroundTexture) {
                // Unload the existing background texture
                this.backgroundTexture.destroy();
            }
            // Load the new background image
            this.backgroundTexture = (await loadTexture(this.data.background.img));
            // Mark as dirty to redraw
            this.markDirty();
        }
        // Refresh contents
        await this.rootNode.refresh();
    }
}

// Canvas
/* eslint-enable @typescript-eslint/no-empty-object-type */
class TalentTreeWorld extends World {
    editable = false;
    contextActor;
    interactionState = 'none';
    contextElement;
    dragOffset;
    constructor(canvas) {
        super(canvas);
        this.eventMode = 'static';
        this.on('mousemove', (event) => {
            this.onMouseMove(event);
        });
        this.on('mousedown', (event) => {
            if (event.target instanceof BaseNode) {
                this.onMouseDownNode(event);
            }
        });
        this.on('mouseup', (event) => {
            this.onMouseUp();
        });
        this.on('click', (event) => {
            if (event.target instanceof BaseNode) {
                this.onClickNode(event);
            }
            else if (event.target instanceof BaseConnection) {
                this.onClickConnection(event);
            }
        });
        this.on('rightclick', (event) => {
            if (event.target instanceof BaseNode) {
                this.onRightClickNode(event);
            }
            else if (event.target instanceof BaseConnection) {
                this.onRightClickConnection(event);
            }
        });
        this.on('mouseover', (event) => {
            if (event.target instanceof BaseNode) {
                this.onMouseOverNode(event);
            }
        });
        this.on('mouseout', (event) => {
            if (event.target instanceof BaseNode) {
                this.onMouseOutNode(event);
            }
        });
    }
    /* --- Accessors --- */
    get tree() {
        return this.children.find((child) => child instanceof TalentTreeCanvasElement);
    }
    /* --- Public functions --- */
    beginCreateConnection(from) {
        if (!this.editable)
            return;
        if (this.interactionState !== 'none')
            return;
        // Find the node
        const node = this.tree.nodes.find((n) => n.data === from);
        this.interactionState = 'create-connection';
        this.contextElement = node;
    }
    /* --- Event handlers --- */
    onMouseMove(event) {
        if (this.interactionState !== 'drag')
            return;
        // Convert screen coordinates to world coordinates
        const position = this.canvas.viewToWorld(event.screen);
        // Apply the offset
        position.x -= this.dragOffset.x;
        position.y -= this.dragOffset.y;
        // Clamp the position to the sub-grid
        const x = Math.round(position.x / SUB_GRID_SIZE) * SUB_GRID_SIZE;
        const y = Math.round(position.y / SUB_GRID_SIZE) * SUB_GRID_SIZE;
        // Set the position
        this.contextElement.data.position = { x, y };
        this.contextElement.x = x;
        this.contextElement.y = y;
    }
    onMouseUp() {
        if (this.interactionState === 'drag') {
            // Dispatch event
            this.emit('node-move', { node: this.contextElement });
            // Refresh
            void this.tree.refresh();
            // Reset interaction state
            this.interactionState = 'none';
            this.contextElement = undefined;
        }
    }
    onMouseDownNode(event) {
        if (!this.editable)
            return;
        if (this.interactionState !== 'none')
            return;
        // Stop event propagation
        event.stopPropagation();
        // Set interaction state
        this.interactionState = 'drag';
        this.contextElement = event.target;
        // Get world space mouse position
        const mousePos = this.canvas.viewToWorld(event.screen);
        // Calculate drag offset
        this.dragOffset = {
            x: mousePos.x - this.contextElement.position.x,
            y: mousePos.y - this.contextElement.position.y,
        };
    }
    onClickNode(event) {
        if (this.interactionState === 'none') {
            // Prevent the event from bubbling up
            event.stopPropagation();
            // Dispatch event
            this.emit('click-node', {
                node: event.target,
            });
        }
        else if (this.interactionState === 'create-connection') {
            // Prevent the event from bubbling up
            event.stopPropagation();
            // Get the node
            const node = event.target;
            // Ensure node is talent node and not the same as the context node
            if (node instanceof TalentNode &&
                node !== this.contextElement) {
                // Dispatch event
                this.emit('create-connection', {
                    from: this.contextElement,
                    to: node,
                });
                // Reset interaction state
                this.interactionState = 'none';
                this.contextElement = undefined;
                node.highlighted = false;
            }
        }
    }
    onClickConnection(event) {
        if (this.interactionState !== 'none')
            return;
        // Prevent the event from bubbling up
        event.stopPropagation();
        const connection = event.target;
        // Dispatch event
        this.emit('click-connection', {
            connection,
            from: connection.from,
            to: connection.to,
        });
    }
    onRightClickNode(event) {
        if (this.interactionState !== 'none')
            return;
        // Prevent the event from bubbling up
        event.stopPropagation();
        // Dispatch event
        this.emit('rightclick-node', {
            ...event,
            node: event.target,
        });
    }
    onRightClickConnection(event) {
        if (this.interactionState !== 'none')
            return;
        // Prevent the event from bubbling up
        event.stopPropagation();
        const connection = event.target;
        // Dispatch event
        this.emit('rightclick-connection', {
            ...event,
            connection,
            from: connection.from,
            to: connection.to,
        });
    }
    onMouseOverNode(event) {
        if (this.interactionState === 'none') {
            // Prevent the event from bubbling up
            event.stopPropagation();
            // Dispatch event
            this.emit('mouseover-node', {
                node: event.target,
            });
        }
        else if (this.interactionState === 'create-connection') {
            // Prevent the event from bubbling up
            event.stopPropagation();
            // Get the node
            const node = event.target;
            // Ensure node is talent node and not the same as the context node
            if (node instanceof TalentNode &&
                node !== this.contextElement) {
                // Highlight the node
                node.highlighted = true;
            }
        }
    }
    onMouseOutNode(event) {
        if (this.interactionState === 'none') {
            // Prevent the event from bubbling up
            event.stopPropagation();
            // Dispatch event
            this.emit('mouseout-node', {
                node: event.target,
            });
        }
        else if (this.interactionState === 'create-connection') {
            // Prevent the event from bubbling up
            event.stopPropagation();
            // Get the node
            const node = event.target;
            // Ensure node is talent node and not the same as the context node
            if (node instanceof TalentNode &&
                node !== this.contextElement) {
                // Unhighlight the node
                node.highlighted = false;
            }
        }
    }
}

class TalentTreeViewComponent extends DragDropComponentMixin(HandlebarsApplicationComponent) {
    static emittedEvents = super.emittedEvents.concat([
        'click-node',
        'rightclick-node',
        'click-connection',
        'rightclick-connection',
    ]);
    static TEMPLATE = 'systems/cosmere-rpg/templates/item/components/talent-tree-view.hbs';
    static DRAG_DROP = [
        {
            dropSelector: '',
        },
    ];
    static SELECTION_ENABLED = false;
    contextMenu;
    app;
    viewport;
    canvasTree;
    _selected;
    _selectedType = 'node';
    // protected viewPositioned = false;
    shouldPositionView = true;
    prevSetView;
    /* --- Accessors --- */
    get tree() {
        return this.params.tree;
    }
    get allowObtainTalents() {
        return this.params.allowObtainTalents ?? false;
    }
    get contextActor() {
        return this.params.contextActor;
    }
    get selected() {
        return this._selected;
    }
    get selectedType() {
        return this._selectedType;
    }
    get allowPan() {
        return this.params.allowPan ?? false;
    }
    get allowZoom() {
        return this.params.allowZoom ?? false;
    }
    get boundView() {
        return this.params.boundView ?? false;
    }
    /* --- Public functions --- */
    async resize() {
        this.app.resize();
        this.positionCanvasView();
        // Render canvas
        await this.canvasTree.refresh();
        await this.renderCanvas(true);
    }
    async setView(view, bounds = this.boundView, render = true) {
        if (!this.viewport)
            return;
        // Clear the view bounds to allow for setting the view regardless of previous bounds
        this.viewport.viewBounds = undefined;
        // Set view
        this.viewport.view = foundry.utils.mergeObject(this.viewport.view, view);
        this.shouldPositionView = false;
        if (bounds) {
            // Set view bounds
            this.viewport.viewBounds = {
                x: this.viewport.view.x / this.viewport.view.zoom,
                y: this.viewport.view.y / this.viewport.view.zoom,
                width: this.viewport.view.width / this.viewport.view.zoom,
                height: this.viewport.view.height / this.viewport.view.zoom,
            };
        }
        // Render canvas
        if (render) {
            await this.canvasTree.refresh();
            await this.renderCanvas(true);
        }
        // Store the view
        this.prevSetView = view;
    }
    selectNode(node) {
        this.deselect();
        if (!this.constructor
            .SELECTION_ENABLED)
            return;
        this._selected = node;
        this._selectedType = 'node';
        // Select node
        this.canvasTree.nodes.find((n) => n instanceof TalentNode &&
            n.data.id === node.id)?.select();
        // Render canvas
        void this.render();
        void this.renderCanvas();
    }
    selectConnection(connection) {
        // NOTE: Do nothing a tthis time
    }
    deselect() {
        if (!this.selected)
            return;
        if (this.selectedType === 'node') {
            this.canvasTree.nodes.find((n) => n instanceof TalentNode &&
                n.data.id === this.selected.id)?.deselect();
        }
        else {
            this.canvasTree.connections.find((c) => c.from.data.id === this.selected.from &&
                c.to.data.id === this.selected.to)?.deselect();
        }
        this._selected = undefined;
        // Draw tree
        void this.render();
        void this.renderCanvas();
    }
    /* --- Lifecycle --- */
    _onInitialize(params) {
        super._onInitialize(params);
        if (this.app)
            return;
        // Add context menu
        this.contextMenu = AppContextMenu.create({
            parent: this,
        });
        // Create canvas application
        this.app = new PIXICanvasApplication({
            viewportClass: GridViewport,
            worldClass: TalentTreeWorld,
        });
        // Get viewport
        this.viewport = this.app.viewport;
        // Add talent tree element
        this.canvasTree = this.app.world.addChild(new TalentTreeCanvasElement(this.app, this.tree));
        // Add listeners
        this.app.world.on('click-node', debounce(this.onClickNode.bind(this), 300, true));
        this.app.world.on('rightclick-node', debounce(this.onRightClickNode.bind(this), 300, true));
        this.app.world.on('click-connection', this.onClickConnection.bind(this));
        this.app.world.on('rightclick-connection', this.onRightClickConnection.bind(this));
        this.app.world.on('node-move', (event) => {
            this.contextMenu.hide();
            // Update the item
            void this.tree.update({
                [`system.nodes.${event.node.data.id}.position`]: event.node.data.position,
            }, { render: false });
        });
        this.app.world.on('create-connection', async (event) => {
            this.contextMenu.hide();
            // Create connection
            await addConnection(event.from.data.id, event.to.data.id, this.tree, { render: false });
            await this.canvasTree.refresh();
            void this.renderCanvas();
        });
        this.app.world.on('mouseover-node', debounce(this.onMouseOverNode.bind(this), 300, true));
        this.app.world.on('mouseout-node', debounce(this.onMouseOutNode.bind(this), 300, true));
        this.viewport.on('mousedown', () => {
            this.contextMenu.hide();
            this.deselect();
            void this.renderCanvas();
        });
        // Configure
        this.configureWorld();
        this.configureViewport();
    }
    _onDestroy() {
        // Teardown canvas
        this.app.destroy();
    }
    _onRender(params) {
        super._onRender(params);
        // Get view element
        const view = this.element.querySelector('.view');
        // Bind the canvas to the view
        this.app.bind(view);
        // Re-configure
        this.configureWorld();
        this.shouldPositionView ||=
            (this.params.view !== undefined &&
                Object.keys(this.params.view).length > 0 &&
                (!this.prevSetView ||
                    !foundry.utils.objectsEqual(this.prevSetView, this.params.view))) ||
                (!this.params.view && !!this.prevSetView);
        setTimeout(async () => {
            this.app.resize();
            if (this.shouldPositionView)
                this.positionCanvasView();
            // Render canvas
            await this.canvasTree.refresh();
            await this.renderCanvas(true);
        });
    }
    configureWorld() {
        this.app.world.editable = false;
        this.app.world.contextActor = this.params.contextActor;
    }
    configureViewport() {
        this.app.viewport.displayGrid = false;
        this.app.viewport.allowPan = this.allowPan;
        this.app.viewport.allowZoom = this.allowZoom;
        if (this.boundView)
            this.app.viewport.viewBounds = this.tree.system.viewBounds;
    }
    positionCanvasView() {
        if (this.params.view && Object.keys(this.params.view).length > 0) {
            // If a view is provided, use it
            void this.setView(this.params.view, this.boundView, false);
        }
        else {
            const canvasWidth = this.app.view.width;
            const canvasHeight = this.app.view.height;
            // Compute new zoom level to match the stored world width and height
            const zoomX = canvasWidth / this.tree.system.viewBounds.width;
            const zoomY = canvasHeight / this.tree.system.viewBounds.height;
            // Use the smaller zoom to ensure the same content is visible
            const newZoom = Math.min(zoomX, zoomY);
            // Compute new top-left position so the center remains the same
            const centerOffsetX = this.tree.system.viewBounds.width / 2;
            const centerOffsetY = this.tree.system.viewBounds.height / 2;
            const cornerX = this.tree.system.viewBounds.x - centerOffsetX;
            const cornerY = this.tree.system.viewBounds.y - centerOffsetY;
            const newX = cornerX * newZoom;
            const newY = cornerY * newZoom;
            // Set the view
            void this.setView({
                x: newX,
                y: newY,
                zoom: newZoom,
            }, this.boundView, false);
        }
    }
    /* --- Event handlers --- */
    async onClickNode(event) {
        // Dispatch event
        this.dispatchEvent(new CustomEvent('click-node', {
            detail: {
                node: event.node,
            },
        }));
        // Get the node
        const node = event.node.data;
        if (!!this.contextActor &&
            this.allowObtainTalents &&
            node.type === "talent" /* TalentTree.Node.Type.Talent */ &&
            !this.contextActor.hasTalent(node.talentId) &&
            this.contextActor.hasTalentPreRequisites(node.prerequisites, this.tree)) {
            // Get the item
            const item = (await fromUuid(node.uuid));
            if (!item)
                return;
            const itemData = item.toObject();
            // Determine the parent (if any)
            const relParent = this.params.parent;
            if (relParent) {
                ItemRelationshipUtils.addRelationshipData(itemData, relParent, ItemRelationship.Type.Parent);
            }
            // Obtain talent
            await this.contextActor.createEmbeddedDocuments('Item', [itemData]);
            // Notification
            ui.notifications.info(game.i18n.format('GENERIC.Notification.TalentObtained', {
                talent: item.name,
                actor: this.contextActor.name,
            }));
            // Refresh tree
            await this.canvasTree.refresh();
            await this.renderCanvas(true);
        }
    }
    async onRightClickNode(event) {
        // Dispatch event
        this.dispatchEvent(new CustomEvent('rightclick-node', {
            detail: {
                node: event.node,
            },
        }));
        // Get the node
        const node = event.node.data;
        if (!!this.contextActor &&
            this.allowObtainTalents &&
            node.type === "talent" /* TalentTree.Node.Type.Talent */ &&
            this.contextActor.hasTalent(node.talentId)) {
            // Find the talent on the actor
            const talent = this.contextActor.items.find((item) => item.isTalent() && item.system.id === node.talentId);
            // Check if the talent is removable
            if (await isTalentRequiredAsPrerequisite(this.contextActor, node.talentId, this.tree)) {
                ui.notifications.warn(game.i18n.format('GENERIC.Notification.TalentCannotBeRemoved', {
                    talent: talent.name,
                    actor: this.contextActor.name,
                }));
                return;
            }
            // Remove the talent
            await talent.delete();
            // Notification
            ui.notifications.info(game.i18n.format('GENERIC.Notification.TalentRemoved', {
                talent: talent.name,
                actor: this.contextActor.name,
            }));
            // Refresh tree
            await this.canvasTree.refresh();
            await this.renderCanvas(true);
        }
    }
    onClickConnection(event) {
        // Dispatch event
        this.dispatchEvent(new CustomEvent('click-connection', {
            detail: {
                connection: event.connection,
            },
        }));
    }
    onRightClickConnection(event) {
        // Dispatch event
        this.dispatchEvent(new CustomEvent('rightclick-connection', {
            detail: {
                connection: event.connection,
            },
        }));
    }
    async onMouseOverNode(event) {
        // Get the item
        const item = (await fromUuid(event.node.data.uuid));
        if (!item)
            return;
        // Get the node
        const node = event.node.data;
        // Get node view position
        const viewPos = event.node.getGlobalPosition();
        // Get node size
        const nodeSize = {
            width: event.node.data.size.width * this.viewport.view.zoom,
            height: event.node.data.size.height * this.viewport.view.zoom,
        };
        // Render tooltip
        const contentStr = await renderSystemTemplate(TEMPLATES.ITEM_TALENT_TREE_NODE_TOOLTIP, {
            title: item.name,
            img: item.img,
            prerequisites: node.prerequisites.map((prereq) => {
                const prereqMet = this.contextActor
                    ? characterMeetsPrerequisiteRule(this.contextActor, prereq, this.tree)
                    : undefined;
                return {
                    ...prereq,
                    met: prereqMet,
                    ...(prereq.type ===
                        "talent" /* TalentTree.Node.Prerequisite.Type.Talent */
                        ? {
                            talents: prereq.talents.map((ref) => ({
                                id: ref.id,
                                label: fromUuidSync(ref.uuid)?.name ?? ref.label,
                                uuid: ref.uuid,
                                obtained: this.contextActor?.hasTalent(ref.id) ?? false,
                            })),
                        }
                        : undefined),
                    ...(prereq.type ===
                        "goal" /* TalentTree.Node.Prerequisite.Type.Goal */
                        ? {
                            goals: prereq.goals.map((ref) => ({
                                id: ref.id,
                                label: fromUuidSync(ref.uuid)?.name ?? ref.label,
                                uuid: ref.uuid,
                                completed: this.contextActor?.hasCompletedGoal(ref.id) ?? false,
                            })),
                        }
                        : undefined),
                };
            }),
            description: await TextEditor.enrichHTML(htmlStringHasContent(item.system.description?.short)
                ? item.system.description.short
                : htmlStringHasContent(item.system.description?.value)
                    ? item.system.description.value
                    : ''),
            hasContextActor: !!this.contextActor,
        });
        // Turn the string into an element
        const template = document.createElement('template');
        template.innerHTML = contentStr;
        const content = template.content.firstElementChild;
        // Create temp element to serve as the tooltip target
        const toolTipRoot = document.createElement('div');
        toolTipRoot.style.position = 'absolute';
        toolTipRoot.style.left = viewPos.x + 'px';
        toolTipRoot.style.top = viewPos.y + 'px';
        toolTipRoot.style.width = nodeSize.width + 'px';
        toolTipRoot.style.height = nodeSize.height + 'px';
        toolTipRoot.style.pointerEvents = 'none';
        toolTipRoot.classList.add('talent-tree-tooltip-root');
        this.element.appendChild(toolTipRoot);
        // Show tooltip
        game.tooltip.activate(toolTipRoot, {
            content: content,
            direction: 'RIGHT',
        });
    }
    onMouseOutNode() {
        game.tooltip.deactivate();
        // Remove tooltip root
        const tooltipRoot = this.element.querySelectorAll('.talent-tree-tooltip-root');
        tooltipRoot.forEach((el) => el.remove());
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        const item = !!this.selected && this.selectedType === 'node'
            ? (await fromUuid(this.selected.uuid))
            : null;
        const itemLink = item ? item.toAnchor().outerHTML : null;
        return {
            ...params,
            tree: this.tree,
            selected: this.selected,
            selectedType: this.selectedType,
            hasSelection: !!this.selected,
            item,
            itemLink,
        };
    }
    /* --- PIXI rendering --- */
    async renderCanvas(force) {
        await this.app.draw(force);
    }
}
// Register the component
TalentTreeViewComponent.register('app-talent-tree-view');

// Components
class TalentTreeEditorComponent extends TalentTreeViewComponent {
    static TEMPLATE = 'systems/cosmere-rpg/templates/item/components/talent-tree-editor.hbs';
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'capture-view': this.onCaptureView,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    static SELECTION_ENABLED = true;
    /* --- Statics --- */
    static onCaptureView(event) {
        event.preventDefault();
        event.stopPropagation();
        // Get the visible bounds
        const bounds = this.app.viewport.visibleBounds;
        // Compute the center
        const center = {
            x: bounds.x + bounds.width / 2,
            y: bounds.y + bounds.height / 2,
        };
        // Get window size
        const windowSize = {
            width: this.application.position.width,
            height: this.application.position.height,
        };
        // Store the view position
        void this.tree.update({
            'system.viewBounds': {
                x: center.x,
                y: center.y,
                width: bounds.width,
                height: bounds.height,
            },
            'system.display': {
                width: windowSize.width - EDIT_MENU_WIDTH,
                height: windowSize.height,
            },
        });
    }
    /* --- Public functions --- */
    async resize() {
        // Get bounds
        const bounds = this.element.getBoundingClientRect();
        // Set size
        this.app.app.renderer.resize(bounds.width - EDIT_MENU_WIDTH, bounds.height);
        // Render canvas
        await this.canvasTree.refresh();
        await this.renderCanvas(true);
    }
    /* --- Configuration --- */
    configureWorld() {
        super.configureWorld();
        this.app.world.editable = true;
        this.canvasTree.backgroundAlpha = 0.5;
    }
    configureViewport() {
        this.app.viewport.displayGrid = true;
        this.app.viewport.allowPan = true;
        this.app.viewport.allowZoom = true;
    }
    /* --- Drag drop --- */
    _canDragDrop(selector) {
        return true;
    }
    async _onDrop(event) {
        const data = TextEditor.getDragEventData(event);
        // Ensure type is correct
        if (data.type !== 'Item')
            return;
        // Get the item
        const item = (await fromUuid(data.uuid));
        // Handle item
        if (item?.isTalent())
            await this.onDropTalent(event, item);
        else if (item?.isTalentTree())
            await this.onDropTalentTree(event, item);
        // Refresh tree
        await this.canvasTree.refresh();
        await this.renderCanvas();
    }
    async onDropTalent(event, item) {
        // Get the item ids for all the nodes in the tree
        const itemIds = this.tree.system.nodes
            .filter((node) => node.type === "talent" /* TalentTree.Node.Type.Talent */)
            .map((node) => node.talentId);
        // Ensure the item isn't already present in the tree
        if (itemIds.includes(item.system.id)) {
            return ui.notifications.warn(game.i18n.format('GENERIC.Warning.ItemAlreadyInTree', {
                itemId: item.system.id,
                name: this.tree.name,
            }));
        }
        // Convert drop position to world space
        const dropPos = this.app.viewport.viewToWorld({
            x: event.offsetX - GRID_SIZE / 2,
            y: event.offsetY - GRID_SIZE / 2,
        }, true);
        // Create node
        const newNode = {
            id: foundry.utils.randomID(),
            type: "talent" /* TalentTree.Node.Type.Talent */,
            position: dropPos,
            talentId: item.system.id,
            uuid: item.uuid,
            size: {
                width: GRID_SIZE,
                height: GRID_SIZE,
            },
            showName: false,
        };
        // Add node to tree
        await addNode(newNode, this.tree, { render: false });
    }
    async onDropTalentTree(event, item) {
        // Get the talent tree uuids for all the nodes in the tree
        const treeUuids = this.tree.system.nodes
            .filter((node) => node.type === "tree" /* TalentTree.Node.Type.Tree */)
            .map((node) => node.uuid);
        // Ensure the item isn't already present in the tree
        if (treeUuids.includes(item.uuid)) {
            return ui.notifications.warn(game.i18n.format('GENERIC.Warning.ItemAlreadyInTree', {
                itemId: item.uuid,
                name: this.tree.name,
            }));
        }
        // Convert drop position to world space
        const dropPos = this.app.viewport.viewToWorld({
            x: event.offsetX - GRID_SIZE / 2,
            y: event.offsetY - GRID_SIZE / 2,
        }, true);
        // Create node
        const newNode = {
            id: foundry.utils.randomID(),
            type: "tree" /* TalentTree.Node.Type.Tree */,
            position: dropPos,
            uuid: item.uuid,
        };
        // Add node to tree
        await addNode(newNode, this.tree, { render: false });
    }
    /* --- Event handlers --- */
    onClickNode(event) {
        this.contextMenu.hide();
        // Select
        this.selectNode(event.node.data);
        // Dispatch event
        this.dispatchEvent(new CustomEvent('click-node', {
            detail: {
                node: event.node,
            },
        }));
        return Promise.resolve();
    }
    async onRightClickNode(event) {
        this.contextMenu.hide();
        // Dispatch event
        this.dispatchEvent(new CustomEvent('rightclick-node', {
            detail: {
                node: event.node,
            },
        }));
        // Show context menu
        const options = [
            ...(event.node.data.type === "talent" /* TalentTree.Node.Type.Talent */
                ? this.getTalentContextMenuOptions(event.node.data)
                : []),
            ...this.getNodeContextMenuOptions(event.node.data),
        ];
        if (options.length === 0)
            return;
        // Convert node position to view space
        const viewPos = this.viewport.worldToView(event.node.origin);
        // Adjust size for zoom
        const size = {
            width: event.node.size.width * this.viewport.view.zoom,
            height: event.node.size.height * this.viewport.view.zoom,
        };
        // Show context menu
        await this.contextMenu.show(options, {
            left: viewPos.x + size.width,
            top: viewPos.y,
        });
    }
    onClickConnection(event) {
        super.onClickConnection(event);
        // Select
        this.selectConnection({
            from: event.from.data.id,
            to: event.to.data.id,
        });
    }
    onRightClickConnection(event) {
        // Convert canvas connection to node connection
        const connection = {
            from: event.from.data.id,
            to: event.to.data.id,
        };
        // Select
        this.selectConnection(connection);
        // Get options
        const options = this.getConnectionContextMenuOptions(connection);
        if (options.length === 0)
            return;
        // Show context menu
        void this.contextMenu.show(this.getConnectionContextMenuOptions(connection), {
            left: event.screen.x,
            top: event.screen.y,
        });
    }
    onMouseOverNode() {
        return Promise.resolve();
    }
    onMouseOutNode() {
        return;
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        return {
            ...(await super._prepareContext(params, context)),
            documentSchema: this.tree.schema,
            systemSchema: this.tree.system.schema,
        };
    }
    /* --- Context menu options --- */
    getNodeContextMenuOptions(node) {
        return [
            {
                icon: 'fas fa-trash',
                name: 'Delete',
                callback: async () => {
                    this._selected = undefined;
                    await removeNode(node, this.tree, {
                        render: false,
                    });
                    await this.canvasTree.refresh();
                },
            },
        ];
    }
    getTalentContextMenuOptions(node) {
        return [
            {
                icon: 'fas fa-edit',
                name: 'Edit',
                callback: async () => {
                    // Get the item
                    const item = (await fromUuid(node.uuid));
                    // Show item sheet
                    void item?.sheet?.render(true);
                },
            },
            {
                icon: 'fas fa-plus',
                name: 'Add Connection',
                callback: () => {
                    this.app.world.beginCreateConnection(node);
                },
            },
        ];
    }
    getConnectionContextMenuOptions(connection) {
        return [
            {
                icon: 'fas fa-trash',
                name: 'Delete',
                callback: async () => {
                    this._selected = undefined;
                    await removeConnection(connection.from, connection.to, this.tree, { render: false });
                    await this.canvasTree.refresh();
                },
            },
        ];
    }
}
// Register the component
TalentTreeEditorComponent.register('app-talent-tree-editor');

const { ApplicationV2 } = foundry.applications.api;
class EditNodePrerequisiteDialog extends ComponentHandlebarsApplicationMixin((ApplicationV2)) {
    tree;
    node;
    data;
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        window: {
            title: 'DIALOG.EditTalentPrerequisite.Title',
            minimizable: false,
            resizable: true,
            positioned: true,
        },
        classes: ['dialog', 'edit-talent-prerequisite'],
        tag: 'dialog',
        position: {
            width: 350,
        },
        actions: {
            update: this.onUpdatePrerequisite,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        form: {
            template: 'systems/cosmere-rpg/templates/item/talent-tree/dialogs/edit-prerequisite.hbs',
            forms: {
                form: {
                    handler: this.onFormEvent,
                    submitOnChange: true,
                },
            },
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    constructor(tree, node, data) {
        super({
            id: `${tree.uuid}.nodes.${node.id}.Prerequisite.${data.id}`,
        });
        this.tree = tree;
        this.node = node;
        this.data = data;
    }
    /* --- Statics --- */
    static async show(tree, node, data) {
        // Clone data
        data = foundry.utils.deepClone(data);
        if (data.type === "talent" /* TalentTree.Node.Prerequisite.Type.Talent */) {
            data.talents = new RecordCollection(Array.from(data.talents.entries()));
        }
        else if (data.type === "goal" /* TalentTree.Node.Prerequisite.Type.Goal */) {
            data.goals = new RecordCollection(Array.from(data.goals.entries()));
        }
        const dialog = new this(tree, node, data);
        await dialog.render(true);
    }
    /* --- Actions --- */
    static onUpdatePrerequisite() {
        if (this.data.type === "talent" /* TalentTree.Node.Prerequisite.Type.Talent */) {
            // Get the old prerequisite state
            const old = this.node.prerequisites.get(this.data.id);
            // Get previous talents
            const prevTalents = old?.type === "talent" /* TalentTree.Node.Prerequisite.Type.Talent */
                ? Array.from(old.talents.keys())
                : [];
            // Figure out which talents have been removed
            const removedTalents = prevTalents.filter((id) => !this.data.talents.has(id));
            void this.tree.update({
                [`system.nodes.${this.node.id}.prerequisites.${this.data.id}`]: this.data,
                [`system.nodes.${this.node.id}.prerequisites.${this.data.id}.talents`]: this.data.talents.toJSON(),
                // Add removals
                ...removedTalents.reduce((acc, id) => ({
                    ...acc,
                    [`system.nodes.${this.node.id}.prerequisites.${this.data.id}.talents.-=${id}`]: {},
                }), {}),
            });
        }
        else if (this.data.type === "goal" /* TalentTree.Node.Prerequisite.Type.Goal */) {
            // Get the old prerequisite state
            const old = this.node.prerequisites.get(this.data.id);
            // Get previous goals
            const prevGoals = old?.type === "goal" /* TalentTree.Node.Prerequisite.Type.Goal */
                ? Array.from(old.goals.keys())
                : [];
            // Figure out which goals have been removed
            const removedGoals = prevGoals.filter((id) => !this.data.goals.has(id));
            void this.tree.update({
                [`system.nodes.${this.node.id}.prerequisites.${this.data.id}`]: this.data,
                [`system.nodes.${this.node.id}.prerequisites.${this.data.id}.goals`]: this.data.goals.toJSON(),
                // Add removals
                ...removedGoals.reduce((acc, id) => ({
                    ...acc,
                    [`system.nodes.${this.node.id}.prerequisites.${this.data.id}.goals.-=${id}`]: {},
                }), {}),
            });
        }
        else {
            if (this.data.type ===
                "attribute" /* TalentTree.Node.Prerequisite.Type.Attribute */ &&
                isNaN(this.data.value)) {
                this.data.value = 1;
            }
            else if (this.data.type === "skill" /* TalentTree.Node.Prerequisite.Type.Skill */ &&
                isNaN(this.data.rank)) {
                this.data.rank = 1;
            }
            void this.tree.update({
                [`system.nodes.${this.node.id}.prerequisites.${this.data.id}`]: this.data,
            });
        }
        void this.close();
    }
    /* --- Form --- */
    static async onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        // Get type
        const type = formData.get('type');
        this.data.type = type;
        if (this.data.type === "attribute" /* TalentTree.Node.Prerequisite.Type.Attribute */) {
            this.data.attribute = (formData.get('attribute') ??
                Object.keys(CONFIG.COSMERE.attributes)[0]);
            this.data.value = parseInt(formData.get('value'), 10);
        }
        else if (this.data.type === "skill" /* TalentTree.Node.Prerequisite.Type.Skill */) {
            this.data.skill = (formData.get('skill') ??
                Object.keys(CONFIG.COSMERE.skills)[0]);
            this.data.rank = parseInt(formData.get('rank'), 10);
        }
        else if (this.data.type === "talent" /* TalentTree.Node.Prerequisite.Type.Talent */) {
            this.data.talents ??= new RecordCollection();
        }
        else if (this.data.type === "goal" /* TalentTree.Node.Prerequisite.Type.Goal */) {
            this.data.goals ??= new RecordCollection();
        }
        else if (this.data.type === "connection" /* TalentTree.Node.Prerequisite.Type.Connection */) {
            this.data.description = formData.get('description');
        }
        else if (this.data.type === "level" /* TalentTree.Node.Prerequisite.Type.Level */ &&
            formData.has('level')) {
            this.data.level = parseInt(formData.get('level'));
        }
        else if (this.data.type === "ancestry" /* TalentTree.Node.Prerequisite.Type.Ancestry */ &&
            formData.has('ancestry')) {
            const ancestryUuid = formData.get('ancestry');
            const ancestry = (await fromUuid(ancestryUuid));
            if (ancestry?.isAncestry()) {
                this.data.ancestry = {
                    uuid: ancestry.uuid,
                    id: ancestry.system.id,
                    label: ancestry.name,
                };
            }
        }
        else if (this.data.type === "culture" /* TalentTree.Node.Prerequisite.Type.Culture */ &&
            formData.has('culture')) {
            const cultureUuid = formData.get('culture');
            const culture = (await fromUuid(cultureUuid));
            if (culture?.isCulture()) {
                this.data.culture = {
                    uuid: culture.uuid,
                    id: culture.system.id,
                    label: culture.name,
                };
            }
        }
        // Render
        void this.render(true);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element).prop('open', true);
        $(this.element)
            .find('app-talent-prerequisite-talent-list')
            .on('change', () => this.render(true));
    }
    /* --- Context --- */
    _prepareContext() {
        return Promise.resolve({
            editable: true,
            tree: this.tree,
            node: this.node,
            schema: this.tree.system.schema.getField('nodes.model.prerequisites.model'),
            ...this.data,
            typeSelectOptions: this.getPrequisiteTypeSelectOptions(),
            attributeSelectOptions: Object.entries(CONFIG.COSMERE.attributes).reduce((acc, [key, config]) => ({
                ...acc,
                [key]: config.label,
            }), {}),
            skillSelectOptions: Object.entries(CONFIG.COSMERE.skills).reduce((acc, [key, config]) => ({
                ...acc,
                [key]: config.label,
            }), {}),
        });
    }
    /* --- Helpers --- */
    getPrequisiteTypeSelectOptions() {
        return this.tree.system.schema.getField('nodes.model.prerequisites.model.type').choices;
    }
}

// Utils
class NodePrerequisitesComponent extends HandlebarsApplicationComponent {
    static TEMPLATE = 'systems/cosmere-rpg/templates/item/talent-tree/components/prerequisites.hbs';
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'create-prerequisite': this.onCreatePrerequisite,
        'edit-prerequisite': this.onEditPrerequisite,
        'delete-prerequisite': this.onDeletePrerequisite,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    /* --- Accessors --- */
    get node() {
        return this.params?.node;
    }
    /* --- Actions --- */
    static async onCreatePrerequisite(event) {
        // Create a new prerequisite
        const newRule = {
            id: foundry.utils.randomID(),
            type: "attribute" /* TalentTree.Node.Prerequisite.Type.Attribute */,
            attribute: "str" /* Attribute.Strength */,
            value: 1,
            managed: false,
        };
        // Add the new rule to the item
        await this.application.item.update({
            [`system.prerequisites.${newRule.id}`]: newRule,
        });
        // Show the edit dialog
        await EditNodePrerequisiteDialog.show(this.application.item, this.node, newRule);
    }
    static onEditPrerequisite(event) {
        // Get the rule ID
        const id = this.getRuleIdFromEvent(event);
        if (!id)
            return;
        // Get the rule data
        const rule = this.node.prerequisites.get(id);
        if (!rule)
            return;
        // Ensure rule isn't managed
        if (rule.managed)
            return;
        // Show the edit dialog
        void EditNodePrerequisiteDialog.show(this.application.item, this.node, rule);
    }
    static onDeletePrerequisite(event) {
        // Get the rule ID
        const id = this.getRuleIdFromEvent(event);
        if (!id)
            return;
        // Get the rule data
        const rule = this.node.prerequisites.get(id);
        if (!rule)
            return;
        // Ensure rule isn't managed
        if (rule.managed)
            return;
        // Update the item
        void removePrerequisite(this.node, id, this.application.item);
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        return {
            ...context,
            ...(await this.preparePrerequisitesContext()),
        };
    }
    async preparePrerequisitesContext() {
        // Get the prerequisites type select options
        const prerequisiteTypeSelectOptions = this.getPrerequisiteTypeSelectOptions();
        return {
            prerequisites: await Promise.all(this.node.prerequisites.map(this.preparePrerequisiteRuleContext.bind(this))),
            prerequisiteTypeSelectOptions,
        };
    }
    async preparePrerequisiteRuleContext(rule) {
        const prerequisiteTypeSelectOptions = this.getPrerequisiteTypeSelectOptions();
        return {
            ...rule,
            typeLabel: prerequisiteTypeSelectOptions[rule.type],
            ...(rule.type === "talent" /* TalentTree.Node.Prerequisite.Type.Talent */
                ? {
                    talents: await Promise.all(rule.talents.map(this.prepareRefContext.bind(this))),
                }
                : {}),
            ...(rule.type === "goal" /* TalentTree.Node.Prerequisite.Type.Goal */
                ? {
                    goals: await Promise.all(rule.goals.map(this.prepareRefContext.bind(this))),
                }
                : {}),
            ...(rule.type === "ancestry" /* TalentTree.Node.Prerequisite.Type.Ancestry */
                ? {
                    ancestry: await this.prepareRefContext(rule.ancestry),
                }
                : {}),
            ...(rule.type === "culture" /* TalentTree.Node.Prerequisite.Type.Culture */
                ? {
                    culture: await this.prepareRefContext(rule.culture),
                }
                : {}),
        };
    }
    async prepareRefContext(ref) {
        if (!ref)
            return ref;
        // Look up doc
        const doc = (await fromUuid(ref.uuid));
        return {
            ...ref,
            link: doc.toAnchor().outerHTML,
        };
    }
    /* --- Helpers --- */
    getRuleIdFromEvent(event) {
        // Find rule element
        const rule = $(event.currentTarget).closest('.rule[data-id]');
        return rule.data('id');
    }
    getPrerequisiteTypeSelectOptions() {
        return this.application.item.system.schema.getField('nodes._.prerequisites._.type').choices;
    }
}
// Register the component
NodePrerequisitesComponent.register('app-talent-tree-node-prerequisites');

// Component imports
class NodePrerequisiteTalentListComponent extends DragDropComponentMixin((HandlebarsApplicationComponent)) {
    static TEMPLATE = 'systems/cosmere-rpg/templates/item/talent-tree/components/prerequisite-talent-list.hbs';
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'remove-talent': this.onRemoveTalent,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    static DRAG_DROP = [
        {
            dropSelector: '*',
        },
    ];
    /* --- Accessors --- */
    get node() {
        return this.params.node;
    }
    get talents() {
        return this.params.talents;
    }
    /* --- Actions --- */
    static onRemoveTalent(event) {
        // Get talent element
        const el = $(event.currentTarget).closest('.talent');
        // Get id
        const id = el.data('id');
        // Remove talent
        this.talents.delete(id);
        // Dispatch change event
        this.element.dispatchEvent(new Event('change'));
        // Re-render
        void this.render();
    }
    /* --- Drag drop --- */
    _canDragDrop() {
        return true;
    }
    async _onDrop(event) {
        const data = TextEditor.getDragEventData(event);
        if (data.type !== 'Item')
            return;
        // Get document
        const item = (await fromUuid(data.uuid));
        // Check if document is a talent
        if (!item.isTalent())
            return;
        // Check if the talent is the same as the root talent
        if (item.system.id === this.node.talentId) {
            return ui.notifications.warn(game.i18n.localize('GENERIC.Warning.TalentCannotBePrerequisiteOfItself'));
        }
        // Check if a talent with the same ID is already in the list
        const duplicateRef = this.talents.find((ref) => ref.id === item.system.id);
        if (duplicateRef) {
            // Retrieve duplicate talent
            const duplicate = (await fromUuid(duplicateRef.uuid));
            // Show a warning
            return ui.notifications.warn(game.i18n.format('GENERIC.Warning.DuplicatePrerequisiteTalentRef', {
                talentId: duplicate.system.id,
                talentName: duplicate.name,
            }));
        }
        // Add talent to the list
        this.talents.set(item.system.id, {
            id: item.system.id,
            uuid: item.uuid,
            label: item.name,
        });
        // Dispatch change event
        this.element.dispatchEvent(new Event('change'));
        // Re-render
        void this.render();
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        // Construct content links
        const contentLinks = this.talents.map((ref) => `@UUID[${ref.uuid}]{${ref.label}}`);
        // Enrich links
        const enrichedLinks = await Promise.all(contentLinks.map((link) => TextEditor.enrichHTML(link)));
        return {
            ...params,
            talents: this.talents.map(({ id }, index) => ({
                id,
                link: enrichedLinks[index],
            })),
        };
    }
}
// Register the component
NodePrerequisiteTalentListComponent.register('app-node-prerequisite-talent-list');

// Component imports
class NodePrerequisiteGoalListComponent extends DragDropComponentMixin((HandlebarsApplicationComponent)) {
    static TEMPLATE = 'systems/cosmere-rpg/templates/item/talent-tree/components/prerequisite-goal-list.hbs';
    /**
     * NOTE: Unbound methods is the standard for defining actions
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static ACTIONS = {
        'remove-goal': this.onRemoveGoal,
    };
    /* eslint-enable @typescript-eslint/unbound-method */
    static DRAG_DROP = [
        {
            dropSelector: '*',
        },
    ];
    /* --- Accessors --- */
    get node() {
        return this.params.node;
    }
    get goals() {
        return this.params.goals;
    }
    /* --- Actions --- */
    static onRemoveGoal(event) {
        // Get goal element
        const el = $(event.currentTarget).closest('.goal');
        // Get id
        const id = el.data('id');
        // Remove goal
        this.goals.delete(id);
        // Dispatch change event
        this.element.dispatchEvent(new Event('change'));
        // Re-render
        void this.render();
    }
    /* --- Drag drop --- */
    _canDragDrop() {
        return true;
    }
    async _onDrop(event) {
        const data = TextEditor.getDragEventData(event);
        if (data.type !== 'Item')
            return;
        // Get document
        const item = (await fromUuid(data.uuid));
        // Check if document is a goal
        if (!item.isGoal())
            return;
        // Check if a goal with the same ID is already in the list
        const duplicateRef = this.goals.find((ref) => ref.id === item.system.id);
        if (duplicateRef) {
            // Retrieve duplicate goal
            const duplicate = (await fromUuid(duplicateRef.uuid));
            // Show a warning
            return ui.notifications.warn(game.i18n.format('GENERIC.Warning.DuplicatePrerequisiteGoalRef', {
                goalId: duplicate.system.id,
                goalName: duplicate.name,
            }));
        }
        // Add goal to the list
        this.goals.set(item.system.id, {
            id: item.system.id,
            uuid: item.uuid,
            label: item.name,
        });
        // Dispatch change event
        this.element.dispatchEvent(new Event('change'));
        // Re-render
        void this.render();
    }
    /* --- Context --- */
    async _prepareContext(params, context) {
        // Construct content links
        const contentLinks = this.goals.map((ref) => `@UUID[${ref.uuid}]{${ref.label}}`);
        // Enrich links
        const enrichedLinks = await Promise.all(contentLinks.map((link) => TextEditor.enrichHTML(link)));
        return {
            ...params,
            goals: this.goals.map(({ id }, index) => ({
                id,
                link: enrichedLinks[index],
            })),
        };
    }
}
// Register the component
NodePrerequisiteGoalListComponent.register('app-node-prerequisite-goal-list');

const { ItemSheetV2: ItemSheetV2$1 } = foundry.applications.sheets;
class BaseItemSheet extends TabsApplicationMixin(ComponentHandlebarsApplicationMixin(ItemSheetV2$1)) {
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        form: {
            handler: this.onFormEvent,
            submitOnChange: true,
        },
        actions: {
            'edit-description': this.editDescription,
            save: this.onSave,
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        description: {
            label: 'COSMERE.Item.Sheet.Tabs.Description',
            icon: '<i class="fa-solid fa-feather-pointed"></i>',
        },
        events: {
            label: 'COSMERE.Item.Sheet.Tabs.Events',
            icon: '<i class="fa-solid fa-eject"></i>',
        },
        effects: {
            label: 'COSMERE.Item.Sheet.Tabs.Effects',
            icon: '<i class="fa-solid fa-bolt"></i>',
        },
    });
    updatingDescription = false;
    proseDescName = '';
    proseDescHtml = '';
    expanded = false;
    get isUpdatingDescription() {
        return this.updatingDescription;
    }
    get item() {
        return super.document;
    }
    /* --- Form --- */
    static async onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        // Handle prose mirror saving via hotkey
        if (event.target.className.includes('prosemirror')) {
            await this.saveDescription();
        }
        if (!('name' in event.target))
            return;
        if (this.item.isPhysical() && 'system.price.unit' in formData.object) {
            // Get currency id
            const [currencyId, denominationId] = formData.object['system.price.unit'].split('.');
            // Remove the unit
            formData.delete('system.price.unit');
            // Get the currency
            const currency = CONFIG.COSMERE.currencies[currencyId];
            formData.set('system.price.currency', currency ? currencyId : NONE);
            if (currency) {
                // Get the primary denomination
                const primaryDenomination = currency.denominations.primary.find((denomination) => denomination.id === denominationId);
                formData.set('system.price.denomination.primary', primaryDenomination?.id ?? NONE);
            }
        }
        if (this.item.hasActivation()) {
            if ('system.activation.uses.type' in formData.object &&
                formData.object['system.activation.uses.type'] === NONE)
                formData.set('system.activation.uses', null);
            // Handle consumption
            const consumption = this.getUpdatedConsumption(formData);
            if (consumption.length === 0) {
                formData.set('system.activation.consume', null);
            }
            else {
                formData.set('system.activation.consume', consumption);
            }
        }
        if (this.item.hasDamage()) {
            if ('system.damage.formula' in formData.object &&
                formData.object['system.damage.formula'].trim() ===
                    '')
                formData.set('system.damage.formula', null);
            if ('system.damage.type' in formData.object &&
                formData.object['system.damage.type'] === NONE)
                formData.set('system.damage.type', null);
            if ('system.damage.skill' in formData.object &&
                formData.object['system.damage.skill'] === NONE)
                formData.set('system.damage.skill', null);
            if ('system.damage.attribute' in formData.object &&
                formData.object['system.damage.attribute'] === NONE)
                formData.set('system.damage.attribute', null);
        }
        if (this.item.hasAttack()) {
            if ('system.attack.range.unit' in formData.object &&
                formData.object['system.attack.range.unit'] === NONE)
                formData.set('system.attack.range', null);
        }
        if (this.item.hasTraits()) {
            const item = this.item;
            const object = formData.object;
            const traitsData = Object.entries(object).filter(([key]) => key.startsWith('system.traits'));
            const defaultValueTraitsData = traitsData.filter(([key]) => key.endsWith('.defaultValue'));
            defaultValueTraitsData.forEach(([key, defaultValue]) => {
                if (!defaultValue) {
                    formData.set(key, 0);
                }
            });
            const expertModifyValueTraitsData = traitsData.filter(([key]) => key.endsWith('.expertise.modifyValue'));
            expertModifyValueTraitsData.forEach(([key, modifiesValue]) => {
                // Get trait id
                const traitId = key
                    .replace('system.traits.', '')
                    .replace('.expertise.modifyValue', '');
                // Get the trait
                const trait = item.system.traits[traitId];
                if (modifiesValue) {
                    if (!trait.expertise?.value) {
                        // Get value
                        const value = trait.defaultValue;
                        formData.set(`system.traits.${traitId}.expertise.value`, value);
                        formData.set(`system.traits.${traitId}.expertise.toggleActive`, false);
                    }
                    else if (object[`system.traits.${traitId}.expertise.toggleActive`]) {
                        // Remove value
                        formData.set(`system.traits.${traitId}.expertise.value`, null);
                    }
                }
                else {
                    formData.set(`system.traits.${traitId}.expertise.value`, null);
                }
                // Remove modifyValue
                formData.delete(key);
            });
        }
        if (this.item.hasModality()) {
            // Get modality enabled
            const modalityEnabled = formData.get('modalityEnabled') === 'true';
            // Set modality
            if (modalityEnabled && this.item.system.modality === null) {
                formData.set('system.modality', '<id>');
            }
            else if (!modalityEnabled && this.item.system.modality !== null) {
                formData.set('system.modality', null);
            }
            // Remove modality enabled
            formData.delete('modalityEnabled');
        }
        // Update the document
        void this.item.update(formData.object);
    }
    async _renderFrame(options) {
        const frame = await super._renderFrame(options);
        const corners = await renderSystemTemplate(TEMPLATES.GENERAL_SHEET_CORNERS, {});
        $(frame).prepend(corners);
        const banners = await renderSystemTemplate(TEMPLATES.GENERAL_SHEET_BACKGROUND, {});
        $(frame).prepend(banners);
        return frame;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        let enrichedDescValue = undefined;
        let enrichedShortDescValue = undefined;
        let enrichedChatDescValue = undefined;
        if (this.item.hasDescription()) {
            enrichedDescValue = await this.enrichDescription(this.item.system.description.value);
            enrichedShortDescValue = await this.enrichDescription(this.item.system.description.short);
            enrichedChatDescValue = await this.enrichDescription(this.item.system.description.chat);
        }
        const expandDefaultSetting = game.settings?.get('cosmere-rpg', 'expandDescriptionByDefault') ??
            false;
        return {
            ...(await super._prepareContext(options)),
            item: this.item,
            systemFields: this.item.system.schema.fields,
            editable: this.isEditable,
            isUpdatingDescription: this.isUpdatingDescription,
            descHtml: enrichedDescValue,
            shortDescHtml: enrichedShortDescValue,
            chatDescHtml: enrichedChatDescValue,
            proseDescName: this.proseDescName,
            proseDescHtml: this.proseDescHtml,
            expandDefault: expandDefaultSetting,
            typeLabel: game
                .i18n.localize(`TYPES.Item.${this.item.type}`)
                .toLowerCase(),
        };
    }
    async enrichDescription(desc) {
        if (desc === CONFIG.COSMERE.items.types[this.item.type].desc_placeholder) {
            desc = game.i18n.localize(desc);
        }
        return await TextEditor.enrichHTML(desc, {
            relativeTo: this.document,
        });
    }
    /* --- Actions --- */
    static async editDescription(event) {
        event.stopPropagation();
        // Get description element
        const descElement = $(event.target).closest('[description-type]');
        // Get description type
        const proseDescType = descElement.attr('description-type');
        const item = this.item;
        // Gets the description to display based on the type found
        if (proseDescType === 'value') {
            this.proseDescHtml = item.system.description.value;
        }
        else if (proseDescType === 'short') {
            this.proseDescHtml = item.system.description.short;
        }
        else if (proseDescType === 'chat') {
            this.proseDescHtml = item.system.description.chat;
        }
        // Gets name for use in prose mirror
        this.proseDescName = 'system.description.' + proseDescType;
        // Switches to prose mirror
        this.updatingDescription = true;
        await this.render(true);
    }
    /**
     * Provide a static callback for the prose mirror save button
     */
    static async onSave() {
        await this.saveDescription();
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element)
            .find('.collapsible .header')
            .on('click', (event) => this.onClickCollapsible(event));
    }
    /* --- Event handlers --- */
    onClickCollapsible(event) {
        const target = event.currentTarget;
        target?.parentElement?.classList.toggle('expanded');
    }
    /* --- Helpers --- */
    /**
     * Helper to update the prose mirror edit state
     */
    async saveDescription() {
        // Switches back from prose mirror
        this.updatingDescription = false;
        await this.render(true);
    }
    /**
     * Helper to manage activation consumption changes
     */
    getUpdatedConsumption(formData) {
        const consumeData = new Map();
        const consumeFormKeys = Object.keys(formData.object).filter((k) => k.startsWith('system.activation.consume'));
        // Track removed options, to ensure a later key doesn't recreate
        // one that has already been intentionally untracked
        const removedOptions = [];
        consumeFormKeys.forEach((formKey) => {
            // Index can be empty, assuming there isn't an existing
            // consumption configured.
            const parts = /\[(\d*)\]\.(\w+)$/.exec(formKey);
            if (!parts || parts.length < 2) {
                console.error(`[${SYSTEM_ID}] Bad form key: ${formKey}`);
                return;
            }
            // Invalid or missing indices will always be sorted to the front,
            // without overwriting existing data.
            let i = parseInt(parts[1]);
            if (isNaN(i))
                i = -1;
            // Ignore form keys for options which have already been deleted
            if (removedOptions.includes(i)) {
                delete formData.object[formKey];
                return;
            }
            const existingConsumeData = consumeData.get(i) ?? {
                type: "resource" /* ItemConsumeType.Resource */,
                value: 0,
                resource: "foc" /* Resource.Focus */,
            };
            const dataKey = parts[2];
            // Parse actual value range from input text
            if (dataKey === 'value') {
                const newConsumeData = {
                    min: 0,
                    max: 0,
                };
                const valueInput = formData.get(formKey)?.toString() ?? '0';
                const valueParts = valueInput.split('-');
                if (valueParts.length === 1) {
                    const value = valueParts[0];
                    const isRange = value.endsWith('+');
                    const parsed = parseInt(value);
                    if (!isNaN(parsed)) {
                        newConsumeData.min = parsed;
                        newConsumeData.max = isRange ? -1 : parsed;
                    }
                }
                else {
                    const base = parseInt(valueParts[0]);
                    const cap = parseInt(valueParts[1]);
                    if (!isNaN(base)) {
                        newConsumeData.min = base;
                    }
                    if (!isNaN(cap)) {
                        newConsumeData.max = cap;
                    }
                    else {
                        newConsumeData.max = newConsumeData.min;
                    }
                }
                existingConsumeData[dataKey] = newConsumeData;
            }
            else {
                existingConsumeData[dataKey] = formData.get(formKey);
            }
            // Use "None" to remove entries,
            // otherwise we have a (theoretically) valid type, so use it.
            if (existingConsumeData.type === NONE ||
                (existingConsumeData.type === "resource" /* ItemConsumeType.Resource */ &&
                    existingConsumeData.resource === NONE)) {
                consumeData.delete(i);
                removedOptions.push(i);
            }
            else {
                consumeData.set(i, existingConsumeData);
            }
            // Clean up form data to remove the old keys
            delete formData.object[formKey];
        });
        return [...consumeData.entries()]
            .sort(([a], [b]) => {
            return a - b;
        })
            .map(([_, v]) => v);
    }
}

class CultureItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'culture'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_BASE_CONTENT}`,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

// Components
function TalentsTabMixin(base) {
    return class mixin extends base {
        static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
            talents: {
                label: 'COSMERE.Item.Sheet.Tabs.Talents',
                icon: '<i class="fa-solid fa-sitemap"></i>',
                sortIndex: 14,
            },
        });
        get talentTreeViewComponent() {
            return Object.values(this.components).find((component) => component instanceof TalentTreeViewComponent);
        }
        /* --- Lifecycle --- */
        _onFirstRender(context, options) {
            super._onFirstRender(context, options);
            // Invoke on tab change
            void this.onTabChange();
        }
        async onTabChange() {
            if (this.tab === 'talents') {
                // Look up talent tree
                const talentTree = this.item.system.talentTree
                    ? (await fromUuid(this.item.system.talentTree))
                    : undefined;
                if (!talentTree)
                    return;
                // Set position
                this.setPosition({
                    width: talentTree.system.display.width
                        ? Math.max(talentTree.system.display.width + 41, 550)
                        : this.position.width,
                    height: talentTree.system.display.height
                        ? talentTree.system.display.height + 170
                        : 'auto',
                });
                setTimeout(() => {
                    this.talentTreeViewComponent.element.style.height =
                        talentTree.system.display.height
                            ? `${talentTree.system.display.height}px`
                            : 'auto';
                    void this.talentTreeViewComponent.resize();
                });
            }
            else {
                // Set position
                this.setPosition({
                    width: 550,
                    height: 'auto',
                });
            }
        }
        /* --- Context --- */
        async _prepareContext(options) {
            // Get context actor
            const contextActor = this.item.actor?.isCharacter()
                ? this.item.actor
                : undefined;
            // Look up talent tree
            const talentTree = this.item.system.talentTree
                ? (await fromUuid(this.item.system.talentTree))
                : undefined;
            return {
                ...(await super._prepareContext(options)),
                talentTree,
                contextActor,
            };
        }
    };
}

// Base
class AncestrySheet extends TalentsTabMixin(BaseItemSheet) {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'ancestry'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_ANCESTRY_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        // Check if the ancestry has a talent tree set
        const hasTalentTree = this.item.system.talentTree !== null;
        // Enable the talents tab if the ancestry has a talent tree set
        this.tabs.talents.enabled = hasTalentTree;
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

// Base
class PathItemSheet extends TalentsTabMixin(BaseItemSheet) {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'path'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_PATH_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
}

class ConnectionItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'connection'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_BASE_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

class InjuryItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'injury'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_INJURY_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
            isPermanent: this.item.system.type === "permanent_injury" /* InjuryType.PermanentInjury */ ||
                this.item.system.type === "death" /* InjuryType.Death */,
        };
    }
}

class SpecialtyItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'specialty'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_SPECIALTY_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

class LootItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'loot'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_LOOT_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

class ArmorItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'armor'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_ARMOR_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

class TraitItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'trait'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_BASE_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

class ActionItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'action'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_ACTION_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

class TalentItemSheet extends BaseItemSheet {
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'talent'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
        form: {
            handler: this.onFormEvent,
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_TALENT_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Form --- */
    static async onFormEvent(event, form, formData) {
        if ('system.path' in formData.object &&
            formData.object['system.path'] === '')
            formData.set('system.path', null);
        // Invoke super
        await super.onFormEvent(event, form, formData);
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
            isPathTalent: this.item.system.type === "path" /* Talent.Type.Path */,
            isAncestryTalent: this.item.system.type === "ancestry" /* Talent.Type.Ancestry */,
            isPowerTalent: this.item.system.type === "power" /* Talent.Type.Power */,
            hasModality: this.item.system.modality !== null,
        };
    }
}

class EquipmentItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'equipment'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_BASE_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

class WeaponItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'weapon'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_BASE_CONTENT}`,
            scrollable: ['.scroll-container'],
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

class GoalItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'armor'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_GOAL_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

class PowerItemSheet extends BaseItemSheet {
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'armor'],
        position: {
            width: 550,
        },
        window: {
            resizable: false,
            positioned: true,
        },
    });
    static TABS = foundry.utils.mergeObject(foundry.utils.deepClone(super.TABS), {
        details: {
            label: 'COSMERE.Item.Sheet.Tabs.Details',
            icon: '<i class="fa-solid fa-circle-info"></i>',
            sortIndex: 15,
        },
    });
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        content: {
            template: `systems/${SYSTEM_ID}/templates/${TEMPLATES.ITEM_POWER_CONTENT}`,
        },
    });
    get item() {
        return super.document;
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
        };
    }
}

// AppV2
const { ItemSheetV2 } = foundry.applications.sheets;
const DEFAULT_WIDTH = 800;
const DEFAULT_HEIGHT = 650;
class TalentTreeItemSheet extends EditModeApplicationMixin(ComponentHandlebarsApplicationMixin(ItemSheetV2)) {
    /**
     * NOTE: Unbound methods is the standard for defining actions and forms
     * within ApplicationV2
     */
    /* eslint-disable @typescript-eslint/unbound-method */
    static DEFAULT_OPTIONS = foundry.utils.mergeObject(foundry.utils.deepClone(super.DEFAULT_OPTIONS), {
        classes: [SYSTEM_ID, 'sheet', 'item', 'talent-tree'],
        window: {
            positioned: true,
            resizable: true,
        },
        actions: {
        // configure: this.onConfigure,
        },
        form: {
            handler: this.onFormEvent,
            submitOnChange: true,
        },
    });
    /* eslint-enable @typescript-eslint/unbound-method */
    static PARTS = foundry.utils.mergeObject(foundry.utils.deepClone(super.PARTS), {
        'sheet-content': {
            template: 'systems/cosmere-rpg/templates/item/talent-tree/parts/sheet-content.hbs',
        },
    });
    _contextActor;
    prevWidth = 0;
    prevHeight = 0;
    constructor(options) {
        const tree = options.document;
        const mode = tree.getFlag(SYSTEM_ID, 'sheet.mode') ?? 'view';
        // Override options
        options = foundry.utils.mergeObject(options, {
            window: {
                title: tree.name,
            },
            position: {
                width: (tree.system.display.width ?? DEFAULT_WIDTH) +
                    (mode === 'edit' ? EDIT_MENU_WIDTH : 0),
                height: tree.system.display.height ?? DEFAULT_HEIGHT,
            },
        });
        // Call parent constructor
        super(options);
        // Get all characters owned by the current user
        const characters = game.actors.filter((actor) => actor.isCharacter() &&
            actor.testUserPermission(game.user, 'OWNER'));
        // Get user character
        const userCharacter = game.user.character;
        if (userCharacter || characters.length === 1)
            this._contextActor = userCharacter ?? characters[0];
        // Assign previous width and height
        this.prevWidth = options.position.width;
        this.prevHeight = options.position.height;
    }
    /* --- Form --- */
    static async onFormEvent(event, form, formData) {
        if (event instanceof SubmitEvent)
            return;
        if (!('name' in event.target))
            return;
        if ('system.background.img' in formData.object &&
            formData.object['system.background.img'] !==
                this.item.system.background.img) {
            const texture = (await loadTexture(formData.object['system.background.img']));
            if (texture) {
                // Set width and height
                formData.set('system.background.width', texture.width);
                formData.set('system.background.height', texture.height);
            }
        }
        if ('node.position.x' in formData.object ||
            'node.position.y' in formData.object) {
            const posX = formData.get('node.position.x');
            const posY = formData.get('node.position.y');
            // Remove
            formData.delete('node.position.x');
            formData.delete('node.position.y');
            // Get selected node
            const selected = this.talentTreeViewComponent
                .selected;
            // Add updates
            formData.set(`system.nodes.${selected.id}.position.x`, posX);
            formData.set(`system.nodes.${selected.id}.position.y`, posY);
        }
        // Update the document
        void this.item.update(formData.object);
    }
    /* --- Accessors --- */
    get item() {
        return super.document;
    }
    get contextActor() {
        return this._contextActor;
    }
    get talentTreeViewComponent() {
        return Object.values(this.components).find((component) => component instanceof TalentTreeViewComponent);
    }
    /* --- Lifecycle --- */
    _onRender(context, options) {
        super._onRender(context, options);
        $(this.element)
            .find('.collapsible .header')
            .on('click', (event) => this.onClickCollapsible(event));
    }
    async _renderFrame(options) {
        const frame = await super._renderFrame(options);
        // Get all characters owned by the current user
        const characters = game.actors.filter((actor) => actor.isCharacter() &&
            actor.testUserPermission(game.user, 'OWNER'));
        // Get user character
        const userCharacter = game.user.character;
        if (characters.length > 1) {
            $(this.window.title).after(`
                <div class="actor-select">
                    <label>${game.i18n.localize('Actor')}</label>
                    <select>
                        <option value="none" ${!userCharacter ? 'selected' : ''}>${game.i18n.localize('GENERIC.None')}</option>
                        ${characters
                .map((actor) => `
                                <option value="${actor.id}" ${userCharacter?.id === actor.id ? 'selected' : ''}>
                                    ${actor.name}
                                </option>
                            `)
                .join('\n')}
                    </select>
                </div>
            `);
        }
        // Bind to select
        $(this.window.title)
            .parent()
            .find('.actor-select select')
            .on('change', (event) => {
            // Get selected actor
            const actorId = $(event.target).val();
            // Get actor
            const actor = actorId === 'none'
                ? undefined
                : game.actors.get(actorId);
            // Set context actor
            this._contextActor = actor;
            // Render
            void this.render(true);
        });
        if (this.contextActor) {
            $(frame).addClass('actor-selected');
        }
        return frame;
    }
    _onPosition(options) {
        super._onPosition(options);
        // Check if size has changed
        const sizeChanged = this.prevWidth !== this.position.width ||
            this.prevHeight !== this.position.height;
        if (!sizeChanged)
            return;
        // Update previous width and height
        this.prevWidth = this.position.width;
        this.prevHeight = this.position.height;
        // Resize
        void this.talentTreeViewComponent.resize();
    }
    _onModeChange() {
        this.setPosition({
            width: this.position.width +
                (this.isEditMode ? EDIT_MENU_WIDTH : -EDIT_MENU_WIDTH),
        });
    }
    /* --- Event handlers --- */
    onClickCollapsible(event) {
        const target = event.currentTarget;
        target?.parentElement?.classList.toggle('expanded');
    }
    /* --- Context --- */
    async _prepareContext(options) {
        return {
            ...(await super._prepareContext(options)),
            item: this.item,
            isEditMode: this.isEditMode,
            editable: this.isEditable,
            contextActor: this._contextActor,
        };
    }
}

// Constants
/**
 * Overrides default tracker template to implement slow/fast buckets and combatant activation button.
 */
class CosmereCombatTracker extends CombatTracker {
    get template() {
        return `systems/${SYSTEM_ID}/templates/${TEMPLATES.COMBAT_TRACKER}`;
    }
    /**
     *  modifies data being sent to the combat tracker template to add turn speed, type and activation status and splitting turns between the initiative phases.
     */
    async getData(options) {
        const data = (await super.getData(options));
        // Add combatant type, speed, and activation status to existing turn data
        data.turns = data.turns.flatMap((turn, i) => {
            const combatant = this.viewed.turns[i];
            // Prepare turn data
            const newTurn = {
                ...turn,
                turnSpeed: combatant.turnSpeed,
                type: combatant.actor.type,
                activated: combatant.activated,
                isBoss: combatant.isBoss,
                bossFastActivated: combatant.bossFastActivated,
            };
            // Strip active player formatting
            newTurn.css = '';
            // provide current turn for non-boss combatants
            return newTurn;
        });
        //split turn data into individual turn "buckets" to separate them in the combat tracker ui
        data.fastPlayers = data.turns.filter((turn) => {
            return (turn.type === "character" /* ActorType.Character */ &&
                turn.turnSpeed === "fast" /* TurnSpeed.Fast */);
        });
        data.slowPlayers = data.turns.filter((turn) => {
            return (turn.type === "character" /* ActorType.Character */ &&
                turn.turnSpeed === "slow" /* TurnSpeed.Slow */);
        });
        data.fastNPC = data.turns.filter((turn) => {
            return (turn.type === "adversary" /* ActorType.Adversary */ &&
                turn.turnSpeed === "fast" /* TurnSpeed.Fast */);
        });
        data.slowNPC = data.turns.filter((turn) => {
            return (turn.type === "adversary" /* ActorType.Adversary */ &&
                turn.turnSpeed === "slow" /* TurnSpeed.Slow */);
        });
        return data;
    }
    /**
     * add listeners to toggleTurnSpeed and activation buttons
     */
    activateListeners(html) {
        super.activateListeners(html);
        html.find(`[data-control='toggleSpeed']`).on('click', this._onClickToggleTurnSpeed.bind(this));
        html.find(`[data-control='activateCombatant']`).on('click', this._onActivateCombatant.bind(this));
    }
    /**
     * toggles combatant turn speed on clicking the "fast/slow" button on the combat tracker window
     * */
    _onClickToggleTurnSpeed(event) {
        event.preventDefault();
        event.stopPropagation();
        // Get the button and the closest combatant list item
        const btn = event.currentTarget;
        const li = btn.closest('.combatant');
        // Get the combatant
        const combatant = this.viewed.combatants.get(li.dataset.combatantId);
        // Toggle the combatant's turn speed
        void combatant.toggleTurnSpeed();
    }
    /**
     *  activates the combatant when clicking the activation button
     */
    _onActivateCombatant(event) {
        event.preventDefault();
        event.stopPropagation();
        // Get the button and the closest combatant list item
        const btn = event.currentTarget;
        const li = btn.closest('.combatant');
        // Get the combatant
        const combatant = this.viewed.combatants.get(li.dataset.combatantId);
        // Mark the combatant as activated
        void combatant.markActivated(combatant.isBoss && li.dataset.phase === "fast" /* TurnSpeed.Fast */);
    }
    /**
     * toggles combatant turn speed on clicking the "fast/slow" option in the turn tracker context menu
     */
    _onContextToggleTurnSpeed(li) {
        // Get the combatant from the list item
        const combatant = this.viewed.combatants.get(li.data('combatant-id'));
        // Toggle the combatant's turn speed
        void combatant.toggleTurnSpeed();
    }
    /**
     * resets combatants activation status to hasn't activated
     */
    _onContextResetActivation(li) {
        // Get the combatant from the list item
        const combatant = this.viewed.combatants.get(li.data('combatant-id'));
        // Reset the combatant's activation status
        void combatant.resetActivation();
    }
    /**
     * Overwrites combatants context menu options, adding toggle turn speed and reset activation options. Removes initiative rolling options from base implementation.
     */
    _getEntryContextOptions() {
        const menu = [
            {
                name: 'COSMERE.Combat.ToggleTurn',
                icon: '',
                callback: this._onContextToggleTurnSpeed.bind(this),
            },
            {
                name: 'COSMERE.Combat.ResetActivation',
                icon: '<i class="fas fa-undo"></i>',
                callback: this._onContextResetActivation.bind(this),
            },
        ];
        //pushes existing context menu options, filtering out the initiative reroll and initiative clear options
        menu.push(...super
            ._getEntryContextOptions()
            .filter((i) => i.name !== 'COMBAT.CombatantReroll' &&
            i.name !== 'COMBAT.CombatantClear'));
        return menu;
    }
}

class AdversaryActorDataModel extends CommonActorDataModel {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            role: new foundry.data.fields.StringField({
                required: true,
                nullable: false,
                blank: false,
                initial: "minion" /* AdversaryRole.Minion */,
                choices: Object.keys(CONFIG.COSMERE.adversary.roles),
            }),
        });
    }
}

const config$2 = {
    ["character" /* ActorType.Character */]: CharacterActorDataModel,
    ["adversary" /* ActorType.Adversary */]: AdversaryActorDataModel,
};

function TypedItemMixin(options = {}) {
    return (base) => {
        return class extends base {
            static defineSchema() {
                const initial = typeof options.initial === 'function'
                    ? options.initial()
                    : options.initial;
                const choices = typeof options.choices === 'function'
                    ? options.choices()
                    : options.choices;
                return foundry.utils.mergeObject(super.defineSchema(), {
                    type: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        initial: initial ?? 'unknown',
                        label: 'Type',
                        choices,
                    }),
                });
            }
            get typeSelectOptions() {
                let choices = this.schema.fields.type.choices;
                if (choices instanceof Function)
                    choices = choices();
                if (Array.isArray(choices)) {
                    return choices.reduce((acc, key, i) => ({
                        ...acc,
                        [i]: key,
                    }), {});
                }
                else {
                    return choices;
                }
            }
            get typeLabel() {
                const options = this.typeSelectOptions;
                return options[this.type] ?? this.type;
            }
        };
    };
}

function EquippableItemMixin(options = {}) {
    return (base) => {
        return class mixin extends base {
            static defineSchema() {
                const equipTypeInitial = typeof options.equipType?.initial === 'function'
                    ? options.equipType.initial()
                    : (options.equipType?.initial ?? "wear" /* EquipType.Wear */);
                const equipTypeChoices = typeof options.equipType?.choices === 'function'
                    ? options.equipType.choices()
                    : (options.equipType?.choices ??
                        Object.keys(CONFIG.COSMERE.items.equip.types));
                return foundry.utils.mergeObject(super.defineSchema(), {
                    equipped: new foundry.data.fields.BooleanField({
                        required: true,
                        nullable: false,
                        initial: false,
                        label: 'Equipped',
                    }),
                    alwaysEquipped: new foundry.data.fields.BooleanField({
                        nullable: true,
                    }),
                    equip: new foundry.data.fields.SchemaField({
                        type: new foundry.data.fields.StringField({
                            required: true,
                            nullable: false,
                            initial: equipTypeInitial,
                            choices: equipTypeChoices,
                        }),
                        hold: new foundry.data.fields.StringField({
                            nullable: true,
                            choices: Object.keys(CONFIG.COSMERE.items.equip.hold),
                        }),
                        hand: new foundry.data.fields.StringField({
                            nullable: true,
                            choices: Object.keys(CONFIG.COSMERE.items.equip.hand),
                        }),
                    }),
                });
            }
            prepareDerivedData() {
                super.prepareDerivedData();
                if (this.alwaysEquipped) {
                    this.equipped = true;
                }
            }
        };
    };
}

class StringField extends foundry.data.fields.StringField {
    constructor(options, context) {
        super(options, context);
    }
    clean(value, options) {
        if (this.options.coerce)
            value = this.options.coerce(value);
        return super.clean(value, options);
    }
}

function ActivatableItemMixin(options) {
    if (options?.skill?.allowDefault && !options.skill.defaultResolver) {
        throw new Error('ActivatableItemMixin: If allowDefaultSkill is true, defaultSkillResolver must be provided.');
    }
    return (base) => {
        return class mixin extends base {
            static defineSchema() {
                return foundry.utils.mergeObject(super.defineSchema(), {
                    activation: new ActivationField({
                        required: true,
                        ...options,
                    }),
                });
            }
            prepareDerivedData() {
                super.prepareDerivedData();
                // Ensure that the uses value is within the min/max bounds
                if (this.activation.uses) {
                    if (this.activation.uses.max != null) {
                        this.activation.uses.value = Math.max(0, Math.min(this.activation.uses.max, this.activation.uses.value));
                    }
                }
            }
        };
    };
}
class ActivationField extends foundry.data.fields.SchemaField {
    model;
    constructor(options, context) {
        // Get the activation data model class based on the options provided
        const cls = getActivationDataModelCls(options);
        // Call the parent constructor with the defined schema and options
        super(cls.defineSchema(), options, context);
        // Assign the model class
        this.model = cls;
    }
    _cast(value) {
        return typeof value === 'object' ? value : {};
    }
    initialize(value, model, options) {
        return new this.model(foundry.utils.deepClone(value), {
            parent: model,
            ...options,
        });
    }
}
class Activation extends foundry.abstract.DataModel {
    static defineSchema() {
        return {
            type: new foundry.data.fields.StringField({
                required: true,
                blank: false,
                initial: "none" /* ActivationType.None */,
                choices: Object.entries(CONFIG.COSMERE.items.activation.types).reduce((acc, [key, config]) => ({
                    ...acc,
                    [key]: config.label,
                }), {}),
                label: 'COSMERE.Item.Sheet.Activation.Type',
            }),
            cost: new foundry.data.fields.SchemaField({
                value: new foundry.data.fields.NumberField({
                    nullable: true,
                    min: 0,
                    max: 3,
                    step: 1,
                    integer: true,
                }),
                type: new StringField({
                    nullable: true,
                    choices: {
                        '': 'GENERIC.None',
                        ...Object.entries(CONFIG.COSMERE.action.costs).reduce((acc, [key, config]) => ({
                            ...acc,
                            [key]: config.label,
                        }), {}),
                    },
                    coerce: (value) => value === '' ? null : value,
                }),
            }, {
                required: true,
                label: 'COSMERE.Item.Sheet.Activation.Cost',
            }),
            consume: new foundry.data.fields.ArrayField(new foundry.data.fields.SchemaField({
                type: new StringField({
                    required: true,
                    nullable: false,
                    choices: {
                        [NONE]: 'GENERIC.None',
                        ...Object.entries(CONFIG.COSMERE.items.activation
                            .consumeTypes).reduce((acc, [key, config]) => ({
                            ...acc,
                            [key]: config.label,
                        }), {}),
                    },
                    initial: "resource" /* ItemConsumeType.Resource */,
                }),
                value: new foundry.data.fields.SchemaField({
                    min: new foundry.data.fields.NumberField({
                        required: true,
                        nullable: false,
                        min: 0,
                        integer: true,
                        initial: 0,
                    }),
                    max: new foundry.data.fields.NumberField({
                        required: true,
                        nullable: false,
                        min: -1,
                        integer: true,
                        initial: 0,
                    }),
                    actual: new foundry.data.fields.NumberField({
                        required: false,
                        nullable: false,
                        min: 0,
                        integer: true,
                        initial: 0,
                    }),
                }),
                resource: new foundry.data.fields.StringField({
                    blank: false,
                    choices: Object.entries(CONFIG.COSMERE.resources).reduce((acc, [key, config]) => ({
                        ...acc,
                        [key]: config.label,
                    }), {}),
                    initial: "foc" /* Resource.Focus */,
                }),
            }, {
                required: false,
                nullable: true,
                initial: null,
            }), {
                label: 'COSMERE.Item.Sheet.Activation.Consume',
            }),
            flavor: new foundry.data.fields.HTMLField(),
            skill: new StringField({
                nullable: true,
                choices: {
                    '': 'GENERIC.None',
                    ...Object.entries(CONFIG.COSMERE.skills).reduce((acc, [key, config]) => ({
                        ...acc,
                        [key]: config.label,
                    }), {}),
                },
                coerce: (value) => (value === '' ? null : value),
                label: 'GENERIC.Skill',
            }),
            attribute: new StringField({
                nullable: true,
                initial: 'default',
                choices: {
                    '': 'GENERIC.None',
                    default: 'GENERIC.Default',
                    ...Object.entries(CONFIG.COSMERE.attributes).reduce((acc, [key, config]) => ({
                        ...acc,
                        [key]: config.label,
                    }), {}),
                },
                coerce: (value) => (value === '' ? null : value),
                label: 'GENERIC.Attribute',
            }),
            modifierFormula: new foundry.data.fields.StringField({
                nullable: true,
                blank: true,
                label: 'COSMERE.Item.Sheet.Activation.AdditionalFormula',
                hint: 'COSMERE.Item.Sheet.Activation.AdditionalFormulaDescription',
            }),
            plotDie: new foundry.data.fields.BooleanField({
                nullable: true,
                initial: false,
                label: 'DICE.Plot.RaiseTheStakes',
            }),
            opportunity: new foundry.data.fields.NumberField({
                nullable: true,
                min: 1,
                max: 20,
                integer: true,
                label: 'COSMERE.Item.Activation.Opportunity',
            }),
            complication: new foundry.data.fields.NumberField({
                nullable: true,
                min: 1,
                max: 20,
                integer: true,
                label: 'COSMERE.Item.Activation.Complication',
            }),
            uses: new foundry.data.fields.SchemaField({
                type: new StringField({
                    required: true,
                    initial: "use" /* ItemUseType.Use */,
                    blank: false,
                    choices: Object.entries(CONFIG.COSMERE.items.activation.uses.types).reduce((acc, [key, config]) => ({
                        ...acc,
                        [key]: config.label,
                    }), {}),
                }),
                value: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    min: 0,
                    initial: 1,
                    integer: true,
                }),
                max: new foundry.data.fields.NumberField({
                    required: true,
                    min: 1,
                    initial: 1,
                    integer: true,
                }),
                recharge: new StringField({
                    nullable: true,
                    initial: null,
                    choices: {
                        '': 'GENERIC.None',
                        ...Object.entries(CONFIG.COSMERE.items.activation.uses.recharge).reduce((acc, [key, config]) => ({
                            ...acc,
                            [key]: config.label,
                        }), {}),
                    },
                    coerce: (value) => value === '' ? null : value,
                    label: 'COSMERE.Item.Sheet.Activation.Recharge',
                }),
            }, {
                required: false,
                nullable: true,
                initial: null,
                label: 'COSMERE.Item.Sheet.Activation.Uses',
            }),
        };
    }
    /* --- Accessors --- */
    /**
     * Returns the resolved skill for the activation.
     * Cleans the configured value to return a valid skill id or null.
     */
    get resolvedSkill() {
        // If no skill is configured, return null
        if (!this.skill || this.skill === 'none')
            return null;
        // If the skill is configured, check if it is a valid skill
        if (!(this.skill in CONFIG.COSMERE.skills))
            return null;
        // Return the skill id
        return this.skill;
    }
    /**
     * Returns the resolved attribute for the activation.
     * Cleans the configured value to return a valid attribute or null.
     */
    get resolvedAttribute() {
        if (!this.attribute)
            return null;
        // Get the resolved skill
        const skillId = this.resolvedSkill;
        if (!skillId)
            return null; // If no skill is configured, never return an attribute
        switch (this.attribute) {
            case 'default':
                // If the attribute is 'default', return the default attribute for the skill
                return CONFIG.COSMERE.skills[skillId].attribute;
            case 'none':
                // If the attribute is 'none', return null
                return null;
            default:
                // Ensure that the attribute is a valid attribute
                if (!(this.attribute in CONFIG.COSMERE.attributes))
                    return null;
                // Return the attribute id
                return this.attribute;
        }
    }
}
function getActivationDataModelCls(options) {
    return class extends Activation {
        static defineSchema() {
            const schema = super.defineSchema();
            if (options?.type?.initial) {
                schema.type.options.initial = options.type.initial;
                schema.type.initial = options.type.initial;
            }
            if (options?.skill?.initial) {
                schema.skill.options.initial = options.skill.initial;
                schema.skill.initial = options.skill.initial;
            }
            if (options?.skill?.allowDefault) {
                schema.skill.options.choices = [
                    ['', 'GENERIC.None'],
                    ['default', 'GENERIC.Default'],
                    ...Object.entries(foundry.utils.getProperty(schema, 'skill.options.choices')).filter(([key]) => key !== ''),
                ].reduce((acc, [key, label]) => ({
                    ...acc,
                    [key]: label,
                }), {});
                schema.skill.choices = schema.skill.options.choices;
            }
            return schema;
        }
        /* --- Accessors --- */
        get resolvedSkill() {
            if (options?.skill?.allowDefault && this.skill === 'default') {
                // If the skill is set to 'default', use the default resolver
                return options.skill.defaultResolver.call(this.parent) ?? null;
            }
            else {
                // Otherwise, use the base implementation
                return super.resolvedSkill;
            }
        }
    };
}

function AttackingItemMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                return foundry.utils.mergeObject(super.defineSchema(), {
                    attack: new foundry.data.fields.SchemaField({
                        type: new foundry.data.fields.StringField({
                            required: true,
                            nullable: false,
                            initial: "melee" /* AttackType.Melee */,
                            choices: Object.entries(CONFIG.COSMERE.attack.types).reduce((acc, [key, config]) => ({
                                ...acc,
                                [key]: config.label,
                            }), {}),
                        }),
                        range: new foundry.data.fields.SchemaField({
                            value: new foundry.data.fields.NumberField({
                                min: 0,
                            }),
                            long: new foundry.data.fields.NumberField({
                                min: 0,
                            }),
                            unit: new foundry.data.fields.StringField(),
                        }, { required: false, nullable: true }),
                    }),
                });
            }
        };
    };
}

function DamagingItemMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                return foundry.utils.mergeObject(super.defineSchema(), {
                    damage: new foundry.data.fields.SchemaField({
                        formula: new foundry.data.fields.StringField({
                            nullable: true,
                            blank: false,
                        }),
                        grazeOverrideFormula: new foundry.data.fields.StringField({
                            nullable: true,
                        }),
                        type: new foundry.data.fields.StringField({
                            nullable: true,
                            choices: Object.keys(CONFIG.COSMERE.damageTypes),
                        }),
                        skill: new foundry.data.fields.StringField({
                            nullable: true,
                            choices: Object.keys(CONFIG.COSMERE.skills),
                        }),
                        attribute: new foundry.data.fields.StringField({
                            nullable: true,
                            choices: Object.keys(CONFIG.COSMERE.attributes),
                        }),
                    }),
                });
            }
        };
    };
}

/**
 * Mixin for weapon & armor traits
 */
function TraitsItemMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                const superSchema = super.defineSchema();
                if (!('expertise' in superSchema)) {
                    throw new Error('TraitsItemMixin must be used in combination with ExpertiseItemMixin and must follow it');
                }
                return foundry.utils.mergeObject(super.defineSchema(), {
                    traits: new MappingField(new foundry.data.fields.SchemaField({
                        defaultValue: new foundry.data.fields.NumberField({
                            integer: true,
                        }),
                        value: new foundry.data.fields.NumberField({
                            integer: true,
                        }),
                        defaultActive: new foundry.data.fields.BooleanField({
                            required: true,
                            nullable: false,
                            initial: true,
                        }),
                        active: new foundry.data.fields.BooleanField({
                            required: true,
                            nullable: false,
                            initial: true,
                        }),
                        expertise: new foundry.data.fields.SchemaField({
                            toggleActive: new foundry.data.fields.BooleanField(),
                            value: new foundry.data.fields.NumberField({
                                integer: true,
                            }),
                        }),
                    })),
                });
            }
            get traitsArray() {
                return Object.entries(this.traits)
                    .map(([id, trait]) => ({ id, ...trait }))
                    .sort((a, b) => a.id.localeCompare(b.id));
            }
            prepareDerivedData() {
                super.prepareDerivedData();
                // Do we have expertise
                const hasExpertise = this.expertise;
                Object.values(this.traits).forEach((trait) => {
                    if (!hasExpertise) {
                        trait.active = trait.defaultActive;
                        trait.value = trait.defaultValue;
                    }
                    else {
                        trait.active = trait.expertise.toggleActive
                            ? !trait.defaultActive
                            : trait.defaultActive;
                        trait.value =
                            trait.expertise.value ?? trait.defaultValue;
                    }
                });
            }
        };
    };
}

function PhysicalItemMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                return foundry.utils.mergeObject(super.defineSchema(), {
                    quantity: new foundry.data.fields.NumberField({
                        min: 0,
                        initial: 1,
                        integer: true,
                    }),
                    weight: new foundry.data.fields.SchemaField({
                        value: new foundry.data.fields.NumberField({
                            min: 0,
                            initial: 0,
                            required: true,
                        }),
                        unit: new foundry.data.fields.StringField({
                            required: true,
                            initial: CONFIG.COSMERE.units.weight[0],
                            choices: CONFIG.COSMERE.units.weight,
                        }),
                    }),
                    price: new foundry.data.fields.SchemaField({
                        value: new foundry.data.fields.NumberField({
                            min: 0,
                            initial: 0,
                            required: true,
                        }),
                        currency: new foundry.data.fields.StringField({
                            required: true,
                            initial: 'none',
                            choices: {
                                none: game.i18n.localize('GENERIC.None'),
                                ...Object.entries(CONFIG.COSMERE.currencies).reduce((acc, [id, currency]) => ({
                                    ...acc,
                                    [id]: currency.label,
                                }), {}),
                            },
                        }),
                        denomination: new foundry.data.fields.SchemaField({
                            primary: new foundry.data.fields.StringField({
                                required: true,
                                initial: 'none',
                                choices: {
                                    none: game.i18n.localize('GENERIC.None'),
                                    ...Object.entries(CONFIG.COSMERE.currencies).reduce((acc, [currencyId, currency]) => ({
                                        ...acc,
                                        ...currency.denominations.primary.reduce((acc, denomination) => ({
                                            ...acc,
                                            [denomination.id]: denomination.label,
                                        }), {}),
                                    }), {}),
                                },
                            }),
                            secondary: new foundry.data.fields.StringField({
                                required: false,
                                initial: 'none',
                                choices: {
                                    none: game.i18n.localize('GENERIC.None'),
                                    ...Object.entries(CONFIG.COSMERE.currencies)
                                        .filter(([_, currency]) => currency.denominations
                                        .secondary)
                                        .reduce((acc, [currencyId, currency]) => ({
                                        ...acc,
                                        ...currency.denominations.secondary.reduce((acc, denomination) => ({
                                            ...acc,
                                            [denomination.id]: denomination.label,
                                        }), {}),
                                    }), {}),
                                },
                            }),
                        }),
                        unit: new foundry.data.fields.StringField(),
                    }),
                });
            }
            prepareDerivedData() {
                super.prepareDerivedData();
                if (this.price.currency === 'none' ||
                    this.price.denomination.primary === 'none') {
                    this.price.unit = '—';
                    this.price.baseValue = this.price.value;
                }
                else {
                    const currency = CONFIG.COSMERE.currencies[this.price.currency];
                    const primary = currency.denominations.primary.find((denomination) => denomination.id === this.price.denomination.primary);
                    const secondary = currency.denominations.secondary?.find((denomination) => denomination.id ===
                        this.price.denomination.secondary);
                    // Set unit
                    this.price.unit = `${this.price.currency}.${primary.id}`;
                    // Calculate base value
                    this.price.baseValue =
                        this.price.value *
                            primary.conversionRate *
                            (secondary ? secondary.conversionRate : 1);
                }
            }
        };
    };
}

function ExpertiseItemMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                const superSchema = super.defineSchema();
                // Ensure schema contains id (id mixin was used)
                if (!('id' in superSchema)) {
                    throw new Error('ExpertiseItemMixin must be used in combination with IdItemMixin');
                }
                return foundry.utils.mergeObject(super.defineSchema(), {
                    expertise: new foundry.data.fields.BooleanField({
                        required: true,
                        nullable: false,
                        initial: false,
                        label: 'Expertise',
                    }),
                });
            }
            prepareDerivedData() {
                super.prepareDerivedData();
                const parent = this.parent;
                // Check if item type can be found in expertise types
                const isKnownExpertiseType = parent.type in CONFIG.COSMERE.expertiseTypes;
                if (isKnownExpertiseType && !!parent.actor) {
                    // Check if the actor has the expertise
                    const actorHasExpertise = parent.actor.system.expertises?.some((expertise) => expertise.id === this.id);
                    // If the actor has the expertise, enable it
                    if (actorHasExpertise) {
                        this.expertise = true;
                    }
                }
            }
        };
    };
}

function LinkedSkillsMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                return foundry.utils.mergeObject(super.defineSchema(), {
                    linkedSkills: new foundry.data.fields.ArrayField(new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                        choices: () => Object.entries(CONFIG.COSMERE.skills)
                            .filter(([key, skill]) => !skill.core)
                            .reduce((acc, [key, skill]) => ({
                            ...acc,
                            [key]: skill.label,
                        }), {}),
                    }), {
                        required: true,
                        nullable: false,
                        initial: [],
                        label: 'COSMERE.Item.General.LinkedSkills.Label',
                        hint: 'COSMERE.Item.General.LinkedSkills.Hint',
                    }),
                });
            }
        };
    };
}

// Mixins
class WeaponItemDataModel extends DataModelMixin(IdItemMixin({
    initialFromName: true,
}), TypedItemMixin({
    initial: "light_wpn" /* WeaponType.Light */,
    choices: () => Object.entries(CONFIG.COSMERE.items.weapon.types).reduce((acc, [key, config]) => ({
        ...acc,
        [key]: config.label,
    }), {}),
}), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Weapon.desc_placeholder',
}), EquippableItemMixin({
    equipType: {
        initial: "hold" /* EquipType.Hold */,
        choices: ["hold" /* EquipType.Hold */],
    },
}), ActivatableItemMixin({
    type: {
        initial: "skill_test" /* ActivationType.SkillTest */,
    },
    skill: {
        allowDefault: true,
        defaultResolver: function () {
            return (CONFIG.COSMERE.items.weapon.types[this.type].skill ?? null);
        },
        initial: 'default',
    },
}), AttackingItemMixin(), DamagingItemMixin(), ExpertiseItemMixin(), TraitsItemMixin(), PhysicalItemMixin(), EventsItemMixin(), LinkedSkillsMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {});
    }
    prepareDerivedData() {
        super.prepareDerivedData();
        // Get active traits
        const activeTraits = this.traitsArray.filter((trait) => trait.active);
        // Check if Two Handed is active
        const twoHandedActive = activeTraits.some((trait) => trait.id === "two_handed" /* WeaponTraitId.TwoHanded */);
        // Set hold type
        if (twoHandedActive) {
            this.equip.hold = "two_handed" /* HoldType.TwoHanded */;
        }
        else {
            this.equip.hold = "one_handed" /* HoldType.OneHanded */;
            this.equip.hand ??= "main_hand" /* EquipHand.Main */;
        }
    }
}

/**
 * Mixin for deflect data
 */
function DeflectItemMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                const damageTypes = CONFIG.COSMERE.damageTypes;
                return foundry.utils.mergeObject(super.defineSchema(), {
                    deflect: new foundry.data.fields.NumberField({
                        required: true,
                        initial: 0,
                        min: 0,
                        integer: true,
                    }),
                    deflects: new foundry.data.fields.SchemaField(Object.keys(damageTypes).reduce((schemas, key) => {
                        schemas[key] =
                            new foundry.data.fields.SchemaField({
                                active: new foundry.data.fields.BooleanField({
                                    required: true,
                                    nullable: false,
                                    initial: !(damageTypes[key].ignoreDeflect ?? false),
                                }),
                            });
                        return schemas;
                    }, {})),
                });
            }
            get deflectsArray() {
                return Object.entries(this.deflects)
                    .map(([id, deflect]) => ({ id, ...deflect }))
                    .sort((a, b) => a.id.localeCompare(b.id));
            }
        };
    };
}

// Mixins
class ArmorItemDataModel extends DataModelMixin(IdItemMixin({
    initial: 'none',
}), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Armor.desc_placeholder',
}), EquippableItemMixin({
    equipType: {
        initial: "wear" /* EquipType.Wear */,
        choices: ["wear" /* EquipType.Wear */],
    },
}), ActivatableItemMixin(), ExpertiseItemMixin(), TraitsItemMixin(), DeflectItemMixin(), PhysicalItemMixin(), EventsItemMixin(), LinkedSkillsMixin(), RelationshipsMixin()) {
}

// Mixins
class EquipmentItemDataModel extends DataModelMixin(TypedItemMixin({
    initial: "basic" /* EquipmentType.Basic */,
    choices: () => Object.entries(CONFIG.COSMERE.items.equipment.types).reduce((acc, [key, config]) => ({
        ...acc,
        [key]: config.label,
    }), {}),
}), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Equipment.desc_placeholder',
}), PhysicalItemMixin(), ActivatableItemMixin(), DamagingItemMixin(), EventsItemMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {});
    }
}

// Mixins
class LootItemDataModel extends DataModelMixin(DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Loot.desc_placeholder',
}), PhysicalItemMixin(), EventsItemMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            isMoney: new foundry.data.fields.BooleanField({
                required: true,
                initial: false,
            }),
        });
    }
}

/**
 * Mixin for items that provide a talent tree through the "talents" tab.
 * Used for Paths & Ancestries.
 */
function TalentsProviderMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                return foundry.utils.mergeObject(super.defineSchema(), {
                    talentTree: new foundry.data.fields.DocumentUUIDField({
                        required: true,
                        nullable: true,
                        blank: false,
                        initial: null,
                        label: 'COSMERE.Item.Sheet.TalentsProvider.TalentTree.Label',
                        hint: 'COSMERE.Item.Sheet.TalentsProvider.TalentTree.Hint',
                    }),
                });
            }
            async getTalents(includeNested = true) {
                if (!this.talentTree)
                    return [];
                // Get the talent tree item
                const talentTreeItem = (await fromUuid(this.talentTree));
                if (!talentTreeItem?.isTalentTree())
                    return [];
                // Get all talents from the talent tree
                return talentTreeItem.system.getTalents(includeNested);
            }
            async providesTalent(talentOrId) {
                // Get talents
                const talents = await this.getTalents();
                // Get the id of the talent
                const id = typeof talentOrId === 'string'
                    ? talentOrId
                    : talentOrId.system.id;
                // Check if any talent matches the id
                return talents.some((talent) => {
                    return talent.system.id === id;
                });
            }
        };
    };
}

// Mixins
class AncestryItemDataModel extends DataModelMixin(IdItemMixin({
    initial: 'none',
}), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Ancestry.desc_placeholder',
}), TalentsProviderMixin(), EventsItemMixin(), LinkedSkillsMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            size: new foundry.data.fields.StringField({
                required: true,
                nullable: false,
                blank: false,
                initial: "medium" /* Size.Medium */,
                choices: Object.entries(CONFIG.COSMERE.sizes).reduce((acc, [key, config]) => ({
                    ...acc,
                    [key]: config.label,
                }), {}),
            }),
            type: new foundry.data.fields.SchemaField({
                id: new foundry.data.fields.StringField({
                    required: true,
                    nullable: false,
                    blank: false,
                    initial: "humanoid" /* CreatureType.Humanoid */,
                    choices: Object.entries(CONFIG.COSMERE.creatureTypes).reduce((acc, [key, config]) => ({
                        ...acc,
                        [key]: config.label,
                    }), {}),
                }),
                custom: new foundry.data.fields.StringField({ nullable: true }),
                subtype: new foundry.data.fields.StringField({
                    nullable: true,
                }),
            }),
            advancement: new foundry.data.fields.SchemaField({
                extraPath: new foundry.data.fields.DocumentUUIDField({
                    type: 'Item',
                }),
                extraTalents: new foundry.data.fields.ArrayField(new foundry.data.fields.SchemaField({
                    uuid: new foundry.data.fields.DocumentUUIDField({
                        type: 'Item',
                    }),
                    level: new foundry.data.fields.NumberField(),
                })),
                bonusTalents: new foundry.data.fields.ArrayField(new foundry.data.fields.SchemaField({
                    level: new foundry.data.fields.NumberField({
                        required: true,
                        min: 0,
                        initial: 0,
                    }),
                    quantity: new foundry.data.fields.NumberField({
                        required: true,
                        min: 0,
                        initial: 0,
                    }),
                    restrictions: new foundry.data.fields.StringField(),
                })),
            }),
        });
    }
    get typeFieldId() {
        return this.schema.fields.type._getField([
            'id',
        ]);
    }
    get sizeField() {
        return this.schema.fields.size;
    }
    get extraTalents() {
        return this.advancement.extraTalents;
    }
}

// Mixins
class CultureItemDataModel extends DataModelMixin(IdItemMixin({
    initial: 'none',
    choices: () => ['none', ...Object.keys(CONFIG.COSMERE.cultures)],
}), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Culture.desc_placeholder',
}), EventsItemMixin(), LinkedSkillsMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {});
    }
}

// Mixins
class PathItemDataModel extends DataModelMixin(IdItemMixin({ initialFromName: true }), TypedItemMixin({
    initial: "heroic" /* PathType.Heroic */,
    choices: () => {
        return Object.entries(CONFIG.COSMERE.paths.types).reduce((acc, [key, value]) => ({
            ...acc,
            [key]: value.label,
        }), {});
    },
}), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Path.desc_placeholder',
}), TalentsProviderMixin(), EventsItemMixin(), LinkedSkillsMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
        // TODO: Advancements
        });
    }
    get typeLabel() {
        return CONFIG.COSMERE.paths.types[this.type].label;
    }
}

// Mixins
class SpecialtyItemDataModel extends DataModelMixin(IdItemMixin({ initialFromName: true }), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Specialty.desc_placeholder',
}), EventsItemMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            path: new foundry.data.fields.StringField({
                required: true,
                nullable: false,
                blank: false,
                initial: '<path>',
            }),
            hasPath: new foundry.data.fields.BooleanField(),
        });
    }
    prepareDerivedData() {
        super.prepareDerivedData();
        // Get item
        const item = this.parent;
        // Get actor
        const actor = item.actor;
        // Determine whether actor has path
        this.hasPath =
            actor?.items.some((item) => item.isPath() && item.id === this.path) ?? false;
    }
}

function ModalityItemMixin() {
    return (base) => {
        return class extends base {
            static defineSchema() {
                const superSchema = super.defineSchema();
                // Ensure schema contains id (id mixin was used)
                if (!('id' in superSchema)) {
                    throw new Error('ModalityItemMixin must be used in combination with IdItemMixin');
                }
                return foundry.utils.mergeObject(super.defineSchema(), {
                    modality: new foundry.data.fields.StringField({
                        required: true,
                        nullable: true,
                        label: 'COSMERE.Item.Modality.Label',
                        hint: 'COSMERE.Item.Modality.Hint',
                        initial: null,
                    }),
                });
            }
        };
    };
}

// Mixins
class TalentItemDataModel extends DataModelMixin(IdItemMixin({
    initialFromName: true,
}), TypedItemMixin({
    initial: "path" /* Talent.Type.Path */,
    choices: () => Object.entries(CONFIG.COSMERE.items.talent.types).reduce((acc, [key, config]) => ({
        ...acc,
        [key]: config.label,
    }), {}),
}), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Talent.desc_placeholder',
}), ActivatableItemMixin(), DamagingItemMixin(), ModalityItemMixin(), EventsItemMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            path: new foundry.data.fields.StringField({
                required: false,
                nullable: true,
                initial: null,
            }),
            hasPath: new foundry.data.fields.BooleanField(),
            specialty: new foundry.data.fields.StringField({
                required: false,
                nullable: true,
                initial: null,
            }),
            hasSpecialty: new foundry.data.fields.BooleanField(),
            ancestry: new foundry.data.fields.StringField({
                required: false,
                nullable: true,
                initial: null,
            }),
            hasAncestry: new foundry.data.fields.BooleanField(),
            power: new foundry.data.fields.StringField({
                required: false,
                nullable: true,
                initial: null,
                label: 'COSMERE.Item.Talent.Power.Label',
                hint: 'COSMERE.Item.Talent.Power.Hint',
            }),
            hasPower: new foundry.data.fields.BooleanField(),
        });
    }
    prepareDerivedData() {
        super.prepareDerivedData();
        // Get item
        const item = this.parent;
        // Get actor
        const actor = item.actor;
        if (this.path) {
            this.hasPath =
                actor?.items.some((item) => item.isPath() && item.id === this.path) ?? false;
        }
        if (this.specialty) {
            this.hasSpecialty =
                actor?.items.some((item) => item.isSpecialty() && item.id === this.specialty) ?? false;
        }
        if (this.ancestry) {
            this.hasAncestry =
                actor?.items.some((item) => item.isAncestry() && item.id === this.ancestry) ?? false;
        }
        if (this.power) {
            this.hasPower =
                actor?.items.some((item) => item.isPower() && item.id === this.power) ?? false;
        }
        // if (!actor) {
        //     this.prerequisitesMet = false;
        // } else {
        //     this.prerequisitesMet = this.prerequisitesArray.every(
        //         (prerequisite) => {
        //             switch (prerequisite.type) {
        //                 case Talent.Prerequisite.Type.Talent:
        //                     return actor.items.some(
        //                         (item) =>
        //                             item.isTalent() &&
        //                             item.id === prerequisite.id,
        //                     );
        //                 case Talent.Prerequisite.Type.Skill:
        //                     return (
        //                         actor.system.skills[prerequisite.skill].rank >=
        //                         (prerequisite.rank ?? 1)
        //                     );
        //                 case Talent.Prerequisite.Type.Attribute:
        //                     return (
        //                         actor.system.attributes[prerequisite.attribute]
        //                             .value >= (prerequisite.value ?? 1)
        //                     );
        //                 default:
        //                     return true;
        //             }
        //         },
        //     );
        // }
    }
}

// Mixins
/**
 * Item data model that represents adversary traits.
 * Not to be confused with weapon & armor traits
 */
class TraitItemDataModel extends DataModelMixin(DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Trait.desc_placeholder',
}), ActivatableItemMixin(), EventsItemMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {});
    }
}

// Mixins
class ActionItemDataModel extends DataModelMixin(IdItemMixin({
    initialFromName: true,
}), TypedItemMixin({
    initial: "basic" /* ActionType.Basic */,
    choices: () => Object.entries(CONFIG.COSMERE.action.types).reduce((acc, [key, config]) => ({
        ...acc,
        [key]: config.label,
    }), {}),
}), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Action.desc_placeholder',
}), ActivatableItemMixin(), DamagingItemMixin(), ModalityItemMixin(), EventsItemMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            ancestry: new foundry.data.fields.StringField({
                required: false,
                nullable: true,
                initial: null,
                label: 'COSMERE.Item.Action.Ancestry.Label',
                hint: 'COSMERE.Item.Action.Ancestry.Hint',
            }),
        });
    }
}

// Mixins
class InjuryItemDataModel extends DataModelMixin(TypedItemMixin({
    // Default to flesh wound data as the least impactful injury type
    initial: "flesh_wound" /* InjuryType.FleshWound */,
    choices: () => Object.entries(CONFIG.COSMERE.injury.types).reduce((acc, [key, { label }]) => ({
        ...acc,
        [key]: label,
    }), {}),
}), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Injury.desc_placeholder',
}), EventsItemMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            duration: new foundry.data.fields.SchemaField({
                initial: new foundry.data.fields.NumberField({
                    nullable: true,
                    integer: true,
                    min: 0,
                    initial: 1,
                }),
                remaining: new foundry.data.fields.NumberField({
                    nullable: true,
                    integer: true,
                    min: 0,
                    initial: 1,
                }),
            }),
        });
    }
    get typeLabel() {
        return CONFIG.COSMERE.injury.types[this.type].label;
    }
}

// Mixins
class ConnectionItemDataModel extends DataModelMixin(DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Connection.desc_placeholder',
}), EventsItemMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {});
    }
}

// Mixins
class PowerItemDataModel extends DataModelMixin(IdItemMixin({
    initialFromName: true,
    hint: 'COSMERE.Item.Power.Identifier.Hint',
}), TypedItemMixin({
    initial: () => Object.keys(CONFIG.COSMERE.power.types)[0],
    choices: () => Object.entries(CONFIG.COSMERE.power.types).reduce((acc, [key, config]) => ({
        ...acc,
        [key]: config.label,
    }), {}),
}), ActivatableItemMixin(), DamagingItemMixin(), DescriptionItemMixin({
    value: 'COSMERE.Item.Type.Power.desc_placeholder',
}), EventsItemMixin(), RelationshipsMixin()) {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            customSkill: new foundry.data.fields.BooleanField({
                required: true,
                initial: false,
                label: 'COSMERE.Item.Power.CustomSkill.Label',
                hint: 'COSMERE.Item.Power.CustomSkill.Hint',
            }),
            skill: new foundry.data.fields.StringField({
                required: true,
                nullable: true,
                blank: false,
                label: 'COSMERE.Item.Power.Skill.Label',
                hint: 'COSMERE.Item.Power.Skill.Hint',
                initial: null,
                choices: () => Object.entries(CONFIG.COSMERE.skills)
                    .filter(([key, skill]) => !skill.core)
                    .reduce((acc, [key, skill]) => ({
                    ...acc,
                    [key]: skill.label,
                }), {}),
            }),
        });
    }
    prepareDerivedData() {
        super.prepareDerivedData();
        if (!this.customSkill) {
            const validId = this.id in CONFIG.COSMERE.skills;
            this.skill = validId ? this.id : null;
        }
    }
}

class TalentTreeNodeCollectionField extends CollectionField {
    constructor(options, context) {
        super(new TalentTreeNodeField({
            nullable: true,
        }), options, context, NodeRecordCollection);
    }
}
class NodeRecordCollection extends RecordCollection {
    set(id, value) {
        // Ensure the node id matches the record id
        if (value) {
            value.id = id;
        }
        // Set the record
        return super.set(id, value);
    }
}
class TalentTreeNodeField extends foundry.data.fields.SchemaField {
    constructor(options, context) {
        options ??= {};
        options.gmOnly = true;
        super({
            // General node fields
            id: new foundry.data.fields.DocumentIdField({
                required: true,
                nullable: false,
                blank: false,
                readonly: false,
            }),
            type: new foundry.data.fields.StringField({
                required: false,
                nullable: true,
                blank: false,
                initial: "talent" /* TalentTree.Node.Type.Talent */,
                choices: [
                    "talent" /* TalentTree.Node.Type.Talent */,
                    "tree" /* TalentTree.Node.Type.Tree */,
                    "text" /* TalentTree.Node.Type.Text */,
                ],
            }),
            position: new foundry.data.fields.SchemaField({
                x: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    label: 'COSMERE.Item.TalentTree.Node.Position.X.Label',
                }),
                y: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    label: 'COSMERE.Item.TalentTree.Node.Position.Y.Label',
                }),
            }, {
                required: true,
                nullable: false,
            }),
            // Talent / Tree node fields
            uuid: new foundry.data.fields.DocumentUUIDField({
                nullable: true,
            }),
            size: new foundry.data.fields.SchemaField({
                width: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    initial: 50,
                }),
                height: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    initial: 50,
                }),
            }, {
                required: false,
                nullable: true,
            }),
            showName: new foundry.data.fields.BooleanField({
                nullable: true,
                initial: false,
            }),
            talentId: new foundry.data.fields.StringField({
                nullable: true,
            }),
            // Talent node fields
            prerequisites: new CollectionField(new foundry.data.fields.SchemaField({
                id: new foundry.data.fields.StringField({
                    required: true,
                    nullable: false,
                    blank: false,
                }),
                type: new foundry.data.fields.StringField({
                    required: true,
                    nullable: false,
                    blank: false,
                    choices: CONFIG.COSMERE.items.talentTree.node
                        .prerequisite.types,
                }),
                managed: new foundry.data.fields.BooleanField({
                    required: true,
                    nullable: false,
                    initial: false,
                }),
                // Connection
                description: new foundry.data.fields.StringField(),
                // Attribute
                attribute: new foundry.data.fields.StringField({
                    blank: false,
                    choices: Object.entries(CONFIG.COSMERE.attributes).reduce((acc, [key, config]) => ({
                        ...acc,
                        [key]: config.label,
                    }), {}),
                }),
                value: new foundry.data.fields.NumberField({
                    min: 0,
                    initial: 0,
                }),
                // Skill
                skill: new foundry.data.fields.StringField({
                    blank: false,
                    choices: Object.entries(CONFIG.COSMERE.skills).reduce((acc, [key, config]) => ({
                        ...acc,
                        [key]: config.label,
                    }), {}),
                }),
                rank: new foundry.data.fields.NumberField({
                    min: 1,
                    initial: 1,
                }),
                // Talent
                talents: new CollectionField(new foundry.data.fields.SchemaField({
                    uuid: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                    id: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                    label: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                }), {
                    nullable: true,
                }),
                // Level
                level: new foundry.data.fields.NumberField({
                    min: 0,
                    initial: 0,
                    label: 'COSMERE.Item.Talent.Prerequisite.Level.Label',
                }),
                // Ancestry
                ancestry: new foundry.data.fields.SchemaField({
                    uuid: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                    id: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                    label: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                }, {
                    nullable: true,
                    initial: null,
                    label: 'COSMERE.Item.Talent.Prerequisite.Ancestry.Label',
                }),
                // Culture
                culture: new foundry.data.fields.SchemaField({
                    uuid: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                    id: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                    label: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                }, {
                    nullable: true,
                    initial: null,
                    label: 'COSMERE.Item.Talent.Prerequisite.Culture.Label',
                }),
                // Goal
                goals: new CollectionField(new foundry.data.fields.SchemaField({
                    uuid: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                    id: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                    label: new foundry.data.fields.StringField({
                        required: true,
                        nullable: false,
                        blank: false,
                    }),
                }), {
                    nullable: true,
                }),
            }), {
                nullable: true,
            }),
            prerequisitesMet: new foundry.data.fields.BooleanField(),
            connections: new CollectionField(new foundry.data.fields.SchemaField({
                id: new foundry.data.fields.DocumentIdField({
                    required: true,
                    nullable: false,
                    blank: false,
                    readonly: false,
                }),
                prerequisiteId: new foundry.data.fields.DocumentIdField({
                    required: true,
                    nullable: false,
                }),
                path: new foundry.data.fields.ArrayField(new foundry.data.fields.SchemaField({
                    x: new foundry.data.fields.NumberField({
                        required: true,
                        nullable: false,
                    }),
                    y: new foundry.data.fields.NumberField({
                        required: true,
                        nullable: false,
                    }),
                }), {
                    nullable: true,
                }),
            }), {
                nullable: true,
            }),
            // Text node fields
            text: new foundry.data.fields.StringField({
                nullable: true,
            }),
        }, options, context);
    }
}

class TalentTreeItemDataModel extends DataModelMixin() {
    static defineSchema() {
        return foundry.utils.mergeObject(super.defineSchema(), {
            nodes: new TalentTreeNodeCollectionField({
                required: true,
                nullable: false,
                gmOnly: true,
            }),
            viewBounds: new foundry.data.fields.SchemaField({
                x: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    initial: 0,
                    label: 'COSMERE.Item.TalentTree.ViewBounds.X.Label',
                }),
                y: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    initial: 0,
                    label: 'COSMERE.Item.TalentTree.ViewBounds.Y.Label',
                }),
                width: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    initial: 800,
                    label: 'COSMERE.Item.TalentTree.ViewBounds.Width.Label',
                }),
                height: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    initial: 650,
                    label: 'COSMERE.Item.TalentTree.ViewBounds.Height.Label',
                }),
            }, {
                required: true,
                nullable: false,
            }),
            display: new foundry.data.fields.SchemaField({
                width: new foundry.data.fields.NumberField({
                    required: false,
                    nullable: true,
                    integer: true,
                    label: 'COSMERE.Item.TalentTree.Display.Width.Label',
                }),
                height: new foundry.data.fields.NumberField({
                    required: false,
                    nullable: true,
                    integer: true,
                    label: 'COSMERE.Item.TalentTree.Display.Height.Label',
                }),
            }),
            background: new foundry.data.fields.SchemaField({
                img: new foundry.data.fields.FilePathField({
                    required: false,
                    nullable: true,
                    categories: ['IMAGE'],
                    label: 'COSMERE.Item.TalentTree.Background.Img.Label',
                }),
                width: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    initial: 0,
                    label: 'COSMERE.Item.TalentTree.Background.Size.Width.Label',
                }),
                height: new foundry.data.fields.NumberField({
                    required: true,
                    nullable: false,
                    integer: true,
                    initial: 0,
                    label: 'COSMERE.Item.TalentTree.Background.Size.Height.Label',
                }),
                position: new foundry.data.fields.SchemaField({
                    x: new foundry.data.fields.NumberField({
                        required: true,
                        nullable: false,
                        integer: true,
                        initial: 0,
                        label: 'COSMERE.Item.TalentTree.Background.Position.X.Label',
                    }),
                    y: new foundry.data.fields.NumberField({
                        required: true,
                        nullable: false,
                        integer: true,
                        initial: 0,
                        label: 'COSMERE.Item.TalentTree.Background.Position.Y.Label',
                    }),
                }, {
                    required: true,
                    nullable: false,
                }),
            }),
        });
    }
    prepareDerivedData() {
        // Get item
        const item = this.parent;
        // Get actor
        const actor = item.actor;
        // Loop through talent nodes
        this.nodes
            .filter((node) => node.type === "talent" /* TalentTree.Node.Type.Talent */)
            .forEach((node) => {
            // Check if prerequisites are met
            if (!actor?.isCharacter()) {
                node.prerequisitesMet = false;
            }
            else {
                node.prerequisitesMet = characterMeetsTalentPrerequisites(actor, node.prerequisites);
            }
        });
    }
    /**
     * The talents referenced by the nodes of this talent tree.
     * @param includeNested - Whether to include talents from nested trees. Defaults to `true`.
     */
    getTalents(includeNested = true) {
        return getTalents(this.parent, includeNested);
    }
}

const config$1 = {
    ["weapon" /* ItemType.Weapon */]: WeaponItemDataModel,
    ["armor" /* ItemType.Armor */]: ArmorItemDataModel,
    ["equipment" /* ItemType.Equipment */]: EquipmentItemDataModel,
    ["loot" /* ItemType.Loot */]: LootItemDataModel,
    ["ancestry" /* ItemType.Ancestry */]: AncestryItemDataModel,
    ["culture" /* ItemType.Culture */]: CultureItemDataModel,
    ["path" /* ItemType.Path */]: PathItemDataModel,
    ["specialty" /* ItemType.Specialty */]: SpecialtyItemDataModel,
    ["talent" /* ItemType.Talent */]: TalentItemDataModel,
    ["trait" /* ItemType.Trait */]: TraitItemDataModel,
    ["action" /* ItemType.Action */]: ActionItemDataModel,
    ["injury" /* ItemType.Injury */]: InjuryItemDataModel,
    ["connection" /* ItemType.Connection */]: ConnectionItemDataModel,
    ["goal" /* ItemType.Goal */]: GoalItemDataModel,
    ["power" /* ItemType.Power */]: PowerItemDataModel,
    ["talent_tree" /* ItemType.TalentTree */]: TalentTreeItemDataModel,
};

class ActiveEffectDataModel extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        return {
            isStackable: new foundry.data.fields.BooleanField({
                required: true,
                initial: false,
            }),
            stacks: new foundry.data.fields.NumberField({
                required: false,
                nullable: true,
                min: 0,
            }),
        };
    }
}

const config = {
    base: ActiveEffectDataModel,
};

class CombatantDataModel extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        return {
            turnSpeed: new foundry.data.fields.StringField({
                required: true,
                blank: false,
                initial: "slow" /* TurnSpeed.Slow */,
                choices: ["slow" /* TurnSpeed.Slow */, "fast" /* TurnSpeed.Fast */],
            }),
            activated: new foundry.data.fields.BooleanField({
                required: true,
                initial: false,
            }),
            bossFastActivated: new foundry.data.fields.BooleanField({
                required: false,
            }),
        };
    }
}

function activateListeners() {
    const body = $('body');
    body.on('dragstart', 'section[data-link]', _onDragContentLink);
}
/**
 * Begin a Drag+Drop workflow for a dynamic content link
 * @param event   The originating drag event
 * @private
 */
function _onDragContentLink(event) {
    event.stopPropagation();
    const a = event.currentTarget;
    let dragData = null;
    // Case 1 - Compendium Link
    if (a.dataset.pack) {
        const pack = game.packs.get(a.dataset.pack);
        let id = a.dataset.id;
        if (a.dataset.lookup && pack.index.size) {
            const entry = pack.index.find((i) => i._id === a.dataset.lookup ||
                i.name ===
                    a.dataset.lookup);
            if (entry)
                id = entry._id;
        }
        if (!a.dataset.uuid && !id)
            return false;
        const uuid = a.dataset.uuid ?? pack.getUuid(id);
        dragData = { type: a.dataset.type ?? pack.documentName, uuid };
    }
    // Case 2 - World Document Link
    else {
        const doc = fromUuidSync(a.dataset.uuid);
        dragData = doc.toDragData();
    }
    event.originalEvent.dataTransfer.setData('text/plain', JSON.stringify(dragData));
}
var Editor = {
    activateListeners,
};

const SYSTEM_REGISTRATION = {
    source: SYSTEM_ID,
    priority: 0,
    hash: false,
};
var RegistrationLogType;
(function (RegistrationLogType) {
    RegistrationLogType["Warn"] = "warn";
    RegistrationLogType["Error"] = "error";
    RegistrationLogType["Debug"] = "debug";
})(RegistrationLogType || (RegistrationLogType = {}));
class RegistrationHelper {
    static LOG_DEBOUNCE_MS = 200;
    static _COMPLETED = {};
    static logs = [];
    static get COMPLETED() {
        return this._COMPLETED;
    }
    static logger = {
        debug: (source, message) => {
            this.registerLog({
                source,
                type: RegistrationLogType.Debug,
                message,
            });
        },
        warn: (source, message) => {
            this.registerLog({
                source,
                type: RegistrationLogType.Warn,
                message,
            });
        },
        error: (source, message) => {
            this.registerLog({
                source,
                type: RegistrationLogType.Error,
                message,
            });
        },
    };
    static registerLog(log) {
        this.logs.push(log);
        this.showLogs();
    }
    static tryRegisterConfig({ key, data, register, compareOmitFields, compare = true, }) {
        data.priority ??= 0; // Default priority to 0 if not set
        // Calculate a hash of the base data to check for equality
        const hash = compare
            ? RegistrationHelper.getHash(data, compareOmitFields)
            : false;
        if (foundry.utils.hasProperty(CONFIG.COSMERE, key)) {
            const registration = RegistrationHelper._COMPLETED[key] ?? SYSTEM_REGISTRATION;
            /**
             * NOTE: Default system configurations (such as skills.ath) have
             * Their hash set to `false`, so similarity check always fails.
             * Modules shouldn't be using the api to set a system configuration to
             * its default value, so this has no actual effect on registrations.
             */
            // Check if same object is already registered
            if (compare && hash === registration.hash) {
                RegistrationHelper.logger.warn(data.source, `Config ${key} already registered with the same data.`);
                return true; // Already registered with the same data
            }
            // If the same key is already registered, we check if the new registration has a higher priority.
            if (data.priority <= registration.priority) {
                RegistrationHelper.logger.error(data.source, `Failed to register config: ${key}. Reason: A higher priority registration already exists.`);
                return false; // Registration failed due to lower priority
            }
            // Log warning about overriding
            RegistrationHelper.logger.warn(data.source, `Overriding config: ${key} due to a higher priority value: ${data.priority}.`);
        }
        // Perform the registration
        const result = register();
        if (result) {
            RegistrationHelper._COMPLETED[key] = {
                source: data.source,
                priority: data.priority,
                hash,
            };
        }
        return result;
    }
    static showLogs = foundry.utils.debounce(() => {
        const hasErrorLogs = this.logs.some((log) => log.type === RegistrationLogType.Error);
        console[hasErrorLogs ? 'error' : 'warn'](`${SYSTEM_ID} | API Registration Logs`, this.logs);
        // Show error notification if there are any error logs
        if (hasErrorLogs) {
            // TODO: Show log dialog instead of error notification.
            ui.notifications.error(game.i18n.localize('GENERIC.Error.RegisteringConfigs'));
        }
        // Clear this batch of logs so we don't display them again.
        this.logs = [];
    }, this.LOG_DEBOUNCE_MS);
    static getHash(data, omitFields = []) {
        const removeFields = [
            ...omitFields,
            'source',
            'priority',
        ];
        const baseData = foundry.utils.duplicate(data);
        removeFields.forEach((field) => {
            delete baseData[field];
        });
        return SparkMD5.hash(JSON.stringify(baseData));
    }
}

function getCurrentRegistrations() {
    return RegistrationHelper.COMPLETED;
}
function registerCurrency(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        denominations: data.denominations,
        label: data.label,
        icon: data.icon,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `currencies.${data.id}`;
    const register = () => {
        // Ensure a base denomination is configured
        if (!data.denominations.primary.some((d) => d.base)) {
            RegistrationHelper.logger.error(data.source, `Failed to register config: ${key}. Reason: Currency must have a base denomination.`);
            return false;
        }
        if (data.denominations.secondary &&
            !data.denominations.secondary.some((d) => d.base)) {
            RegistrationHelper.logger.error(data.source, `Failed to register config: ${key}. Reason: Secondary denominations must have a base denomination.`);
            return false;
        }
        // Get base denomination
        const baseDenomination = data.denominations.primary.find((d) => d.base);
        // Ensure base denomination has a unit
        if (!baseDenomination.unit) {
            RegistrationHelper.logger.error(data.source, `Failed to register config: ${key}. Reason: Base denomination ${baseDenomination.id} must have a unit.`);
            return false;
        }
        CONFIG.COSMERE.currencies[data.id] = {
            label: data.label,
            icon: data.icon,
            denominations: data.denominations,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
        compareOmitFields: ['icon'], // Omit icon from hash comparison
    });
}

var GeneralAPI = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getCurrentRegistrations: getCurrentRegistrations,
    registerCurrency: registerCurrency
});

function registerSkill(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        attribute: data.attribute,
        label: data.label,
        core: data.core,
        hiddenUntilAcquired: data.hiddenUntilAcquired,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `skills.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.skills[data.id] = {
            key: data.id,
            label: data.label,
            attribute: data.attribute,
            core: data.core,
            hiddenUntilAcquired: data.hiddenUntilAcquired,
        };
        CONFIG.COSMERE.attributes[data.attribute].skills.push(data.id);
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}

var ActorAPI = /*#__PURE__*/Object.freeze({
    __proto__: null,
    registerSkill: registerSkill
});

function registerPowerType(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        plural: data.plural,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `power.types.${data.id}`;
    const register = () => {
        if (data.id === 'none') {
            RegistrationHelper.logger.error(data.source, `Failed to register config: ${key}. Reason: Cannot register power type with id "none".`);
            return false;
        }
        CONFIG.COSMERE.power.types[data.id] = {
            label: data.label,
            plural: data.plural,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
function registerPathType(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `path.types.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.paths.types[data.id] = {
            label: data.label,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
function registerActionType(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        labelPlural: data.labelPlural,
        hasMode: data.hasMode,
        subtitle: data.subtitle,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `action.types.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.action.types[data.id] = {
            label: data.label,
            labelPlural: data.labelPlural,
            hasMode: data.hasMode,
            subtitle: data.subtitle,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
function registerEquipmentType(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `items.equipment.types.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.items.equipment.types[data.id] = {
            label: data.label,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
function registerWeaponType(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        skill: data.skill,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `items.weapon.types.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.items.weapon.types[data.id] = {
            label: data.label,
            skill: data.skill,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
function registerWeapon(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        reference: data.reference,
        specialExpertise: data.specialExpertise,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `weapons.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.weapons[data.id] = {
            label: data.label,
            reference: data.reference,
            specialExpertise: data.specialExpertise,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
function registerArmor(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        specialExpertise: data.specialExpertise,
        reference: data.reference,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `armors.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.armors[data.id] = {
            label: data.label,
            reference: data.reference,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
function registerCulture(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        reference: data.reference,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `cultures.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.cultures[data.id] = {
            label: data.label,
            reference: data.reference,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
function registerAncestry(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        reference: data.reference,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `ancestries.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.ancestries[data.id] = {
            label: data.label,
            reference: data.reference,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
function registerItemEventType(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        type: data.type,
        label: data.label,
        description: data.description,
        hook: data.hook,
        host: data.host ?? "source" /* ItemEventSystem.Event.ExecutionHost.Source */,
        filter: data.filter,
        condition: data.condition,
        transform: data.transform,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `items.events.types.${data.type}`;
    const register = () => {
        if (data.type === 'none') {
            RegistrationHelper.logger.error(data.source, `Failed to register config: ${key}. Reason: Cannot register item event type with type "none".`);
            return false;
        }
        CONFIG.COSMERE.items.events.types[data.type] = {
            label: data.label,
            description: data.description,
            hook: data.hook,
            host: data.host,
            filter: data.filter,
            condition: data.condition,
            transform: data.transform,
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
function registerItemEventHandlerType(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        type: data.type,
        label: data.label,
        description: data.description,
        executor: data.executor,
        config: data.config,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `items.events.handlers.${data.type}`;
    const register = () => {
        if (data.type === 'none') {
            RegistrationHelper.logger.error(data.source, `Failed to register config: ${key}. Reason: Cannot register item event handler with type "none".`);
            return false;
        }
        CONFIG.COSMERE.items.events.handlers[data.type] = {
            label: data.label,
            description: data.description,
            documentClass: constructHandlerClass(data.type, data.executor, data.config),
        };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
        compare: false, // Handlers are not compared by hash
    });
}

var ItemAPI = /*#__PURE__*/Object.freeze({
    __proto__: null,
    registerActionType: registerActionType,
    registerAncestry: registerAncestry,
    registerArmor: registerArmor,
    registerCulture: registerCulture,
    registerEquipmentType: registerEquipmentType,
    registerItemEventHandlerType: registerItemEventHandlerType,
    registerItemEventType: registerItemEventType,
    registerPathType: registerPathType,
    registerPowerType: registerPowerType,
    registerWeapon: registerWeapon,
    registerWeaponType: registerWeaponType
});

function registerTheme(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `themes.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.themes[data.id] = data.label;
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}

var StyleAPI = /*#__PURE__*/Object.freeze({
    __proto__: null,
    registerTheme: registerTheme
});

/**
 * Registers a new static section for the actor's actions list.
 */
function registerActionListSection(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        label: data.label,
        sortOrder: data.sortOrder,
        default: data.default,
        itemTypeLabel: data.itemTypeLabel,
        createItemTooltip: data.createItemTooltip,
        filter: data.filter,
        new: data.new,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `sheet.actor.components.actions.sections.static.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.sheet.actor.components.actions.sections.static[data.id] =
            {
                id: data.id,
                label: data.label,
                sortOrder: data.sortOrder,
                default: data.default,
                itemTypeLabel: data.itemTypeLabel,
                createItemTooltip: data.createItemTooltip,
                filter: data.filter,
                new: data.new,
            };
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}
/**
 * Registers a new dynamic section generator for the actor's actions list.
 * Dynamic section generators are used to create sections based on the actor's state, such as powers or paths.
 */
function registerActionListDynamicSectionGenerator(data) {
    if (!CONFIG.COSMERE) {
        throw new Error('Cannot access API until after the system is initialized.');
    }
    // Clean data, remove fields that are not part of the config
    data = {
        id: data.id,
        generator: data.generator,
        source: data.source,
        priority: data.priority,
        strict: data.strict,
    };
    const key = `sheet.actor.components.actions.sections.dynamic.${data.id}`;
    const register = () => {
        CONFIG.COSMERE.sheet.actor.components.actions.sections.dynamic[data.id] = data.generator;
        return true;
    };
    return RegistrationHelper.tryRegisterConfig({
        key,
        data,
        register,
    });
}

var SheetAPI = /*#__PURE__*/Object.freeze({
    __proto__: null,
    registerActionListDynamicSectionGenerator: registerActionListDynamicSectionGenerator,
    registerActionListSection: registerActionListSection
});

var CosmereAPI = {
    ...GeneralAPI,
    ...ActorAPI,
    ...ItemAPI,
    ...StyleAPI,
    ...SheetAPI,
};

// Types
const STARTING_SKILLS = {
    agent: Skill.Insight,
    envoy: Skill.Discipline,
    hunter: Skill.Perception,
    leader: Skill.Leadership,
    scholar: Skill.Lore,
    warrior: Skill.Athletics,
};
async function set(item, options) {
    const actor = item.actor;
    if (!actor)
        return;
    if (!item.isPath())
        return;
    const paths = actor.paths;
    const changes = {};
    // Check if the actor already has a starting path
    const startingPath = paths.find((p) => p.getFlag('cosmere-rpg', 'isStartingPath') === true);
    if (startingPath && options?.replace === true) {
        await unassignStartingPath(startingPath, changes);
    }
    else if (startingPath) {
        return;
    }
    // Assign the new starting path
    await assignStartingPath(item, changes);
    // Update the actor
    await actor.update(changes, options?.ops);
    if (options?.notify !== false) {
        ui.notifications.info(game.i18n.format('STORMLIGHT.Macro.StartingPath.Set', {
            path: item.name,
            actor: actor.name,
            skill: game.i18n.localize(`COSMERE.Skill.${STARTING_SKILLS[item.system.id]}`),
        }));
    }
}
async function unset(item, options) {
    const actor = item.actor;
    if (!item.isPath())
        return;
    const isStartingPath = item.getFlag('cosmere-rpg', 'isStartingPath');
    if (!isStartingPath)
        return;
    const changes = {};
    let newStartingPath;
    // Unassign the starting path
    await unassignStartingPath(item, changes, false);
    if (options?.replace !== false) {
        const paths = actor.paths;
        newStartingPath = paths
            .filter((p) => p.system.id !== item.system.id)
            .find(() => true);
        if (newStartingPath) {
            await assignStartingPath(newStartingPath, changes);
        }
    }
    await actor.update(changes, options?.ops);
    if (options?.notify !== false) {
        ui.notifications.info(game.i18n.format(newStartingPath
            ? 'STORMLIGHT.Macro.StartingPath.Replaced'
            : 'STORMLIGHT.Macro.StartingPath.Unset', {
            actor: actor.name,
            skill: game.i18n.localize(`COSMERE.Skill.${STARTING_SKILLS[newStartingPath?.system.id ?? item.system.id]}`),
            oldPath: item.name,
            newPath: newStartingPath?.name ?? '',
        }));
    }
}
async function assignStartingPath(item, actorChanges, setFlag = true) {
    const actor = item.actor;
    const skillId = STARTING_SKILLS[item.system.id];
    foundry.utils.mergeObject(actorChanges, {
        [`system.skills.${skillId}.rank`]: actor.system.skills[skillId].rank + 1,
    }, { inplace: true });
    if (setFlag)
        await item.setFlag('cosmere-rpg', 'isStartingPath', true);
}
async function unassignStartingPath(item, actorChanges, setFlag = true) {
    const actor = item.actor;
    if (!actor.isCharacter())
        return;
    const skillId = STARTING_SKILLS[item.system.id];
    foundry.utils.mergeObject(actorChanges, {
        [`system.skills.${skillId}.rank`]: actor.system.skills[skillId].rank - 1,
    }, { inplace: true });
    if (setFlag)
        await item.unsetFlag('cosmere-rpg', 'isStartingPath');
}
var startingPath = {
    set,
    unset,
};

var startingPath$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: startingPath,
    set: set,
    unset: unset
});

var macros = /*#__PURE__*/Object.freeze({
    __proto__: null,
    startingPath: startingPath$1
});

/**
 * Global utility functions, exposed to users via
 * cosmereRPG.utils
 */
var CosmereUtils = {
    invokeMigration,
    macros,
};

Hooks.once('init', async () => {
    globalThis.cosmereRPG = Object.assign(game.system, {
        api: CosmereAPI,
        utils: CosmereUtils,
    });
    CONFIG.COSMERE = COSMERE;
    CONFIG.ChatMessage.documentClass = CosmereChatMessage;
    CONFIG.Actor.dataModels = config$2;
    CONFIG.Actor.documentClass = CosmereActor;
    CONFIG.Item.dataModels = config$1;
    CONFIG.Item.documentClass = CosmereItem;
    CONFIG.Combat.documentClass = CosmereCombat;
    CONFIG.ui.combat = CosmereCombatTracker;
    // NOTE: Disabled for now as v12 doesn't permit users to update the system of combatants they own
    // (CONFIG.Combatant as AnyMutableObject).dataModels =
    //     dataModels.combatant.config;
    CONFIG.Combatant.documentClass =
        CosmereCombatant;
    CONFIG.Token.documentClass = CosmereTokenDocument;
    CONFIG.ActiveEffect.dataModels =
        config;
    CONFIG.ActiveEffect.documentClass =
        CosmereActiveEffect;
    CONFIG.ActiveEffect.legacyTransferral = false;
    Roll.TOOLTIP_TEMPLATE = `systems/${SYSTEM_ID}/templates/${TEMPLATES.CHAT_ROLL_TOOLTIP}`;
    // Add fonts
    configureFonts();
    // Register item event system event types & handlers
    register$7();
    // Configure the starter rules
    register();
    Actors.unregisterSheet('core', ActorSheet);
    registerActorSheet("character" /* ActorType.Character */, CharacterSheet);
    registerActorSheet("adversary" /* ActorType.Adversary */, AdversarySheet);
    Items.unregisterSheet('core', ItemSheet);
    registerItemSheet("culture" /* ItemType.Culture */, CultureItemSheet);
    registerItemSheet("ancestry" /* ItemType.Ancestry */, AncestrySheet);
    registerItemSheet("path" /* ItemType.Path */, PathItemSheet);
    registerItemSheet("connection" /* ItemType.Connection */, ConnectionItemSheet);
    registerItemSheet("injury" /* ItemType.Injury */, InjuryItemSheet);
    registerItemSheet("specialty" /* ItemType.Specialty */, SpecialtyItemSheet);
    registerItemSheet("loot" /* ItemType.Loot */, LootItemSheet);
    registerItemSheet("armor" /* ItemType.Armor */, ArmorItemSheet);
    registerItemSheet("trait" /* ItemType.Trait */, TraitItemSheet);
    registerItemSheet("action" /* ItemType.Action */, ActionItemSheet);
    registerItemSheet("talent" /* ItemType.Talent */, TalentItemSheet);
    registerItemSheet("equipment" /* ItemType.Equipment */, EquipmentItemSheet);
    registerItemSheet("weapon" /* ItemType.Weapon */, WeaponItemSheet);
    registerItemSheet("goal" /* ItemType.Goal */, GoalItemSheet);
    registerItemSheet("power" /* ItemType.Power */, PowerItemSheet);
    registerItemSheet("talent_tree" /* ItemType.TalentTree */, TalentTreeItemSheet);
    CONFIG.Dice.types.push(PlotDie);
    CONFIG.Dice.terms.p = PlotDie;
    CONFIG.Dice.termTypes[PlotDie.name] = PlotDie;
    // NOTE: foundry-vtt-types has two version of the RollTerm class which do not match
    // causing this to error. Bug?
    // @league-of-foundry-developers/foundry-vtt-types/src/foundry/client/dice/term.d.mts
    // @league-of-foundry-developers/foundry-vtt-types/src/foundry/client-esm/dice/terms/term.d.mts
    // @ts-expect-error see note
    CONFIG.Dice.rolls.push(D20Roll);
    // @ts-expect-error see note
    CONFIG.Dice.rolls.push(DamageRoll);
    CONFIG.Canvas.visionModes.sense = new VisionMode({
        id: 'sense',
        label: 'COSMERE.Actor.Statistics.SensesRange',
        canvas: {
            shader: ColorAdjustmentsSamplerShader,
            uniforms: { contrast: 0, saturation: -1.0, brightness: 0 },
        },
        lighting: {
            levels: {
                [VisionMode.LIGHTING_LEVELS.DIM]: VisionMode.LIGHTING_LEVELS.BRIGHT,
            },
            background: { visibility: VisionMode.LIGHTING_VISIBILITY.REQUIRED },
        },
        vision: {
            darkness: { adaptive: false },
            defaults: {
                attenuation: 0,
                contrast: 0,
                saturation: -1.0,
                brightness: 0,
            },
        },
    });
    // Register status effects
    registerStatusEffects();
    // Register settings
    registerSystemSettings();
    registerSystemKeybindings();
    registerCustomEnrichers();
    // Load templates
    await preloadHandlebarsTemplates();
    // Activate the editor listeners
    Editor.activateListeners();
    // Set configuration through API
    configure();
});
Hooks.once('setup', () => {
    // Register some settings after modules have had a chance to initialize
    registerDeferredSettings();
});
Hooks.once('ready', () => {
    // Chat message listeners
    CosmereChatMessage.activateListeners();
});
/**
 * Helper function to register the configured
 * statuses as status effects.
 */
function registerStatusEffects() {
    // Map statuses to status effects
    const statusEffects = Object.keys(CONFIG.COSMERE.statuses).map((status) => {
        // Get the config
        const config = CONFIG.COSMERE.statuses[status];
        return {
            id: status,
            name: config.label,
            img: config.icon,
            _id: `cond${status}`.padEnd(16, '0'),
            ...(config.stackable
                ? {
                    system: {
                        isStackable: true,
                        count: 1,
                    },
                }
                : {}),
        };
    });
    // Register status effects
    CONFIG.statusEffects = statusEffects;
}
// NOTE: Must cast to `any` as registerSheet type doesn't accept ApplicationV2 (even though it's valid to pass it)
/* eslint-disable @typescript-eslint/no-explicit-any */
function registerActorSheet(type, sheet) {
    Actors.registerSheet(SYSTEM_ID, sheet, {
        types: [type],
        makeDefault: true,
        label: `TYPES.Actor.${type}`,
    });
}
function registerItemSheet(type, sheet) {
    Items.registerSheet(SYSTEM_ID, sheet, {
        types: [type],
        makeDefault: true,
        label: `TYPES.Item.${type}`,
    });
}
/* eslint-enable @typescript-eslint/no-explicit-any */
/**
 * Configure additional system fonts.
 */
function configureFonts() {
    Object.assign(CONFIG.fontDefinitions, {
        'Laski Sans': {
            editor: true,
            fonts: [
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/laski-sans/LaskiSans-Regular.woff2`,
                    ],
                },
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/laski-sans/LaskiSans-RegularItalic.woff2`,
                    ],
                    style: 'italic',
                },
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/laski-sans/LaskiSans-Semibold.woff2`,
                    ],
                    weight: 600,
                },
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/laski-sans/LaskiSans-SemiboldItalic.woff2`,
                    ],
                    weight: 600,
                    style: 'italic',
                },
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/laski-sans/LaskiSans-Bold.woff2`,
                    ],
                    weight: 'bold',
                },
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/laski-sans/LaskiSans-BoldItalic.woff2`,
                    ],
                    weight: 'bold',
                    style: 'italic',
                },
            ],
        },
        'Roboto Condensed': {
            editor: true,
            fonts: [
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/roboto-condensed/RobotoCondensed-Regular.woff2`,
                    ],
                },
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/roboto-condensed/RobotoCondensed-Bold.woff2`,
                    ],
                    weight: 'bold',
                },
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/roboto-condensed/RobotoCondensed-Italic.woff2`,
                    ],
                    style: 'italic',
                },
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/roboto-condensed/RobotoCondensed-BoldItalic.woff2`,
                    ],
                    weight: 'bold',
                    style: 'italic',
                },
            ],
        },
        'Penumbra Serif Std': {
            editor: true,
            fonts: [
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/penumbra-serif-std/PenumbraSerifStd-Semibold.woff2`,
                    ],
                    weight: 600,
                },
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/penumbra-serif-std/PenumbraSerifStd-Bold.woff2`,
                    ],
                    weight: 'bold',
                },
            ],
        },
        'Penumbra Serif Std SC': {
            editor: false,
            fonts: [
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/penumbra-serif-std/PenumbraSerifStd-SemiboldCaps.woff2`,
                    ],
                    weight: 600,
                },
            ],
        },
        'Cosmere Dingbats': {
            editor: true,
            fonts: [
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/cosmere-dingbats/CosmereDingbats-Regular.woff2`,
                    ],
                },
            ],
        },
        'Shally Handwritten': {
            editor: true,
            fonts: [
                {
                    urls: [
                        `systems/${SYSTEM_ID}/assets/fonts/shally-handwritten/Shally-Regular.woff2`,
                    ],
                },
            ],
        },
    });
}
